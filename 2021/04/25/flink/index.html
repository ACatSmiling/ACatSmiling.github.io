<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Flink 流处理简介 Flink 官网：https:&#x2F;&#x2F;flink.apache.org&#x2F;   Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.  Apache Flink 是一个框架和分布">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink 入门">
<meta property="og:url" content="http://example.com/2021/04/25/flink/index.html">
<meta property="og:site_name" content="XiSun的博客">
<meta property="og:description" content="Flink 流处理简介 Flink 官网：https:&#x2F;&#x2F;flink.apache.org&#x2F;   Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.  Apache Flink 是一个框架和分布">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425162301927.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425162650326.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425165553312.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425165954248.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425170357898.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425171740295.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425171848097.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425172005916.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210425172711551.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210426131311252.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210426152309423.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210426142005687.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722110158056.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722105422030.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722105503741.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722105640710.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722111347256.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210426211322730.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722113043847.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722113205682.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427100238674.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427102627506.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427103016003.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427103111560.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427103303879.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427110351124.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722164432110.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722164519782.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210722164634809.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210723104757557.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210723112007722.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210723120009218.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427114221318.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427143509692.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427143943176.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210427151039156.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210721113548841.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210726145655263.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210726150221347.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210727163648248.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210727165729037.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210728144150779.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210728144213582.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210728171436010.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210729225604513.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210729231840293.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210730163822923.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210428091400383.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210429130112584.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210429131505870.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210429130649590.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210429131832931.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210504093752377.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210504093831460.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210504093142847.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210504094045828.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210504114937037.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210504165018734.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210506104650689.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210506131527104.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/bounded-unbounded.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210506215448736.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210507095457119.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210507101757027.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210507152955485.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210508161548431.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210508172915347.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210508173159146.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210508173336325.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210802131640148.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210804102019506.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210803225357577.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210803225534170.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210804104402570.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210804112151265.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210804095939601.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210804113522284.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210806151223965.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210809131823596.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210809231831959.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210806165916098.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210809154103959.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210809163414850.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210809163742517.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210809170614289.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810161328004.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810162207412.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810162427408.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810162656149.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810163340480.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810171057951.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810172052882.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810173003834.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810214432904.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810220612064.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810231203921.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210810231535649.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210812151826568.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210812173118769.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210812232358366.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210813095330140.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210813102001911.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210813104309481.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210813104522976.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210813104938956.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210813110109944.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210813111720234.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210817114056535.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210817164421379.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210817165913353.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210819163456431.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210819164346348.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210819164659342.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210819165853317.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210819170050982.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210822170147356.png">
<meta property="og:image" content="http://example.com/2021/04/25/flink/image-20210822170940295.png">
<meta property="article:published_time" content="2021-04-25T05:01:45.000Z">
<meta property="article:modified_time" content="2022-01-10T06:33:45.026Z">
<meta property="article:author" content="XiSun">
<meta property="article:tag" content="flink">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/04/25/flink/image-20210425162301927.png">

<link rel="canonical" href="http://example.com/2021/04/25/flink/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Flink 入门 | XiSun的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiSun的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learning is endless</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/flink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flink 入门
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 13:01:45" itemprop="dateCreated datePublished" datetime="2021-04-25T13:01:45+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-10 14:33:45" itemprop="dateModified" datetime="2022-01-10T14:33:45+08:00">2022-01-10</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>221k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:21</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Flink-流处理简介"><a href="#Flink-流处理简介" class="headerlink" title="Flink 流处理简介"></a>Flink 流处理简介</h2><ul>
<li>Flink 官网：<a target="_blank" rel="noopener" href="https://flink.apache.org/">https://flink.apache.org/</a></li>
</ul>
<ul>
<li><p>Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.</p>
<ul>
<li>Apache Flink 是一个<strong>框架</strong>和<strong>分布式处理引擎</strong>，用于对<strong>无界和有界数据流</strong>进行<strong>状态</strong>计算。</li>
</ul>
</li>
<li><p>为什么选择 Flink：</p>
<ul>
<li>流数据更真实地反映了我们的生活方式。</li>
<li>传统的数据架构是基于有限数据集的。</li>
<li>我们的目标：<ul>
<li>低延迟</li>
<li>高吞吐</li>
<li>结果的准确性和良好的容错性</li>
</ul>
</li>
</ul>
</li>
<li><p>哪些行业需要处理流数据：</p>
<ul>
<li>电商和市场营销<ul>
<li>数据报表、广告投放、业务流程需要。</li>
</ul>
</li>
<li>物联网 (IOT)<ul>
<li>传感器实时数据采集和显示、实时报警，交通运输业。</li>
</ul>
</li>
<li>电信业<ul>
<li>基站流量调配。</li>
</ul>
</li>
<li>银行和金融业<ul>
<li>实时结算和通知推送，实时检测异常行为。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="传统数据处理架构"><a href="#传统数据处理架构" class="headerlink" title="传统数据处理架构"></a>传统数据处理架构</h3><ul>
<li><p>事务处理架构：</p>
<img src="/2021/04/25/flink/image-20210425162301927.png" alt="image-20210425162301927" style="zoom:67%;">

<ul>
<li>特点：实时性好，但数据量大时，难以进行高并发处理。(低延迟、低吞吐)</li>
</ul>
</li>
<li><p>分析处理架构：</p>
<img src="/2021/04/25/flink/image-20210425162650326.png" alt="image-20210425162650326" style="zoom: 80%;">

<ul>
<li>特点：将数据从业务数据库复制到数仓，再进行分析和查询。能够处理大数据，高并发，但实时性差。(高延迟、高吞吐)</li>
</ul>
</li>
</ul>
<h3 id="有状态的流式处理-第一代"><a href="#有状态的流式处理-第一代" class="headerlink" title="有状态的流式处理 (第一代)"></a>有状态的流式处理 (第一代)</h3><img src="/2021/04/25/flink/image-20210425165553312.png" alt="image-20210425165553312" style="zoom:67%;">

<ul>
<li>数据存储于内存当中，达到 Periodic Checkpoint 条件时，执行持久化存储。能够做到低延迟、高吞吐，但分布式架构下，难以保证数据的顺序。</li>
</ul>
<h3 id="lambda-架构-第二代"><a href="#lambda-架构-第二代" class="headerlink" title="lambda 架构 (第二代)"></a>lambda 架构 (第二代)</h3><img src="/2021/04/25/flink/image-20210425165954248.png" alt="image-20210425165954248" style="zoom:67%;">

<ul>
<li>采用两套系统，同时保证低延迟和结果准确：<ul>
<li>批处理系统处理速度慢，但准确性高。</li>
<li>流处理系统处理速度快，但准确性差。</li>
<li>缺点：实现一个功能，但需要维护两套系统，开发成本高。</li>
</ul>
</li>
</ul>
<h3 id="流处理系统的演变"><a href="#流处理系统的演变" class="headerlink" title="流处理系统的演变"></a>流处理系统的演变</h3><img src="/2021/04/25/flink/image-20210425170357898.png" alt="image-20210425170357898" style="zoom:67%;">

<ul>
<li>Storm 能够做到低延迟，Spark Streaming 能做到高吞吐，而 Flink 不仅综合了它们的优点，同时还能做得更好。</li>
<li>Flink 可以看作第三代流处理架构。</li>
</ul>
<h3 id="Flink-的特点"><a href="#Flink-的特点" class="headerlink" title="Flink 的特点"></a>Flink 的特点</h3><ul>
<li><p><strong>事件驱动 (Event-driven)</strong></p>
<img src="/2021/04/25/flink/image-20210425171740295.png" alt="image-20210425171740295" style="zoom:80%;">
</li>
<li><p><strong>基于流的世界观</strong></p>
<img src="/2021/04/25/flink/image-20210425171848097.png" alt="image-20210425171848097" style="zoom:80%;">

<ul>
<li>在 Flink 的世界观中，一切都是由流组成的，离线数据是有界的流，实时数据是一个没有界限的流，这就是所谓的<strong>有界流</strong>和<strong>无界流</strong>。</li>
</ul>
</li>
<li><p><strong>分层 API</strong></p>
<img src="/2021/04/25/flink/image-20210425172005916.png" alt="image-20210425172005916" style="zoom:67%;">

<ul>
<li>越顶层越抽象，表达含义越简明，使用越方便。</li>
<li>越底层越具体，表达能力越丰富，使用越灵活。</li>
</ul>
</li>
<li><p>支持事件时间 (event-time) 和处理时间 (processing-time) 语义。</p>
</li>
<li><p>精确一次 (exactly-once) 的状态一致性保证。</p>
</li>
<li><p>低延迟，每秒处理数百万个事件，毫秒级延迟。</p>
</li>
<li><p>与众多常用存储系统的连接。</p>
</li>
<li><p>高可用，动态扩展，实现 7 * 24 小时全天候运行。</p>
</li>
</ul>
<h3 id="Flink-vs-Spark-Streaming"><a href="#Flink-vs-Spark-Streaming" class="headerlink" title="Flink vs Spark Streaming"></a>Flink vs Spark Streaming</h3><ul>
<li><p>Flink 是流处理 (stream) 架构，Spark Streaming 是微批处理 (micro-batching) 架构。</p>
<img src="/2021/04/25/flink/image-20210425172711551.png" alt="image-20210425172711551" style="zoom:67%;">
</li>
<li><p>数据模型</p>
<ul>
<li>Spark 采用 RDD 模型，Spark Streaming 的 DStream 实际上也就是一组组小批数据 RDD 的集合。—&gt; 底层实现基于微批</li>
<li>Flink 基本数据模型是数据流，以及事件 (Event) 序列。—&gt; 底层实现就是流，一个一个的处理</li>
</ul>
</li>
<li><p>运行时架构</p>
<ul>
<li>Spark 是批计算，将 DAG 划分为不同的 stage，一个完成后才可以计算下一个。—&gt; 需要等待</li>
<li>Flink 是标准的流执行模式，一个事件在一个节点处理完后可以直接发往下一个节点进行处理。—&gt; 不需要等待</li>
</ul>
</li>
</ul>
<h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><ul>
<li><p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.xisun.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xisun-flink<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.11.1<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>flink-streaming-java_2.12：Flink 底层组件依赖 scala，2.12 是 scala 版本。</p>
<p>Flink 1.11 版本之后，需要添加 flink-clients_2.12 依赖，否则会报异常 <code>java.lang.IllegalStateException: No ExecutorFactory found to execute the application.</code>。</p>
</blockquote>
</li>
</ul>
<h3 id="批处理实现-WordCount"><a href="#批处理实现-WordCount" class="headerlink" title="批处理实现 WordCount"></a>批处理实现 WordCount</h3><ul>
<li><p>hello.txt 文件内容：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello java</span><br><span class="line">hello world</span><br><span class="line">hello flink</span><br><span class="line">hello spark</span><br><span class="line">hello scala</span><br><span class="line">how are you</span><br><span class="line">fine thank you</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xisun.flink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.DataSet;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.ExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/25 20:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义类，实现FlatMapFunction接口</span></span><br><span class="line"><span class="comment">     * 参数说明：</span></span><br><span class="line"><span class="comment">     * 		String：传入数据类型</span></span><br><span class="line"><span class="comment">     * 		Tuple2&lt;String, Integer&gt;：传出数据类型</span></span><br><span class="line"><span class="comment">     * Tuple2&lt;T0, T1&gt;：Flink自身实现的元组，注意不要用scala的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapper</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String line, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 按空格分词</span></span><br><span class="line">            String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历所有word，包装成二元组输出</span></span><br><span class="line">            <span class="keyword">for</span> (String str : words) &#123;</span><br><span class="line">                <span class="comment">// 每一个word，都包装成一个二元组对象，并计数为1，然后用out收集</span></span><br><span class="line">                out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(str, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建批处理执行环境</span></span><br><span class="line">        ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从resources路径下的文件中单线程读取数据，是按照一行一行读取的</span></span><br><span class="line">        String inputPath = <span class="string">&quot;src/main/resources/hello.txt&quot;</span>;</span><br><span class="line">        DataSet&lt;String&gt; inputDataSet = env.readTextFile(inputPath).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.对数据集进行处理，按空格分词展开，转换成(word, 1)这样的二元组进行统计</span></span><br><span class="line">        DataSet&lt;Tuple2&lt;String, Integer&gt;&gt; resultSet = inputDataSet.flatMap(<span class="keyword">new</span> MyFlatMapper())</span><br><span class="line">                .groupBy(<span class="number">0</span>)<span class="comment">// 按照元组第一个位置的word分组</span></span><br><span class="line">                .sum(<span class="number">1</span>);<span class="comment">// 按照元组第二个位置上的数据求和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.打印输出</span></span><br><span class="line">        resultSet.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">(scala,<span class="number">1</span>)</span><br><span class="line">(you,<span class="number">2</span>)</span><br><span class="line">(flink,<span class="number">1</span>)</span><br><span class="line">(world,<span class="number">1</span>)</span><br><span class="line">(hello,<span class="number">5</span>)</span><br><span class="line">(are,<span class="number">1</span>)</span><br><span class="line">(java,<span class="number">1</span>)</span><br><span class="line">(thank,<span class="number">1</span>)</span><br><span class="line">(fine,<span class="number">1</span>)</span><br><span class="line">(how,<span class="number">1</span>)</span><br><span class="line">(spark,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="流处理实现-WordCount"><a href="#流处理实现-WordCount" class="headerlink" title="流处理实现 WordCount"></a>流处理实现 WordCount</h3><ul>
<li><p>基于文件读取数据，非真正的流式数据。</p>
</li>
<li><p>批处理 —&gt; 几组或所有数据到达后才处理；流处理 —&gt; 有数据来就直接处理，不等数据堆叠到一定数量级。</p>
</li>
<li><p><strong>这里不像批处理有 groupBy —&gt; 所有数据统一处理，而是用流处理的 keyBy —&gt; 每一个数据都对 key 进行 hash 计算，进行类似分区的操作，来一个数据就处理一次，所有中间过程都有输出！</strong></p>
</li>
<li><p><strong>并行度：本地 IDEA 执行环境的并行度默认就是计算机的 CPU 逻辑核数。</strong></p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xisun.flink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/25 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置并行度，可选操作，默认值=当前计算机的CPU逻辑核数(设置成1即为单线程处理)</span></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从resources路径下的文件中多线程读取数据，是按照一行一行读取的</span></span><br><span class="line">        String inputPath = <span class="string">&quot;src/main/resources/hello.txt&quot;</span>;</span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.readTextFile(inputPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.对数据集进行处理，按空格分词展开，转换成(word, 1)这样的二元组进行统计</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.打印输出</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不同于批处理，<code>env.execute()</code> 之前的代码，可以理解为是在定义任务，只有执行 <code>env.execute()</code> 后，Flink 才把前面的代码片段当作一个任务整体 (每个线程根据这个任务操作，并行处理流数据)。</p>
</blockquote>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line"><span class="number">2</span>&gt; (java,<span class="number">1</span>)</span><br><span class="line"><span class="number">7</span>&gt; (flink,<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span>&gt; (scala,<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span>&gt; (spark,<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span>&gt; (are,<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>&gt; (hello,<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>&gt; (hello,<span class="number">2</span>)</span><br><span class="line"><span class="number">6</span>&gt; (how,<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>&gt; (thank,<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>&gt; (hello,<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span>&gt; (hello,<span class="number">4</span>)</span><br><span class="line"><span class="number">5</span>&gt; (fine,<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span>&gt; (you,<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span>&gt; (you,<span class="number">2</span>)</span><br><span class="line"><span class="number">5</span>&gt; (world,<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>&gt; (hello,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为是流处理，所以所有中间过程都会被输出，前面的序号就是并行执行任务的线程编号。</p>
<p>线程最大编号为 7，是因为本机配置是 4 核 8 处理器，默认并行度为 8。</p>
</blockquote>
</li>
</ul>
<h3 id="流式数据源测试"><a href="#流式数据源测试" class="headerlink" title="流式数据源测试"></a>流式数据源测试</h3><ul>
<li><p>开启适用于 Linux 的 Windows 子系统。</p>
<img src="/2021/04/25/flink/image-20210426131311252.png" alt="image-20210426131311252" style="zoom: 80%;">
</li>
<li><p>第一次使用时，需要先安装 Ubuntu 系统：</p>
<img src="/2021/04/25/flink/image-20210426152309423.png" alt="image-20210426152309423" style="zoom:80%;">
</li>
<li><p>打开 Windows PowerShell，输入 <code>wsl</code> 命令进入系统，然后通过 <code>nc -lk &lt;port&gt;</code> 命令打开一个 Socket 服务，用于模拟实时的流数据。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xisun.flink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.utils.ParameterTool;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/26 10:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置并行度，默认值 = 当前计算机的CPU逻辑核数(设置成1即为单线程处理)</span></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从数据流中读取数据，Socket文本流只能单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.对数据集进行处理，按空格分词展开，转换成(word, 1)这样的二元组进行统计</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.打印输出</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>生产环境时，一般是在程序的启动参数中设置主机和端口号，此时，可以通过 ParameterTool 工具提取参数：</p>
<p><img src="/2021/04/25/flink/image-20210426142005687.png" alt="image-20210426142005687"></p>
<blockquote>
<p>参数设置格式：<code>--host localhost --port 7777</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用parameter tool工具从程序启动参数中提取配置项</span></span><br><span class="line">ParameterTool parameterTool = ParameterTool.fromArgs(args);</span><br><span class="line">String host = parameterTool.get(<span class="string">&quot;host&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> port = parameterTool.getInt(<span class="string">&quot;port&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.从数据流中读取数据</span></span><br><span class="line">DataStream&lt;String&gt; inputDataStream = env.socketTextStream(host, port);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>输出结果：在本地开启的 Socket 中输入数据，并观察 IDEA 的 Console 输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/Users/Xisun/Desktop$ nc -lk 7777</span><br><span class="line">hello world</span><br><span class="line">hello flink</span><br><span class="line">hello scala</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line"><span class="number">3</span>&gt; (world,<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>&gt; (hello,<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span>&gt; (flink,<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>&gt; (hello,<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span>&gt; (scala,<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>&gt; (hello,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于输出结果，某项数据对应的次数最大值，是该数据统计到当前时间的最终结果。</p>
</blockquote>
</li>
</ul>
<h2 id="Flink-的部署"><a href="#Flink-的部署" class="headerlink" title="Flink 的部署"></a>Flink 的部署</h2><ul>
<li><p>下载地址：<a target="_blank" rel="noopener" href="https://flink.apache.org/downloads.html">https://flink.apache.org/downloads.html</a></p>
</li>
<li><p>最新版本：</p>
<p><img src="/2021/04/25/flink/image-20210722110158056.png" alt="image-20210722110158056"></p>
</li>
<li><p>全部稳定版本：<a target="_blank" rel="noopener" href="https://flink.apache.org/downloads.html#all-stable-releases">https://flink.apache.org/downloads.html#all-stable-releases</a></p>
<p><img src="/2021/04/25/flink/image-20210722105422030.png" alt="image-20210722105422030"></p>
<p><img src="/2021/04/25/flink/image-20210722105503741.png" alt="image-20210722105503741"></p>
</li>
<li><p>对于新版本的 Flink (1.7 之后)，需要额外下载 Hadoop 依赖，否则无法使用 Hadoop 支持的 Yarn 资源：</p>
<p><img src="/2021/04/25/flink/image-20210722105640710.png" alt="image-20210722105640710"></p>
</li>
</ul>
<h3 id="Standalone-模式"><a href="#Standalone-模式" class="headerlink" title="Standalone 模式"></a>Standalone 模式</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li><p>地址：<a target="_blank" rel="noopener" href="https://www.apache.org/dyn/closer.lua/flink/flink-1.13.1/flink-1.13.1-bin-scala_2.12.tgz">https://www.apache.org/dyn/closer.lua/flink/flink-1.13.1/flink-1.13.1-bin-scala_2.12.tgz</a></p>
</li>
<li><p>Flink 组件：</p>
<p><img src="/2021/04/25/flink/image-20210722111347256.png" alt="image-20210722111347256"></p>
</li>
<li><p>其他组件 (Hadoop)：</p>
<p><img src="/2021/04/25/flink/image-20210426211322730.png" alt="image-20210426211322730"></p>
</li>
<li><p>解压到指定目录，并把 Hadoop 的组件添加到 Flink 解压路径的 lib 目录下：</p>
<p><img src="/2021/04/25/flink/image-20210722113043847.png" alt="image-20210722113043847"></p>
<p><img src="/2021/04/25/flink/image-20210722113205682.png" alt="image-20210722113205682"></p>
</li>
<li><p>打开 wsl 控制台，安装 JDK：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/d/Program Files/flink-1.13.1$ sudo apt update</span><br><span class="line">xisun@DESKTOP-OM8IACS:/mnt/d/Program Files/flink-1.13.1$ sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/d/Program Files/flink-1.13.1$ java -version</span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_282&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_282-8u282-b08-0ubuntu1~20.04-b08)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.282-b08, mixed mode)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Ubuntu 20.04 系统下安装 OpenJDK 11 和 OpenJDK 8 的方法：<a target="_blank" rel="noopener" href="https://ywnz.com/linuxjc/6984.html">https://ywnz.com/linuxjc/6984.html</a></p>
</blockquote>
</li>
<li><p>查看 JDK 安装路径，并在 Flink 安装目录的 conf/flink-conf.yaml 文件中配置 Java 环境：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Java</span></span><br><span class="line"><span class="attr">env.java.home:</span> <span class="string">/usr/lib/jvm/java-8-openjdk-amd64</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议不要使用 Windows 系统下安装的 JDK 路径，可能会有问题。</p>
</blockquote>
</li>
<li><p>配置主机和从机 (未验证)：</p>
<ul>
<li><p>修改 conf/flink-conf.yaml 文件，配置主机地址：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The external address of the host on which the JobManager runs and can be</span></span><br><span class="line"><span class="comment"># reached by the TaskManagers and any clients which want to connect. This setting</span></span><br><span class="line"><span class="comment"># is only used in Standalone mode and may be overwritten on the JobManager side</span></span><br><span class="line"><span class="comment"># by specifying the --host &lt;hostname&gt; parameter of the bin/jobmanager.sh executable.</span></span><br><span class="line"><span class="comment"># In high availability mode, if you use the bin/start-cluster.sh script and setup</span></span><br><span class="line"><span class="comment"># the conf/masters file, this will be taken care of automatically. Yarn/Mesos</span></span><br><span class="line"><span class="comment"># automatically configure the host name based on the hostname of the node where the</span></span><br><span class="line"><span class="comment"># JobManager runs.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobmanager.rpc.address:</span> <span class="string">hadoop1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 conf/workers 文件，配置从机地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop2</span><br><span class="line">hadoop3</span><br></pre></td></tr></table></figure>
</li>
<li><p>将主机 Flink 安装文件，派发给从机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xsync flink-1.13.1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>启动 Flink 集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/Users/XiSun/Desktop$ bash /mnt/d/Program\ Files/flink-1.13.1/bin/start-cluster.sh</span><br><span class="line">Starting cluster.</span><br><span class="line">Starting standalonesession daemon on host DESKTOP-OM8IACS.</span><br><span class="line">Starting taskexecutor daemon on host DESKTOP-OM8IACS.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/Users/XiSun/Desktop$ jps</span><br><span class="line">7347 Jps</span><br><span class="line">6956 StandaloneSessionClusterEntrypoint</span><br><span class="line">7246 TaskManagerRunner</span><br></pre></td></tr></table></figure>
</li>
<li><p>前端页面访问 <code>localhost:8081</code>，可以对 Flink 集群和任务进行监控管理。(8081 是默认端口)</p>
<p><img src="/2021/04/25/flink/image-20210427100238674.png" alt="image-20210427100238674"></p>
<blockquote>
<p>可以查看任务分配，内存使用，Log 日志，标准输出 (控制台) 等。</p>
</blockquote>
</li>
</ul>
<h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><ul>
<li><p>Web 页面提交</p>
<ul>
<li><p>上传 Jar 包：Submit New Job —&gt; Add New，将打包好的 Jar 包添加上来。</p>
<p><img src="/2021/04/25/flink/image-20210427102627506.png" alt="image-20210427102627506"></p>
</li>
<li><p>设置启动参数：</p>
<p><img src="/2021/04/25/flink/image-20210427103016003.png" alt="image-20210427103016003"></p>
<ul>
<li><p>Show Plan 查看任务执行计划：</p>
<p><img src="/2021/04/25/flink/image-20210427103111560.png" alt="image-20210427103111560"></p>
</li>
</ul>
</li>
<li><p>Submit 提交任务：</p>
<ul>
<li><p>提交失败：</p>
<p><img src="/2021/04/25/flink/image-20210427103303879.png" alt="image-20210427103303879"></p>
<blockquote>
<p>提交任务时，如果 slot 的数量低于设置的线程数量，会提交失败，会一直等待分配更多的资源。—&gt; 增加 slot 数量或者降低任务线程数量。</p>
</blockquote>
</li>
<li><p>提交成功：(需要先启动本机的 socket 服务)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/Users/XiSun/Desktop$ nc -tl 7777</span><br><span class="line">hello world</span><br><span class="line">hello flink</span><br><span class="line">hellojava^[[D^[[D^[[D</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/25/flink/image-20210427110351124.png" alt="image-20210427110351124"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>命令行提交</p>
<ul>
<li><p>准备数据文件，把含数据文件的文件夹，分发到 taskmanage 所在的机器中 (如果需要)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xsync flink</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果从文件中读取数据，由于是从本地磁盘读取，实际任务会被分发到 taskmanage 的机器中，所以要把数据文件分发到该机器上。</p>
</blockquote>
</li>
<li><p>提交命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/d/Program Files/flink-1.13.1/bin$ ./flink run -p 4 -c cn.xisun.flink.StreamWordCount /mnt/d/JetBrainsWorkSpace/IDEAProjects/xisun-flink/target/xisun-flink-1.0-SNAPSHOT.jar --host localhost --port 7777</span><br><span class="line">Job has been submitted with JobID 470883e75e676e9c538d13f509ddc6cc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>./flink run：启动命令；-p 参数：指定并行度；-c 参数：指定 Jar 包运行的主程序。</p>
</blockquote>
</li>
<li><p>查看结果，如果输出到控制台，应该在 taskmanager 下查看；如果计算结果输出到文件，同样会保存到 taskmanage 的机器下，不会在 jobmanage 下。</p>
<p><img src="/2021/04/25/flink/image-20210722164432110.png" alt="image-20210722164432110"></p>
<blockquote>
<p>如果 Job 要求的 Task Slots 数大于可用的 Task Slots，Job 提交时会一直等待，直到分配到足够的资源。</p>
<p>flink-conf.yaml 配置文件中，<code>taskmanager.numberOfTaskSlots: 8</code> 用于配置可用的最大 slots 数，默认为 1，一般设置与当前主机 CPU 最大逻辑核心数相同。</p>
</blockquote>
<p><img src="/2021/04/25/flink/image-20210722164519782.png" alt="image-20210722164519782"></p>
<p>  <img src="/2021/04/25/flink/image-20210722164634809.png" alt="image-20210722164634809"></p>
</li>
<li><p>查看提交的 Job 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/d/Program Files/flink-1.13.1/bin$ ./flink list</span><br><span class="line">Waiting <span class="keyword">for</span> response...</span><br><span class="line">------------------ Running/Restarting Jobs -------------------</span><br><span class="line">22.07.2021 16:41:11 : 470883e75e676e9c538d13f509ddc6cc : Flink Streaming Job (RUNNING)</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">No scheduled <span class="built_in">jobs</span>.</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消 Job：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/d/Program Files/flink-1.13.1/bin$ ./flink cancel 470883e75e676e9c538d13f509ddc6cc</span><br><span class="line">Cancelling job 470883e75e676e9c538d13f509ddc6cc.</span><br><span class="line">Cancelled job 470883e75e676e9c538d13f509ddc6cc.</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看包含已取消的 Job 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/d/Program Files/flink-1.13.1/bin$ ./flink list -a</span><br><span class="line">Waiting <span class="keyword">for</span> response...</span><br><span class="line">No running <span class="built_in">jobs</span>.</span><br><span class="line">No scheduled <span class="built_in">jobs</span>.</span><br><span class="line">---------------------- Terminated Jobs -----------------------</span><br><span class="line">22.07.2021 16:41:11 : 470883e75e676e9c538d13f509ddc6cc : Flink Streaming Job (CANCELED)</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="Yarn-模式"><a href="#Yarn-模式" class="headerlink" title="Yarn 模式"></a>Yarn 模式</h3><ul>
<li>以 Yarn 模式部署 Flink 任务时，要求 Flink 是有 Hadoop 支持的版本，Hadoop 环境需要保证版本在 2.2 以上，并且集群中安装有 HDFS 服务。</li>
</ul>
<h4 id="Flink-on-Yarn"><a href="#Flink-on-Yarn" class="headerlink" title="Flink on Yarn"></a>Flink on Yarn</h4><ul>
<li><p>Flink 提供了两种在 Yarn 上运行的模式，分别为 Session-Cluster 模式和 Per-Job-Cluster 模式。</p>
</li>
<li><p>Session-Cluster 模式</p>
<p><img src="/2021/04/25/flink/image-20210723104757557.png" alt="image-20210723104757557"></p>
<ul>
<li>Session-Cluster 模式需要先在 Yarn 中初始化一个 Flink 会话集群，开辟指定的资源。之后，所有任务都向这个 Flink 会话集群提交。这个 Flink 会话集群会常驻在 Yarn 集群中，除非手动停止。</li>
<li>Flink 会话集群所占的资源，会一直保持不变。提交任务时，如果资源满了，下一个任务就无法提交，只有等到 Yarn 中的其中一个任务执行完成后，释放了资源，下个任务才会正常提交。</li>
<li>Flink 会话集群中所有任务共享 Dispatcher 和 ResourceManager；共享资源。</li>
<li>Session-Cluster 模式适合规模小执行时间短的任务。</li>
</ul>
</li>
<li><p>Per-Job-Cluster 模式</p>
<p><img src="/2021/04/25/flink/image-20210723112007722.png" alt="image-20210723112007722"></p>
<ul>
<li><strong>Per-Job-Cluster 模式每次提交任务时，都会创建一个新的 Flink 集群，各任务之间互相独立，互不影响，方便管理。任务执行完成之后创建的集群也会消失。</strong></li>
<li>一个 Job 会对应一个集群，每提交一个任务会根据自身的情况，单独向 Yarn 申请资源，直到任务执行完成，一个任务的失败与否并不会影响下一个任务的正常提交和运行。</li>
<li>每个任务独享 Dispatcher 和 ResourceManager，按需接受资源申请；适合规模大长时间运行的作业。</li>
</ul>
</li>
</ul>
<h4 id="Session-Cluster"><a href="#Session-Cluster" class="headerlink" title="Session-Cluster"></a>Session-Cluster</h4><ul>
<li><p>启动 Hadoop 集群 (略)。</p>
</li>
<li><p>启动 yarn-session：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./yarn-session.sh -n 2 -s 2 -jm 1024 -tm 1024 -nm <span class="built_in">test</span> -d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-n (–container)：TaskManager 的数量，新版本此参数应该无效了。<br>-s (–slots)： 每个 TaskManager 的 slot 数量，默认一个 slot 一个 core，默认每个 taskmanager 的 slot 的个数为 1，有时可以多一些 taskmanager，做冗余。<br>-jm：JobManager 的内存，单位 MB。<br>-tm：每个 taskmanager 的内存，单位 MB。<br>-nm：Yarn 的 appName (出现在 Yarn 的 ui 上的名字)。<br>-d：后台执行。</p>
</blockquote>
</li>
<li><p>提交任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./flink run -p 4 -d -c cn.xisun.flink.StreamWordCount /mnt/d/JetBrainsWorkSpace/IDEAProjects/xisun-flink/target/xisun-flink-1.0-SNAPSHOT.jar --host localhost --port 7777</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Flink 中，如果启动了 yarn-session，提交任务时，默认提交到 yarn-session 中的 Flink 集群；如果没有启动 yarn-session，则提交到 Standalone 中的 Flink 集群。</p>
</blockquote>
</li>
<li><p>到 Yarn 控制台查看任务状态：</p>
<p><img src="/2021/04/25/flink/image-20210723120009218.png" alt="image-20210723120009218"></p>
</li>
<li><p>取消 yarn-session：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn application --<span class="built_in">kill</span> application_1577588252906_0001</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Per-Job-Cluster"><a href="#Per-Job-Cluster" class="headerlink" title="Per-Job-Cluster"></a>Per-Job-Cluster</h4><ul>
<li><p>启动 Hadoop 集群 (略)。</p>
</li>
<li><p>不启动 yarn-session ，直接提交任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./flink run –m yarn-cluster -p 4 -d -c cn.xisun.flink.StreamWordCount /mnt/d/JetBrainsWorkSpace/IDEAProjects/xisun-flink/target/xisun-flink-1.0-SNAPSHOT.jar --host localhost --port 7777</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按参数名称提取参数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./flink run -m yarn-cluster -p 6 -d reaction-extractor-1.0-SNAPSHOT.jar extractor-patent extractor-reaction extractor-patent-timeout y</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按参数位置提取参数。</p>
</blockquote>
</li>
<li><p>查看任务和关闭任务，使用 Yarn 命令处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看yarn上面的资源使用情况命令，ctrl+c退出</span></span><br><span class="line">$ yarn top</span><br><span class="line"><span class="comment"># 查看yarn上运行的任务列表命令，如果集群有krb认证的话，需要先kinit，认证后可以看到所有正在运行的任务</span></span><br><span class="line">$ yarn application -list</span><br><span class="line"><span class="comment"># 查看yarn上运行的指定状态的任务列表命令</span></span><br><span class="line">$ yarn application -list -appStates RUNNING</span><br><span class="line"><span class="comment"># 查看yarn指定任务的状态信息命令</span></span><br><span class="line">$ yarn application -status &lt;applicationId&gt; </span><br><span class="line"><span class="comment"># 查看yarn指定application任务日志命令，可以选择输出到本地文件</span></span><br><span class="line">$ yarn logs -applicationId &lt;applicationId&gt; &gt; yarn.log</span><br><span class="line"><span class="comment"># yarn logs -applicationId application_1606730935892_0095 &gt; yarn.log</span></span><br><span class="line"><span class="comment"># yarn logs -applicationId application_1606730935892_0095 &gt; yarn-2001-2005.log</span></span><br><span class="line"><span class="comment"># yarn logs -applicationId application_1606730935892_0093 --size 3145728 &gt; yarn-1996-2000.log</span></span><br><span class="line"><span class="comment"># kill yarn application命令</span></span><br><span class="line">$ yarn application -<span class="built_in">kill</span> &lt;applicationId&gt;</span><br><span class="line"><span class="comment"># kill yarn job命令</span></span><br><span class="line">$ yarn job -<span class="built_in">kill</span> &lt;jobId&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Kubernetes-部署"><a href="#Kubernetes-部署" class="headerlink" title="Kubernetes 部署"></a>Kubernetes 部署</h3><ul>
<li><p>容器化部署是目前业界很流行的一项技术，基于 Docker 镜像运行能够让用户更加方便地对应用进行管理和运维。容器管理工具中最为流行的就是 Kubernetes (k8s)，而 Flink 也在最近的版本中支持了 k8s 部署模式。</p>
</li>
<li><p>搭建 Kubernetes 集群 (略)。</p>
</li>
<li><p>配置各组件的 yaml 文件。</p>
<ul>
<li>在 k8s 上构建 Flink Session Cluster，需要将 Flink 集群的组件对应的 Docker 镜像分别在 k8s 上启动，包括 JobManager、TaskManager、JobManagerService 三个镜像服务，每个镜像服务都可以从中央镜像仓库中获取。</li>
</ul>
</li>
<li><p>启动 Flink Session Cluster：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 启动 jobmanager-service 服务</span><br><span class="line">$ kubectl create -f jobmanager-service.yaml</span><br><span class="line"></span><br><span class="line">// 启动 jobmanager-deployment 服务</span><br><span class="line">$ kubectl create -f jobmanager-deployment.yaml</span><br><span class="line"></span><br><span class="line">// 启动 taskmanager-deployment 服务</span><br><span class="line">$ kubectl create -f taskmanager-deployment.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 Flink UI 页面。集群启动后，就可以通过 JobManagerServicers 中配置的 WebUI 端口，用浏览器输入以下 url 来访问 Flink UI 页面了：<code>http://&#123;JobManagerHost:Port&#125;/api/v1/namespaces/default/services/flink-jobmanager:ui/proxy</code></p>
</li>
</ul>
<h2 id="Flink-的运行架构"><a href="#Flink-的运行架构" class="headerlink" title="Flink 的运行架构"></a>Flink 的运行架构</h2><h3 id="Flink-运行时的组件"><a href="#Flink-运行时的组件" class="headerlink" title="Flink 运行时的组件"></a>Flink 运行时的组件</h3><img src="/2021/04/25/flink/image-20210427114221318.png" alt="image-20210427114221318" style="zoom:67%;">

<h4 id="作业管理器-JobManager"><a href="#作业管理器-JobManager" class="headerlink" title="作业管理器 (JobManager)"></a>作业管理器 (JobManager)</h4><ul>
<li>控制一个应用程序执行的主进程，也就是说，<strong>每个应用程序都会被一个不同的 JobManager 所控制执行。</strong></li>
<li>JobManager 会先接收到要执行的应用程序，这个应用程序会包括：作业图 (JobGraph)、逻辑数据流图 (logical dataflow graph) 和打包了所有的类、库和其它资源的 Jar 包。</li>
<li>JobManager 会把 JobGraph 转换成一个物理层面的数据流图，这个图被叫做 “执行图” (ExecutionGraph)，包含了所有可以并发执行的任务。</li>
<li>JobManager 会向资源管理器 (ResourceManager) 请求执行任务必要的资源，也就是任务管理器 (TaskManager) 上的插槽 (slot)。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的 TaskManager 上。而在运行过程中，JobManager 会负责所有需要中央协调的操作，比如说检查点 (checkpoints) 的协调。</li>
</ul>
<h4 id="任务管理器-TaskManager"><a href="#任务管理器-TaskManager" class="headerlink" title="任务管理器 (TaskManager)"></a>任务管理器 (TaskManager)</h4><ul>
<li>Flink 中的工作进程。通常在 Flink 中会有多个 TaskManager 运行，每一个 TaskManager 都包含了一定数量的插槽 (slots)。插槽的数量限制了 TaskManager 能够执行的任务数量。</li>
<li>启动之后，<strong>TaskManager 会向资源管理器 (ResourceManager) 注册它的插槽；</strong>收到资源管理器 (ResourceManager) 的指令后，TaskManager 就会将一个或者多个插槽提供给 JobManager 调用，然后 JobManager 就可以向插槽分配任务 (tasks) 来执行了。</li>
<li>在执行过程中，一个 TaskManager 可以跟其它运行同一应用程序的 TaskManager 交换数据。</li>
</ul>
<h4 id="资源管理器-ResourceManager"><a href="#资源管理器-ResourceManager" class="headerlink" title="资源管理器 (ResourceManager)"></a>资源管理器 (ResourceManager)</h4><ul>
<li>主要负责管理任务管理器 (TaskManager) 的插槽 (slot)，TaskManger 插槽是 Flink 中定义的处理资源单元。</li>
<li>Flink 为不同的环境和资源管理工具提供了不同资源管理器，比如 YARN、Mesos、K8s，以及 Standalone 部署。</li>
<li>当 JobManager 申请插槽资源时，ResourceManager 会将有空闲插槽的 TaskManager 分配给 JobManager。如果 ResourceManager 没有足够的插槽来满足 JobManager 的请求，它还可以向资源提供平台发起会话，以提供启动 TaskManager 进程的容器。</li>
<li>另外，<strong>ResourceManager 还负责终止空闲的 TaskManager，释放计算资源。</strong></li>
</ul>
<h4 id="分发器-Dispatcher"><a href="#分发器-Dispatcher" class="headerlink" title="分发器 (Dispatcher)"></a>分发器 (Dispatcher)</h4><ul>
<li>可以跨作业运行，它为应用提交提供了 REST 接口。</li>
<li>当一个应用被提交执行时，分发器就会启动并将应用移交给一个 JobManager。</li>
<li>Dispatcher 也会启动一个 Web UI，用来方便地展示和监控作业执行的信息。</li>
<li>Dispatcher 在架构中可能并不是必需的，这取决于应用提交运行的方式。</li>
</ul>
<h3 id="任务提交流程"><a href="#任务提交流程" class="headerlink" title="任务提交流程"></a>任务提交流程</h3><ul>
<li><p>当一个应用提交执行时，Flink 的各个组件交互协作的过程如下：</p>
<img src="/2021/04/25/flink/image-20210427143509692.png" alt="image-20210427143509692" style="zoom:80%;">

<blockquote>
<p>上图中，步骤 7 指 TaskManager 为 JobManager 提供 slots，步骤 8 表示 JobManager 提交要在 slots 中执行的任务给 TaskManager。</p>
</blockquote>
</li>
<li><p>上图是从一个较为高层级的视角来看应用中各组件的交互协作。如果部署的集群环境不同 (例如 Yarn，Mesos，Kubernetes，Standalone等)，其中一些步骤可以被省略，或是有些组件会运行在同一个 JVM 进程中。</p>
</li>
</ul>
<ul>
<li><p>具体地，如果我们将 Flink 集群部署到 Yarn 上，那么就会有如下的提交流程：</p>
<img src="/2021/04/25/flink/image-20210427143943176.png" alt="image-20210427143943176" style="zoom:80%;">
- Flink 任务提交后，Client 向 HDFS 上传 Flink 的 Jar 包和配置。
- 之后，Client 向 Yarn ResourceManager 提交任务，Yarn ResourceManager 分配 Container 资源并通知对应的 NodeManager 启动 ApplicationMaster.
- ApplicationMaster 启动后加载 Flink 的 Jar 包和配置构建环境，然后启动 JobManager，之后，**JobManager 向 Flink 自身的 ResourceManager 申请资源，Flink 自身的 ResourceManager 再向 Yarn 的 ResourceManager 申请资源 (因为是 Yarn 模式，所有资源归 Yarn 的 ResourceManager 管理)，**申请到资源后，启动 TaskManager。
- Yarn ResourceManager 分配 Container 资源后 ， 由 ApplicationMaster 通知资源所在节点的 NodeManager 启动 TaskManager。
- NodeManager 加载 Flink 的 Jar 包和配置构建环境并启动 TaskManager，TaskManager 启动后向 JobManager 发送心跳包，并等待 JobManager 向其分配任务。

</li>
</ul>
<h3 id="任务调度原理"><a href="#任务调度原理" class="headerlink" title="任务调度原理"></a>任务调度原理</h3><img src="/2021/04/25/flink/image-20210427151039156.png" alt="image-20210427151039156" style="zoom:80%;">

<ul>
<li>客户端不是运行时和程序执行的一部分，但它用于准备并发送 dataflow (JobGraph) 给 Master (JobManager)，然后，客户端断开连接或者维持连接以等待接收计算结果。</li>
<li>当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。</li>
<li>Client 为提交 Job 的客户端，可以是运行在任何机器上 (与 JobManager 环境连通即可)。提交 Job 后，Client 可以结束进程 (Streaming 的任务)，也可以不结束并等待结果返回。</li>
<li>JobManager 会产生一个执行图 (Dataflow Graph)，主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 Jar 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。</li>
<li>TaskManager 在启动的时候就设置好了槽位数 (Slot)，每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。(如果一个 Slot 中启动多个线程，那么这几个线程类似 CPU 调度一样共用同一个 slot)</li>
</ul>
<h4 id="并行度-Parallelism"><a href="#并行度-Parallelism" class="headerlink" title="并行度 (Parallelism)"></a>并行度 (Parallelism)</h4><ul>
<li><p>Flink 程序的执行具有并行、分布式的特性。</p>
</li>
<li><p>在执行过程中，一个流 (Stream) 包含一个或多个分区 (stream partition)，而每一个算子 (operator) 可以包含一个或多个子任务 (operator subtask)，这些子任务在不同的线程、不同的物理机或不同的容器中彼此互不依赖地执行。</p>
</li>
<li><p>一个特定算子的子任务 (subtask) 的个数，称之为该算子的并行度 (parallelism)。一个程序中，不同的算子可能具有不同的并行度。一般情况下，一个流程序的并行度，可以认为就是其所有算子中，设置最大的那个算子的并行度。</p>
<p><img src="/2021/04/25/flink/image-20210721113548841.png" alt="image-20210721113548841"></p>
</li>
<li><p><strong>并行度优先级：具体算子设置的并行度 &gt; 程序全局设置的并行度 &gt; 提交 Job 时设置的并行度 &gt; flink-conf.yaml 配置文件默认的并行度。</strong></p>
</li>
<li><p>并行度，可以简单理解为：并行执行任务的程度。Flink 程序中，有四种方式设置并行度：</p>
<ul>
<li>通过 <code>env.setParallelism(1);</code> 设置全局的并行度。</li>
<li>通过  <code>setParallelism()</code> 设置每一个算子的并行度。</li>
<li>提交任务时，通过 Web 页面直接指定，或命令行使用 -p 参数指定并行度。</li>
<li>通过 flink-conf.yaml 配置文件配置。 </li>
</ul>
</li>
<li><p>并行度 parallelism 是动态概念，即 TaskManager 运行程序时实际使用的并发能力。在 flink-conf.yaml 配置文件中，通过 <code>parallelism.default</code> 设置并行度，默认为 1。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The parallelism used for programs that did not specify and other parallelism.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">parallelism.default:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="TaskManger-与-Slots"><a href="#TaskManger-与-Slots" class="headerlink" title="TaskManger 与 Slots"></a>TaskManger 与 Slots</h4><ul>
<li><p>Flink 中每一个 worker (TaskManager) 都是一个 JVM 进程 (Processes)，它可能会在独立的线程 (Threads) 上执行一个或多个 subtask。为了控制一个 worker 能接收多少个 task，worker 通过 task slot 来进行控制 (一个 worker 至少有一个 task slot)。</p>
</li>
<li><p>每个 task slot 表示 TaskManager 拥有资源的一个固定大小的子集。假如一个 TaskManager 有三个 slot，那么它会将其管理的内存分成三份给各个 slot。资源 slot 化意味着一个 subtask 将不需要跟来自其他 job 的 subtask 竞争被管理的内存，取而代之的是它将拥有一定数量的内存储备。需要注意的是，这里不会涉及到 CPU 的隔离，slot 目前仅仅用来隔离 task 的受管理的内存。</p>
<p><img src="/2021/04/25/flink/image-20210726145655263.png" alt="image-20210726145655263"></p>
<ul>
<li>slot 实际上就是，执行一个独立任务所需要的计算资源的最小单元 (主要就是 CPU 和内存资源)。</li>
<li>当前 Flink 架构中，每一个 slot 所占的内存是隔离开的，即独享内存资源，互不影响。但 CPU 资源是共享的，如果一个 CPU 被多个 slot 使用，那 CPU 就是时间片上的一个轮转状态，被多个 slot 轮流使用。</li>
<li>通过调整 task slot 的数量，允许用户定义 subtask 之间如何互相隔离。如果一个 TaskManager 只有一个 slot，那将意味着每个 task group 运行在独立的 JVM 中 (该 JVM 可能是通过一个特定的容器启动的)，而一个 TaskManager 多个 slot，则意味着更多的 subtask 可以共享同一个 JVM。而在同一个 JVM 进程中的 task 将共享 TCP 连接 (基于多路复用) 和心跳消息。它们也可能共享数据集和数据结构，因此这减少了每个 task 的负载。</li>
</ul>
</li>
<li><p>默认情况下，Flink 允许子任务共享 slot，即使它们是不同任务的子任务。 这样的结果是，一个 slot 可以保存任务的整个管道 (也就是任务的一个完整流程)。</p>
<p><img src="/2021/04/25/flink/image-20210726150221347.png" alt="image-20210726150221347"></p>
<ul>
<li>从上图可以看出，Stream 的并行度为 6，共有 13 个任务，但实际上，只用了 6 个 slot 就完成了全部任务的执行。</li>
</ul>
</li>
<li><p>共享 slot 的好处：在一个 slot 中可以保存任务的整个管道，即使其他的 slot 挂掉了，也不会影响任务的完整执行，保证了程序的健壮性。另外，如果某个子任务比较占用 CPU，共享 slot 能够充分调用 CPU 的处理能力，防止出现有的 CPU 极其空闲，有的 CPU 极其繁忙。</p>
</li>
<li><p>共享 slot 的前提：必须是一个 Stream 中先后发生的不同的子任务。比如上图中，不同的 source-map 算子任务，就只能放在不同的 slot 中，不能共享一个 slot，因为相同的子任务，如果共享一个 slot，可能会导致这几个相同的子任务间数据的混淆。</p>
</li>
<li><p>Task Slot 是静态的概念，是指 TaskManager 具有的并发执行能力。在 flink-conf.yaml 配置文件中，通过 <code>taskmanager.numberOfTaskSlots</code> 设置 TaskManager 中的 slot 数量，默认为 1，<strong>一般应设置为与当前主机 CPU 的逻辑核心数相同。</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of task slots that each TaskManager offers. Each slot runs one parallel pipeline.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">taskmanager.numberOfTaskSlots:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Flink 中，可以通过 <code>slotSharingGroup()</code> 设置每一个算子所属的 slot 共享组。 如果不同算子的 slot 共享组不同，则运行时一定要占用不同的 slot。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        ParameterTool parameterTool = ParameterTool.fromArgs(args);</span><br><span class="line">        String host = parameterTool.get(<span class="string">&quot;host&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> port = parameterTool.getInt(<span class="string">&quot;port&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(host, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不配置时，默认slot共享组为default，后面的算子默认与前面的算子同一slot共享组</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; resultStream = inputDataStream</span><br><span class="line">                .flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper()).slotSharingGroup(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>).setParallelism(<span class="number">2</span>).slotSharingGroup(<span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/25/flink/image-20210727163648248.png" alt="image-20210727163648248"></p>
<blockquote>
<p>上面代码中，source 算子是 default 共享组，flatMap 是 green 共享组，sum 是 red 共享组，print 与 sum 相同。提交上面这个任务时，先考虑分组，再考虑每个分组内最大的并行度，相加之后，即为所需的 slot 数量。因此，上面的任务，至少需要 4 个 slot。</p>
</blockquote>
</li>
</ul>
<h4 id="并行子任务的分配"><a href="#并行子任务的分配" class="headerlink" title="并行子任务的分配"></a>并行子任务的分配</h4><ul>
<li><p>假设一个 JobGraph 如下图左所示，则可以看出，一共有 16 个子任务。如果没有自定义 slot 共享组，则如下图右所示，只需要 4 个 slot 就可以完成任务。</p>
<p><img src="/2021/04/25/flink/image-20210727165729037.png" alt="image-20210727165729037"></p>
</li>
<li><p>假设一共有 3 个 TaskManager，每一个 TaskManager 中分配了 3 个 TaskSlot，也就是每个 TaskManager 可以接收 3 个 task，一共有 9 个 TaskSlot。在 Example 1 中，如果我们设置 <code>parallelism.default=1</code>，即运行程序默认的并行度为 1，那么 9 个 TaskSlot 只用了 1个，会有 8 个空闲。因此，设置合适的并行度才能提高效率，如 Example 2 ~ 4 所示。</p>
<p><img src="/2021/04/25/flink/image-20210728144150779.png" alt="image-20210728144150779"></p>
<p><img src="/2021/04/25/flink/image-20210728144213582.png" alt="image-20210728144213582"></p>
</li>
</ul>
<h4 id="程序与数据流-DataFlow"><a href="#程序与数据流-DataFlow" class="headerlink" title="程序与数据流 (DataFlow)"></a>程序与数据流 (DataFlow)</h4><p><img src="/2021/04/25/flink/image-20210728171436010.png" alt="image-20210728171436010"></p>
<ul>
<li><p>所有的 Flink 程序都是由三部分组成的：Source、Transformation 和 Sink。</p>
<ul>
<li>Source 负责读取数据源，Transformation 利用各种算子进行处理加工，Sink 负责输出。</li>
</ul>
</li>
<li><p>在运行时，Flink 上运行的程序会被映射成 “逻辑数据流” (dataflows)，它包含了这三部分。</p>
</li>
<li><p>每一个 dataflow 以一个或多个 source 开始，以一个或多个 sink 结束。dataflow 类似于任意的有向无环图 (DAG) (有方向非环形)。</p>
<p><img src="/2021/04/25/flink/image-20210729225604513.png" alt="image-20210729225604513"></p>
</li>
<li><p>在大部分情况下，程序中的转换运算 (transformations) 跟 dataflow 中的算子 (operator) 是一一对应的关系，但有时候，一个 transformation 可能对应多个 operator。</p>
</li>
</ul>
<h4 id="执行图-ExecutionGrap"><a href="#执行图-ExecutionGrap" class="headerlink" title="执行图 (ExecutionGrap)"></a>执行图 (ExecutionGrap)</h4><ul>
<li><p>由 Flink 程序直接映射成的数据流图是 StreamGraph，也被称为逻辑流图，因为它们表示的是计算逻辑的高级视图。为了执行一个流处理程序，Flink 需要将逻辑流图转换为物理数据流图 (也叫执行图)，详细说明程序的执行方式。</p>
</li>
<li><p>Flink 中的执行图可以分成四层：StreamGraph —&gt; JobGraph —&gt; ExecutionGraph —&gt; 物理执行图。</p>
<p><img src="/2021/04/25/flink/image-20210729231840293.png" alt="image-20210729231840293"></p>
<ul>
<li>StreamGraph：是根据用户通过 Stream API 编写的代码生成的最初的图。用来表示程序的拓扑结构。</li>
<li>JobGraph：StreamGraph 经过优化后生成了 JobGraph，即提交给 JobManager 的数据结构。主要的优化为：将多个符合条件的节点 chain 在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗。</li>
<li>ExecutionGraph：JobManager 根据 JobGraph 生成 ExecutionGraph。ExecutionGraph 是 JobGraph 的并行化版本，是调度层最核心的数据结构。</li>
<li>物理执行图：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个 TaskManager 上部署 Task 后形成的 “图”，并不是一个具体的数据结构。</li>
</ul>
</li>
</ul>
<h4 id="数据传输形式"><a href="#数据传输形式" class="headerlink" title="数据传输形式"></a>数据传输形式</h4><ul>
<li>一个 Flink 程序中，不同的算子可能具有不同的并行度。</li>
<li>Stream 在算子之间传输数据的形式可以是 one-to-one (forwarding) 的模式，也可以是 redistributing 的模式，具体是哪一种形式，取决于算子的种类</li>
<li>One-to-one：Stream维护着分区以及元素的顺序，比如在 source 和 map 这两个 operator 之间，这意味着 map 算子的子任务看到的元素的个数以及顺序，跟 source 算子的子任务生产的元素的个数、顺序相同。map、fliter、flatMap 等算子都是 one-to-one 的对应关系。<ul>
<li>类似于 Spark 中的窄依赖。</li>
</ul>
</li>
<li>Redistributing：Stream 的分区会发生改变，比如 map 跟 keyBy/window 之间，或者 keyBy/window 跟 sink 之间。每一个算子的子任务依据所选择的 transformation 发送数据到不同的目标任务。例如，keyBy 基于 hashCode 重分区、broadcast 和 rebalance会随机重新分区 (rebalance 实际上是一种轮询的随机重新分区操作)，这些算子都会引起 redistribute 过程，而 redistribute 过程就类似于 Spark 中的 shuffle 过程 (Flink 中的 shuffle 算子，是完全随机的重新分区操作)。<ul>
<li>类似于 Spark 中的宽依赖。</li>
</ul>
</li>
</ul>
<h4 id="任务链-Operator-Chain"><a href="#任务链-Operator-Chain" class="headerlink" title="任务链 (Operator Chain)"></a>任务链 (Operator Chain)</h4><p><img src="/2021/04/25/flink/image-20210730163822923.png" alt="image-20210730163822923"></p>
<ul>
<li>Flink 采用了一种称为任务链的优化技术，它能减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量，可以在特定条件下减少本地通信的开销。为了满足任务链的要求，必须将两个或多个算子设为相同的并行度，并通过本地转发 (local forward) 的方式进行连接。</li>
<li>相同并行度的 one-to-one 操作，Flink 将这样相连的算子链接在一起形成一个 task，原来的算子成为里面的 subtask。</li>
<li>算子合并的条件：并行度相同，并且是 one-to-one 操作，两个条件缺一不可。</li>
<li>如上图所示，最终有 5 个任务，如果未自定义共享组，只需要 2 个 slot 即可。</li>
<li>如果不希望 Key Agg 和 Sink 这两个算子合并为一个任务，但也还是能 slot 共享，则有以下几种方式处理：<ul>
<li>在 Key Agg 算子后做一个 rebalance (<code>.rebalance()</code>) 或 shuffle (<code>.shuffle()</code>) 操作，改变其传输方式；</li>
<li>使用 <code>.disableChaining()</code>，指定 Key Agg 算子不参与任务链合并操作 (该算子前后都会不参与)；</li>
<li>使用 <code>.startNewChain()</code>，指定 Key Agg 算子后面开始一个新的任务链合并操作，即 Key Agg 算子还可以与它前面的算子合并，但不与后面的算子合并；</li>
<li>如果希望每一个算子都这样处理，可以通过 <code>env.disableOperatorChaining();</code>，对全局进行设置。</li>
</ul>
</li>
</ul>
<h2 id="Flink-的流处理-API"><a href="#Flink-的流处理-API" class="headerlink" title="Flink 的流处理 API"></a>Flink 的流处理 API</h2><img src="/2021/04/25/flink/image-20210428091400383.png" alt="image-20210428091400383" style="zoom:80%;">

<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><h4 id="getExecutionEnvironment"><a href="#getExecutionEnvironment" class="headerlink" title="getExecutionEnvironment()"></a><code>getExecutionEnvironment()</code></h4><ul>
<li><p>创建一个执行环境，表示当前执行程序的上下文。 如果程序是独立调用的，则此方法返回本地执行环境；如果从命令行客户端调用程序以提交到集群，则此方法返回此集群的执行环境，也就是说，getExecutionEnvironment 会根据查询运行的方式决定返回什么样的运行环境，是最常用的一种创建执行环境的方式。</p>
</li>
<li><p>批处理执行环境：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure>
</li>
<li><p>流处理执行环境：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在生产环境时，如果没有设置并行度，会以 flink-conf.yaml 中的配置为准，默认是 1：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The parallelism used for programs that did not specify and other parallelism.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">parallelism.default:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在本地 IDEA 执行环境时，默认并行度是本地计算机的 CPU 逻辑核数，本地计算机为 4 核 8 处理器，即默认并行度为 8，本文测试代码以此为基准。</p>
</blockquote>
</li>
</ul>
<h4 id="createLocalEnvironment"><a href="#createLocalEnvironment" class="headerlink" title="createLocalEnvironment()"></a><code>createLocalEnvironment()</code></h4><ul>
<li><p>返回本地执行环境，需要在调用时指定默认的并行度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalStreamEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="createRemoteEnvironment"><a href="#createRemoteEnvironment" class="headerlink" title="createRemoteEnvironment()"></a><code>createRemoteEnvironment()</code></h4><ul>
<li><p>返回集群执行环境，将 Jar 提交到远程服务器。需要在调用时指定 JobManager 的 IP 和端口号，并指定要在集群中运行的 Jar 包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env =</span><br><span class="line">        StreamExecutionEnvironment.createRemoteEnvironment(<span class="string">&quot;jobmanage-hostname&quot;</span>, <span class="number">6123</span>, <span class="string">&quot;YOURPATH//WordCount.jar&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h4 id="从集合读取数据"><a href="#从集合读取数据" class="headerlink" title="从集合读取数据"></a>从集合读取数据</h4><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传感器温度读数的数据类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/28 20:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性：id，时间戳，温度值</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Long timestamp;</span><br><span class="line">    <span class="keyword">private</span> Double temperature;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SensorReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SensorReading</span><span class="params">(String id, Long timestamp, Double temperature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimestamp</span><span class="params">(Long timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemperature</span><span class="params">(Double temperature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SensorReading&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, timestamp=&quot;</span> + timestamp +</span><br><span class="line">                <span class="string">&quot;, temperature=&quot;</span> + temperature +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/28 20:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceTest1_Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.Source: 从集合读取数据</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; sensorDataStream = env.fromCollection(</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> SensorReading(<span class="string">&quot;sensor_1&quot;</span>, <span class="number">1547718199L</span>, <span class="number">35.8</span>),</span><br><span class="line">                        <span class="keyword">new</span> SensorReading(<span class="string">&quot;sensor_6&quot;</span>, <span class="number">1547718201L</span>, <span class="number">15.4</span>),</span><br><span class="line">                        <span class="keyword">new</span> SensorReading(<span class="string">&quot;sensor_7&quot;</span>, <span class="number">1547718202L</span>, <span class="number">6.7</span>),</span><br><span class="line">                        <span class="keyword">new</span> SensorReading(<span class="string">&quot;sensor_10&quot;</span>, <span class="number">1547718205L</span>, <span class="number">38.1</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        DataStream&lt;Integer&gt; intDataStream = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 打印，参数为数据流的名称，可选</span></span><br><span class="line">        sensorDataStream.print(<span class="string">&quot;sensorDataName&quot;</span>);</span><br><span class="line">        intDataStream.print(<span class="string">&quot;intDataStreamName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 执行任务，参数为Job的名称，可选</span></span><br><span class="line">        env.execute(<span class="string">&quot;JobName&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">intDataStreamName:<span class="number">1</span>&gt; <span class="number">8</span></span><br><span class="line">intDataStreamName:<span class="number">5</span>&gt; <span class="number">4</span></span><br><span class="line">intDataStreamName:<span class="number">4</span>&gt; <span class="number">3</span></span><br><span class="line">sensorDataName:<span class="number">5</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">sensorDataName:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">intDataStreamName:<span class="number">3</span>&gt; <span class="number">2</span></span><br><span class="line">sensorDataName:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">intDataStreamName:<span class="number">2</span>&gt; <span class="number">1</span></span><br><span class="line">intDataStreamName:<span class="number">2</span>&gt; <span class="number">9</span></span><br><span class="line">intDataStreamName:<span class="number">7</span>&gt; <span class="number">6</span></span><br><span class="line">intDataStreamName:<span class="number">6</span>&gt; <span class="number">5</span></span><br><span class="line">sensorDataName:<span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">intDataStreamName:<span class="number">8</span>&gt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h4><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/28 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceTest2_File</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据：单线程读取文件，按顺序逐行读取，如果不设置，则多线程读取，文件内容会乱序</span></span><br><span class="line">        DataStream&lt;String&gt; dataStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.打印，多线程</span></span><br><span class="line">        dataStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sensor.txt 文件内容：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718207,36.3</span><br><span class="line">sensor_1,1547718209,32.8</span><br><span class="line">sensor_1,1547718212,37.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果 (多线程打印，每次输出结果都会不同)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line"><span class="number">4</span>&gt; sensor_1,<span class="number">1547718207</span>,<span class="number">36.3</span></span><br><span class="line"><span class="number">1</span>&gt; sensor_6,<span class="number">1547718201</span>,<span class="number">15.4</span></span><br><span class="line"><span class="number">3</span>&gt; sensor_10,<span class="number">1547718205</span>,<span class="number">38.1</span></span><br><span class="line"><span class="number">6</span>&gt; sensor_1,<span class="number">1547718212</span>,<span class="number">37.1</span></span><br><span class="line"><span class="number">2</span>&gt; sensor_7,<span class="number">1547718202</span>,<span class="number">6.7</span></span><br><span class="line"><span class="number">5</span>&gt; sensor_1,<span class="number">1547718209</span>,<span class="number">32.8</span></span><br><span class="line"><span class="number">8</span>&gt; sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 <code>dataStream.print().setParallelism(1);</code>，单线程打印的输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">sensor_6,<span class="number">1547718201</span>,<span class="number">15.4</span></span><br><span class="line">sensor_7,<span class="number">1547718202</span>,<span class="number">6.7</span></span><br><span class="line">sensor_10,<span class="number">1547718205</span>,<span class="number">38.1</span></span><br><span class="line">sensor_1,<span class="number">1547718207</span>,<span class="number">36.3</span></span><br><span class="line">sensor_1,<span class="number">1547718209</span>,<span class="number">32.8</span></span><br><span class="line">sensor_1,<span class="number">1547718212</span>,<span class="number">37.1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="从-Kafka-消息队列读取数据"><a href="#从-Kafka-消息队列读取数据" class="headerlink" title="从 Kafka 消息队列读取数据"></a>从 Kafka 消息队列读取数据</h4><ul>
<li><p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/28 22:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceTest3_Kafka</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建Kafka消费者</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        FlinkKafkaConsumer&lt;String&gt; consumer = <span class="keyword">new</span> FlinkKafkaConsumer&lt;&gt;(<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> SimpleStringSchema(), properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从Kafka读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; dataStream = env.addSource(consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.打印</span></span><br><span class="line">        dataStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="自定义-Source"><a href="#自定义-Source" class="headerlink" title="自定义 Source"></a>自定义 Source</h4><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/28 22:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceTest4_UDF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">//        env.setParallelism(1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从自定义Source读取数据</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = env.addSource(<span class="keyword">new</span> MySensorSource());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.打印</span></span><br><span class="line">        dataStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义的SourceFunction，随机生成传感器数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySensorSource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">SensorReading</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个标识位，用来控制数据的产生</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;SensorReading&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 定义一个随机数发生器</span></span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置10个传感器的初始温度</span></span><br><span class="line">            HashMap&lt;String, Double&gt; sensorTempMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sensorTempMap.put(<span class="string">&quot;sensor_&quot;</span> + (i + <span class="number">1</span>), <span class="number">60</span> + random.nextGaussian() * <span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String sensorId : sensorTempMap.keySet()) &#123;</span><br><span class="line">                    <span class="comment">// 在当前温度基础上随机波动</span></span><br><span class="line">                    Double newtemp = sensorTempMap.get(sensorId) + random.nextGaussian();</span><br><span class="line">                    sensorTempMap.put(sensorId, newtemp);</span><br><span class="line">                    ctx.collect(<span class="keyword">new</span> SensorReading(sensorId, System.currentTimeMillis(), newtemp));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 控制输出频率</span></span><br><span class="line">                Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果 (程序会一直输出下去)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line"><span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1619670947828</span>, temperature=<span class="number">57.523519020755195</span>&#125;</span><br><span class="line"><span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1619670947828</span>, temperature=<span class="number">60.16683595604395</span>&#125;</span><br><span class="line"><span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_9&#x27;</span>, timestamp=<span class="number">1619670947831</span>, temperature=<span class="number">42.125026316308286</span>&#125;</span><br><span class="line"><span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1619670947826</span>, temperature=<span class="number">82.58226594512607</span>&#125;</span><br><span class="line"><span class="number">5</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_4&#x27;</span>, timestamp=<span class="number">1619670947828</span>, temperature=<span class="number">78.73909616880852</span>&#125;</span><br><span class="line"><span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_5&#x27;</span>, timestamp=<span class="number">1619670947831</span>, temperature=<span class="number">26.71490359887942</span>&#125;</span><br><span class="line"><span class="number">5</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1619670947831</span>, temperature=<span class="number">85.09026456845346</span>&#125;</span><br><span class="line"><span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_2&#x27;</span>, timestamp=<span class="number">1619670947828</span>, temperature=<span class="number">64.90731492147165</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_3&#x27;</span>, timestamp=<span class="number">1619670947822</span>, temperature=<span class="number">31.96909359527708</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_8&#x27;</span>, timestamp=<span class="number">1619670947831</span>, temperature=<span class="number">86.34172370619932</span>&#125;</span><br><span class="line"><span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1619670948831</span>, temperature=<span class="number">60.71931724451548</span>&#125;</span><br><span class="line"><span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1619670948831</span>, temperature=<span class="number">57.36109139383153</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_4&#x27;</span>, timestamp=<span class="number">1619670948831</span>, temperature=<span class="number">78.1152626762054</span>&#125;</span><br><span class="line"><span class="number">5</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_2&#x27;</span>, timestamp=<span class="number">1619670948831</span>, temperature=<span class="number">63.90599072985537</span>&#125;</span><br><span class="line"><span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1619670948831</span>, temperature=<span class="number">82.1517010383502</span>&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><h4 id="基本转换算子"><a href="#基本转换算子" class="headerlink" title="基本转换算子"></a>基本转换算子</h4><ul>
<li><p>map、flatMap、filter 通常被统一称为<strong>基本转换算子 (简单转换算子)。</strong></p>
</li>
<li><p><strong>map：</strong></p>
<img src="/2021/04/25/flink/image-20210429130112584.png" alt="image-20210429130112584" style="zoom:80%;">
</li>
<li><p><strong>flatMap：</strong></p>
<img src="/2021/04/25/flink/image-20210429131505870.png" alt="image-20210429131505870" style="zoom:80%;">
</li>
<li><p><strong>filter：</strong></p>
<img src="/2021/04/25/flink/image-20210429130649590.png" alt="image-20210429130649590" style="zoom:80%;">
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/28 10:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTest1_Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.map，把String转换成其长度输出</span></span><br><span class="line">        DataStream&lt;Integer&gt; mapStream = inputStream.map(<span class="keyword">new</span> MapFunction&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.flatmap，按逗号分割字符串</span></span><br><span class="line">        DataStream&lt;String&gt; flatMapStream = inputStream.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] fields = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">                    out.collect(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.filter，筛选&quot;sensor_1&quot;开头的id对应的数据</span></span><br><span class="line">        DataStream&lt;String&gt; filterStream = inputStream.filter(<span class="keyword">new</span> FilterFunction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value.startsWith(<span class="string">&quot;sensor_1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.打印</span></span><br><span class="line">        mapStream.print(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        flatMapStream.print(<span class="string">&quot;flatMap&quot;</span>);</span><br><span class="line">        filterStream.print(<span class="string">&quot;filter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">map:<span class="number">5</span>&gt; <span class="number">24</span></span><br><span class="line">map:<span class="number">5</span>&gt; <span class="number">24</span></span><br><span class="line">flatMap:<span class="number">4</span>&gt; sensor_1</span><br><span class="line">flatMap:<span class="number">4</span>&gt; <span class="number">1547718199</span></span><br><span class="line">flatMap:<span class="number">4</span>&gt; <span class="number">35.8</span></span><br><span class="line">flatMap:<span class="number">4</span>&gt; sensor_1</span><br><span class="line">flatMap:<span class="number">4</span>&gt; <span class="number">1547718212</span></span><br><span class="line">flatMap:<span class="number">4</span>&gt; <span class="number">37.1</span></span><br><span class="line">flatMap:<span class="number">6</span>&gt; sensor_7</span><br><span class="line">flatMap:<span class="number">6</span>&gt; <span class="number">1547718202</span></span><br><span class="line">flatMap:<span class="number">6</span>&gt; <span class="number">6.7</span></span><br><span class="line">map:<span class="number">6</span>&gt; <span class="number">24</span></span><br><span class="line">filter:<span class="number">3</span>&gt; sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">filter:<span class="number">3</span>&gt; sensor_1,<span class="number">1547718212</span>,<span class="number">37.1</span></span><br><span class="line">filter:<span class="number">6</span>&gt; sensor_10,<span class="number">1547718205</span>,<span class="number">38.1</span></span><br><span class="line">map:<span class="number">4</span>&gt; <span class="number">24</span></span><br><span class="line">map:<span class="number">1</span>&gt; <span class="number">23</span></span><br><span class="line">map:<span class="number">3</span>&gt; <span class="number">24</span></span><br><span class="line">map:<span class="number">2</span>&gt; <span class="number">25</span></span><br><span class="line">filter:<span class="number">1</span>&gt; sensor_1,<span class="number">1547718207</span>,<span class="number">36.3</span></span><br><span class="line">filter:<span class="number">2</span>&gt; sensor_1,<span class="number">1547718209</span>,<span class="number">32.8</span></span><br><span class="line">flatMap:<span class="number">5</span>&gt; sensor_6</span><br><span class="line">flatMap:<span class="number">5</span>&gt; <span class="number">1547718201</span></span><br><span class="line">flatMap:<span class="number">5</span>&gt; <span class="number">15.4</span></span><br><span class="line">flatMap:<span class="number">3</span>&gt; sensor_1</span><br><span class="line">flatMap:<span class="number">3</span>&gt; <span class="number">1547718209</span></span><br><span class="line">flatMap:<span class="number">3</span>&gt; <span class="number">32.8</span></span><br><span class="line">flatMap:<span class="number">2</span>&gt; sensor_1</span><br><span class="line">flatMap:<span class="number">2</span>&gt; <span class="number">1547718207</span></span><br><span class="line">flatMap:<span class="number">2</span>&gt; <span class="number">36.3</span></span><br><span class="line">flatMap:<span class="number">1</span>&gt; sensor_10</span><br><span class="line">flatMap:<span class="number">1</span>&gt; <span class="number">1547718205</span></span><br><span class="line">flatMap:<span class="number">1</span>&gt; <span class="number">38.1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="聚合操作算子"><a href="#聚合操作算子" class="headerlink" title="聚合操作算子"></a>聚合操作算子</h4><ul>
<li><p>DataStream 里没有 reduce 和 sum 这类聚合操作的方法，因为 <strong>Flink 设计中，所有数据必须先分组才能做聚合操作。</strong></p>
</li>
<li><p><strong>先 keyBy 得到 KeyedStream，然后调用其 reduce、sum 等聚合操作方法。(先分组后聚合)</strong></p>
</li>
<li><p>常见的聚合操作算子主要有：</p>
<ul>
<li>keyBy</li>
<li>滚动聚合算子 Rolling Aggregation</li>
<li>reduce</li>
</ul>
</li>
<li><p><strong>keyBy：</strong></p>
<img src="/2021/04/25/flink/image-20210429131832931.png" alt="image-20210429131832931" style="zoom:80%;">

<ul>
<li><p>DataStream —&gt; KeyedStream：逻辑地将一个流拆分成不相交的分组，每个分组包含具有相同 key 的元素，在内部以 hash 的形式实现的。</p>
</li>
<li><p><strong>keyBy 会重新分组。相同的 key 一定在同一个分组，而不同的 key 可能会在一个分组，因为是通过 hash 原理实现的，可能存在取模操作。</strong></p>
</li>
<li><p>keyBy 不是计算操作。</p>
</li>
<li><p>keyBy 可以按照元组的位置，或者对象的属性名分组，在 Flink 新版本中，有一些方法被弃用，可以用其他的方法替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;K&gt; <span class="function">KeyedStream&lt;T, K&gt; <span class="title">keyBy</span><span class="params">(KeySelector&lt;T, K&gt; key)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyedStream(<span class="keyword">this</span>, (KeySelector)<span class="keyword">this</span>.clean(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;K&gt; <span class="function">KeyedStream&lt;T, K&gt; <span class="title">keyBy</span><span class="params">(KeySelector&lt;T, K&gt; key, TypeInformation&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(key);</span><br><span class="line">    Preconditions.checkNotNull(keyType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyedStream(<span class="keyword">this</span>, (KeySelector)<span class="keyword">this</span>.clean(key), keyType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KeyedStream&lt;T, Tuple&gt; <span class="title">keyBy</span><span class="params">(<span class="keyword">int</span>... fields)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">this</span>.getType() <span class="keyword">instanceof</span> BasicArrayTypeInfo) &amp;&amp; !(<span class="keyword">this</span>.getType() <span class="keyword">instanceof</span> PrimitiveArrayTypeInfo) ? <span class="keyword">this</span>.keyBy((Keys)(<span class="keyword">new</span> ExpressionKeys(fields, <span class="keyword">this</span>.getType()))) : <span class="keyword">this</span>.keyBy((KeySelector)KeySelectorUtil.getSelectorForArray(fields, <span class="keyword">this</span>.getType()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KeyedStream&lt;T, Tuple&gt; <span class="title">keyBy</span><span class="params">(String... fields)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.keyBy((Keys)(<span class="keyword">new</span> ExpressionKeys(fields, <span class="keyword">this</span>.getType())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>滚动聚合算子 (Rolling Aggregation)：</strong></p>
<ul>
<li><p>这些算子可以针对 KeyedStream 的每一个支流做聚合，包括：</p>
<ul>
<li><strong><code>sum()</code></strong></li>
<li><strong><code>min()</code></strong></li>
<li><strong><code>max()</code></strong></li>
<li><strong><code>minBy()</code></strong></li>
<li><strong><code>maxBy()</code></strong></li>
</ul>
</li>
<li><p><strong><code>min()</code>、<code>max()</code> 和 <code>minBy()</code>、<code>maxBy()</code> 的区别在于：前者每次输出时，只有作为参数比较的字段会更新，其他字段不变；而后者除了作为参数比较的字段会更新，其他的字段会一起更新。</strong></p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/30 9:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTest2_RollingAggregation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.按照SensorReading对象的id分组</span></span><br><span class="line">        <span class="comment">// 方式一：直接以属性名作为参数，此方法已弃用</span></span><br><span class="line">        <span class="comment">/*KeyedStream&lt;SensorReading, Tuple&gt; keyedStream = dataStream.keyBy(&quot;id&quot;);*/</span></span><br><span class="line">        <span class="comment">// 方式二：以KeySelector作为参数</span></span><br><span class="line">        <span class="comment">/*KeyedStream&lt;SensorReading, String&gt; keyedStream = dataStream.keyBy(new KeySelector&lt;SensorReading, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String getKey(SensorReading sensorReading) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                return sensorReading.getId();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">        <span class="comment">// 方式三：方式二的Lambda表达式版</span></span><br><span class="line">        KeyedStream&lt;SensorReading, String&gt; keyedStream = dataStream.keyBy(SensorReading::getId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.滚动聚合，取当前最大的温度值，可以输入对象的属性名，或者元组里面的位置</span></span><br><span class="line">        <span class="comment">// DataStream&lt;SensorReading&gt; resultStream = keyedStream.max(&quot;temperature&quot;);</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; resultStream = keyedStream.maxBy(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.打印</span></span><br><span class="line">        resultStream.print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>max()</code> 输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">result:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">result:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">32.8</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为是滚动更新，对于每一个分组，每次来一条数据时，都会输出一次历史最大值，所以有的数据才会出现多次。</p>
<p>sensor_7 和 sensor_10 各属于一个分组 (线程2 和线程 4)，但各只有一条数据。sensor_6 和 sensor_1 在同一个分组 (线程 3)，sensor_6 只有一条数据，对于 sensor_1，有四条数据，temperature 最大值为 37.1，输出了四次，但每次只更新了 temperature 的值，其他字段的值没有更新。</p>
</blockquote>
</li>
<li><p><code>maxBy()</code> 输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">result:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">result:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">result:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于 sensor_1 的四条数据，每次输出时，除了更新 temperature 的值，其他字段的值也一起更新，但保留时间戳仍是当前 temperature 最大值对应的时间戳，而这个时间戳可能不是实时的值，比如第 9 行，其时间戳应该是 1547718209 (32.8 度的时间戳)，而不是 1547718207。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>reduce：</strong></p>
<ul>
<li><p><strong>reduce，归约，适用于更加一般化的聚合操作场景</strong>。比如：在读取文件内容时，可以使用 reduce 算子将前后两行加起来，最终组成完整的文件内容。</p>
</li>
<li><p><strong>KeyedStream —&gt; DataStream：一个分组数据流的聚合操作，合并当前的元素和上次聚合的结果，产生一个新的值，返回的流中包含每一次聚合的结果，而不是只返回最后一次聚合的最终结果。(返回值类型与传入类型一致，不能改变)</strong></p>
</li>
<li><p>在前面 Rolling Aggregation 的前提下，对需求进行修改。获取同组历史温度最高的传感器信息，并要求实时更新其时间戳信息。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/30 16:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTest3_Reduce</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置并行度为1，能更好的体验效果，sensor.txt从上到下时间戳是递增的</span></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.按照SensorReading对象的id分组</span></span><br><span class="line">        KeyedStream&lt;SensorReading, String&gt; keyedStream = dataStream.keyBy(SensorReading::getId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.reduce聚合，取每个分组最大的温度值，并更新为当前最新的时间戳</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; resultStream = keyedStream.reduce(<span class="keyword">new</span> ReduceFunction&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="comment">// curSensor：上次聚合的结果，newSensor：当前的元素</span></span><br><span class="line">            <span class="comment">// 对同一个分组，id值一直是相同的</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> SensorReading <span class="title">reduce</span><span class="params">(SensorReading curSensor, SensorReading newSensor)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(curSensor.getId(), newSensor.getTimestamp(),</span><br><span class="line">                        Math.max(curSensor.getTemperature(), newSensor.getTemperature()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.打印</span></span><br><span class="line">        resultStream.print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">result&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">result&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">result&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">result&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">result&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">result&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">result&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于 sensor_1 的四条数据，从第 8 行开始，每次输出时，temperature 都是当前历史温度的最高值，而时间戳也在实时更新。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="多流转换算子"><a href="#多流转换算子" class="headerlink" title="多流转换算子"></a>多流转换算子</h4><ul>
<li><p>多流转换算子一般包括：</p>
<ul>
<li>split 和 select (Filink 1.12.1 版本被移除)</li>
<li>connect 和 coMap</li>
<li>union</li>
</ul>
</li>
<li><p>split 和 select：</p>
<ul>
<li><p>split：</p>
<img src="/2021/04/25/flink/image-20210504093752377.png" alt="image-20210504093752377" style="zoom:80%;">

<ul>
<li><strong>DataStream —&gt; SplitStream</strong>：根据某些特征把一个 DataStream 拆分成两个或者多个 DataStream。</li>
</ul>
</li>
<li><p>select：</p>
<img src="/2021/04/25/flink/image-20210504093831460.png" alt="image-20210504093831460" style="zoom:80%;">

<ul>
<li>SplitStream —&gt; DataStream：从一个 SplitStream 中获取一个或者多个 DataStream。</li>
</ul>
</li>
<li><p>split 和 select 需要结合使用。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/2 11:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTest4_MultipleStreams</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.分流</span></span><br><span class="line">        SplitStream&lt;SensorReading&gt; splitStream = dataStream.split(<span class="keyword">new</span> OutputSelector&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 可以获得多个分流，此处按温度是否超过30℃设置了两个分流</span></span><br><span class="line">                <span class="keyword">return</span> (sensorReading.getTemperature() &gt; <span class="number">30</span>) ? Collections.singletonList(<span class="string">&quot;high&quot;</span>) :</span><br><span class="line">                        Collections.singletonList(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取分流</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; highTempStream = splitStream.select(<span class="string">&quot;high&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; lowTempStream = splitStream.select(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; allTempStream = splitStream.select(<span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.打印</span></span><br><span class="line">        highTempStream.print(<span class="string">&quot;high&quot;</span>);</span><br><span class="line">        lowTempStream.print(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">        allTempStream.print(<span class="string">&quot;all&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码，可使用 Flink 1.11.1 版本测试。</p>
</blockquote>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">all:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">all:<span class="number">5</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">32.8</span>&#125;</span><br><span class="line">high:<span class="number">5</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">32.8</span>&#125;</span><br><span class="line">all:<span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">high:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">all:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">all:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">high:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">all:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">low:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">high:<span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">all:<span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line">high:<span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line">low:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>connect 和 coMap/coFlatMap：</strong></p>
<ul>
<li><p>connect：</p>
<img src="/2021/04/25/flink/image-20210504093142847.png" alt="image-20210504093142847" style="zoom:80%;">

<ul>
<li><strong>DataStream，DataStream —&gt; ConnectedStreams</strong>：连接两个保持他们类型的数据流，两个数据流被 Connect 之后，只是被放在了同一个流中，其内部依然保持各自的数据和形式不发生任何变化，两个流相互独立。</li>
</ul>
</li>
<li><p>coMap/coFlatMap：</p>
<img src="/2021/04/25/flink/image-20210504094045828.png" alt="image-20210504094045828" style="zoom:80%;">

<ul>
<li><strong>ConnectedStreams —&gt; DataStream</strong>：作用于 ConnectedStreams 上，功能与 map 和 flatMap 一样，对 ConnectedStreams 中的每一个 Stream 分别进行 map 和 flatMap 处理。</li>
</ul>
</li>
<li><p>connect 和 coMap/coFlatMap 需要结合使用。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/2 11:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTest4_MultipleStreams2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.分流</span></span><br><span class="line">        SplitStream&lt;SensorReading&gt; splitStream = dataStream.split(<span class="keyword">new</span> OutputSelector&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 可以获得多个分流，此处按温度是否超过30℃设置了两个分流</span></span><br><span class="line">                <span class="keyword">return</span> (sensorReading.getTemperature() &gt; <span class="number">30</span>) ? Collections.singletonList(<span class="string">&quot;high&quot;</span>) :</span><br><span class="line">                        Collections.singletonList(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取分流</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; highTempStream = splitStream.select(<span class="string">&quot;high&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; lowTempStream = splitStream.select(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; allTempStream = splitStream.select(<span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.合流connect，将高温流转换成二元组类型，再与低温流连接合并之后，输出状态信息</span></span><br><span class="line">        <span class="comment">// org.apache.flink.api.java.tuple.Tuple2</span></span><br><span class="line">        <span class="comment">// org.apache.flink.api.java.tuple.Tuple3</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Double&gt;&gt; warningStream = highTempStream.map(<span class="keyword">new</span> MapFunction&lt;SensorReading, Tuple2&lt;String, Double&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Double&gt; <span class="title">map</span><span class="params">(SensorReading sensorReading)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(sensorReading.getId(), sensorReading.getTemperature());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ConnectedStreams&lt;Tuple2&lt;String, Double&gt;, SensorReading&gt; connectedStreams = warningStream.connect(lowTempStream);</span><br><span class="line">        SingleOutputStreamOperator&lt;Object&gt; resultStream = connectedStreams.map(<span class="keyword">new</span> CoMapFunction&lt;Tuple2&lt;String, Double&gt;, SensorReading, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">map1</span><span class="params">(Tuple2&lt;String, Double&gt; stringDoubleTuple2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(stringDoubleTuple2.f0, stringDoubleTuple2.f1, <span class="string">&quot;high temperature warning&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">map2</span><span class="params">(SensorReading sensorReading)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple3&lt;&gt;(sensorReading.getId(), sensorReading.getTemperature(), <span class="string">&quot;normal temperature&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line"><span class="number">3</span>&gt; (sensor_1,<span class="number">35.8</span>,high temperature warning)</span><br><span class="line"><span class="number">2</span>&gt; (sensor_1,<span class="number">32.8</span>,high temperature warning)</span><br><span class="line"><span class="number">1</span>&gt; (sensor_1,<span class="number">36.3</span>,high temperature warning)</span><br><span class="line"><span class="number">4</span>&gt; (sensor_6,<span class="number">15.4</span>,normal temperature)</span><br><span class="line"><span class="number">3</span>&gt; (sensor_1,<span class="number">37.1</span>,high temperature warning)</span><br><span class="line"><span class="number">5</span>&gt; (sensor_7,<span class="number">6.7</span>,normal temperature)</span><br><span class="line"><span class="number">6</span>&gt; (sensor_10,<span class="number">38.1</span>,high temperature warning)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>union：</strong></p>
<img src="/2021/04/25/flink/image-20210504114937037.png" alt="image-20210504114937037" style="zoom:80%;">

<ul>
<li><p><strong>DataStream —&gt; DataStream</strong>：对两个或者两个以上的 DataStream 进行 union 操作，产生一个包含所有 DataStream 元素的新 DataStream。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/2 11:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTest4_MultipleStreams3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.分流</span></span><br><span class="line">        SplitStream&lt;SensorReading&gt; splitStream = dataStream.split(<span class="keyword">new</span> OutputSelector&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 可以获得多个分流，此处按温度是否超过30℃设置了两个分流</span></span><br><span class="line">                <span class="keyword">return</span> (sensorReading.getTemperature() &gt; <span class="number">30</span>) ? Collections.singletonList(<span class="string">&quot;high&quot;</span>) :</span><br><span class="line">                        Collections.singletonList(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取分流</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; highTempStream = splitStream.select(<span class="string">&quot;high&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; lowTempStream = splitStream.select(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; allTempStream = splitStream.select(<span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.联合两个分流</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; unionStream = highTempStream.union(lowTempStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.打印</span></span><br><span class="line">        unionStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line"><span class="number">6</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line"><span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line"><span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">32.8</span>&#125;</span><br><span class="line"><span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line"><span class="number">5</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line"><span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>connect 与 union 区别：</p>
<ul>
<li>执行 union 操作的流的类型必须是一样，connect 可以不一样，可以在之后的 coMap 中再调整为一样的类型。</li>
<li>connect 只能合并两个流，union 可以合并多个流。</li>
</ul>
</li>
</ul>
<h4 id="算子转换"><a href="#算子转换" class="headerlink" title="算子转换"></a>算子转换</h4><img src="/2021/04/25/flink/image-20210504165018734.png" alt="image-20210504165018734" style="zoom:80%;">

<ul>
<li>在 Flink 中，<strong>Transformation 算子就是将一个或多个 DataStream 转换为新的 DataStream</strong>，可以将多个转换组合成复杂的数据流拓扑。 如上图所示，DataStream 会由不同的 Transformation 操作，转换、过滤、聚合成其他不同的流，从而完成我们的业务要求。</li>
</ul>
<h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><ul>
<li>Flink 流应用程序处理的是以数据对象表示的事件流。所以在 Flink 内部，我们需要能够处理这些对象。它们<strong>需要被序列化和反序列化</strong>，以便通过网络传送它们；或者从状态后端、检查点和保存点读取它们。为了有效地做到这一点，Flink 需要明确知道应用程序所处理的数据类型。<strong>Flink 使用类型信息的概念来表示数据类型，并为每个数据类型生成特定的序列化器、反序列化器和比较器。</strong></li>
<li><strong>Flink 还具有一个类型提取系统，该系统分析函数的输入和返回类型，以自动获取类型信息，从而获得序列化器和反序列化器。</strong>但是，在某些情况下，例如 lambda 函数或泛型类型，需要显式地提供类型信息，才能使应用程序正常工作或提高其性能。</li>
<li>Flink 支持 Java 和 Scala 中所有常见数据类型。使用最广泛的类型有以下几种。</li>
</ul>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><ul>
<li><p>Flink 支持所有的 Java 和 Scala 基础数据类型，Int，Double，Long，String，…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Integer&gt; numberStream = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">numberStream.map(data -&gt; data * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Java-和-和-Scala-元组-Tuples"><a href="#Java-和-和-Scala-元组-Tuples" class="headerlink" title="Java 和 和 Scala 元组 (Tuples)"></a>Java 和 和 Scala 元组 (Tuples)</h4><ul>
<li><p>Java 不像 Scala 天生支持元组 Tuple 类型，Java 的元组类型由 Flink 的包提供，默认提供 Tuple0 ~ Tuple25。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; personStream = env.fromElements(</span><br><span class="line">        <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">&quot;Adam&quot;</span>, <span class="number">17</span>), <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">&quot;Sarah&quot;</span>, <span class="number">23</span>));</span><br><span class="line">personStream.filter(p -&gt; p.f1 &gt; <span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>包位置：<code>import org.apache.flink.api.java.tuple.Tuple2;</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARITY = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] CLASSES = <span class="keyword">new</span> Class[]&#123;Tuple0.class, Tuple1.class, Tuple2.class, Tuple3.class, Tuple4.class, Tuple5.class, Tuple6.class, Tuple7.class, Tuple8.class, Tuple9.class, Tuple10.class, Tuple11.class, Tuple12.class, Tuple13.class, Tuple14.class, Tuple15.class, Tuple16.class, Tuple17.class, Tuple18.class, Tuple19.class, Tuple20.class, Tuple21.class, Tuple22.class, Tuple23.class, Tuple24.class, Tuple25.class&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">getField</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFieldNotNull</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        T field = <span class="keyword">this</span>.getField(pos);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullFieldException(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">setField</span><span class="params">(T var1, <span class="keyword">int</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getArity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Tuple&gt; <span class="function">T <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;? extends Tuple&gt; getTupleClass(<span class="keyword">int</span> arity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arity &gt;= <span class="number">0</span> &amp;&amp; arity &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CLASSES[arity];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The tuple arity must be in [0, 25].&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tuple <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> arity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(arity) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Tuple0.INSTANCE;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple1();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple3();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple4();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple5();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple6();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple7();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple8();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple9();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple10();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple11();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple12();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple13();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple14();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple15();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple16();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple17();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple18();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple19();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple20();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple21();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple22();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple23();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">24</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple24();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple25();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The tuple arity must be in [0, 25].&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Scala-样例类-case-classes"><a href="#Scala-样例类-case-classes" class="headerlink" title="Scala 样例类 (case classes)"></a>Scala 样例类 (case classes)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">persons</span></span>: <span class="type">DataStream</span>[<span class="type">Person</span>] = env.fromElements(<span class="type">Person</span>(<span class="string">&quot;Adam&quot;</span>, <span class="number">17</span>), <span class="type">Person</span>(<span class="string">&quot;Sarah&quot;</span>, <span class="number">23</span>))</span><br><span class="line">persons.filter(p =&gt; p.age &gt; <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Java-简单对象-POJO"><a href="#Java-简单对象-POJO" class="headerlink" title="Java 简单对象 (POJO)"></a>Java 简单对象 (POJO)</h4><ul>
<li><p>要求必须提供无参构造函数。</p>
</li>
<li><p>要求成员变量都是 public，或者 private 的但提供 getter、setter 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataStream</span> <span class="type">Person</span> &gt; persons = env.fromElements(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;Alex&quot;</span>, <span class="number">42</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;Wendy&quot;</span>, <span class="number">23</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="其它-Arrays，Lists，Maps，Enums，等等"><a href="#其它-Arrays，Lists，Maps，Enums，等等" class="headerlink" title="其它 (Arrays，Lists，Maps，Enums，等等)"></a>其它 (Arrays，Lists，Maps，Enums，等等)</h4><ul>
<li>Flink 对 Java 和 Scala 中的一些特殊目的的类型也都是支持的，比如 Java 的 ArrayList，HashMap，Enum 等等。</li>
</ul>
<h3 id="实现-UDF-函数——更细粒度的控制流"><a href="#实现-UDF-函数——更细粒度的控制流" class="headerlink" title="实现 UDF 函数——更细粒度的控制流"></a>实现 UDF 函数——更细粒度的控制流</h3><h4 id="函数类-Function-Classes"><a href="#函数类-Function-Classes" class="headerlink" title="函数类 (Function Classes)"></a>函数类 (Function Classes)</h4><ul>
<li><p>Flink 暴露了所有 udf 函数的接口 (实现方式为接口或者抽象类)。例如 MapFunction，FilterFunction，ProcessFunction 等等。</p>
</li>
<li><p>下面的例子，实现了 FilterFunction 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; flinkTweets = tweets.filter(<span class="keyword">new</span> FlinkFilter());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkFilter</span> <span class="keyword">implements</span> <span class="title">FilterFunction</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.contains(<span class="string">&quot;flink&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以将函数实现成匿名类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; flinkTweets = tweets.filter(<span class="keyword">new</span> FilterFunction&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.contains(<span class="string">&quot;flink&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要 filter 的字符串 “flink” 可以当作参数传进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; tweets = env.readTextFile(<span class="string">&quot;INPUT_FILE &quot;</span>);</span><br><span class="line"></span><br><span class="line">DataStream&lt;String&gt; flinkTweets = tweets.filter(<span class="keyword">new</span> KeyWordFilter(<span class="string">&quot;flink&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyWordFilter</span> <span class="keyword">implements</span> <span class="title">FilterFunction</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String keyWord;</span><br><span class="line"></span><br><span class="line">    KeyWordFilter(String keyWord) &#123;</span><br><span class="line">        <span class="keyword">this</span>.keyWord = keyWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.contains(<span class="keyword">this</span>.keyWord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; tweets = env.readTextFile(<span class="string">&quot;INPUT_FILE&quot;</span>);</span><br><span class="line"></span><br><span class="line">DataStream&lt;String&gt; flinkTweets = tweets.filter(tweet -&gt; tweet.contains(<span class="string">&quot;flink&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="富函数-Rich-Functions"><a href="#富函数-Rich-Functions" class="headerlink" title="富函数 (Rich Functions)"></a>富函数 (Rich Functions)</h4><ul>
<li><p>富函数是 DataStream API 提供的一个函数类的接口，所有 Flink 函数类都有其 Rich 版本。</p>
</li>
<li><p><strong>它与常规函数的不同在于，可以获取运行环境的上下文，并拥有一些生命周期方法，所以可以实现更复杂的功能</strong>。</p>
<ul>
<li>RichMapFunction</li>
<li>RichFlatMapFunction</li>
<li>RichFilterFunction</li>
<li>…</li>
</ul>
</li>
<li><p>Rich Function 有一个<strong>生命周期</strong>的概念。典型的生命周期方法有：</p>
<ul>
<li><code>open()</code> 是 RichFunction 的初始化方法，当一个算子例如 map 或者 filter 被调用之前，<code>open()</code> 会被调用。</li>
<li><code>close()</code> 是生命周期中的最后一个调用的方法，做一些清理工作。</li>
<li><code>getRuntimeContext()</code> 提供了函数的 RuntimeContext 的一些信息，例如函数执行的并行度，任务的名字，以及 state 状态。</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/5 14:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTest5_RichFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;Tuple2&lt;Integer, String&gt;&gt; resultStream = dataStream.map(<span class="keyword">new</span> MyMapper());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传统的Function不能获取上下文信息，只能处理当前数据，不能和其他数据交互</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper0</span> <span class="keyword">implements</span> <span class="title">MapFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">map</span><span class="params">(SensorReading value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(value.getId(), value.getId().length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义富函数类(RichMapFunction是一个abstract类)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapper</span> <span class="keyword">extends</span> <span class="title">RichMapFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Tuple2</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Integer, String&gt; <span class="title">map</span><span class="params">(SensorReading value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// getRuntimeContext().getState();</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(getRuntimeContext().getIndexOfThisSubtask() + <span class="number">1</span>, value.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 初始化工作，一般是定义状态，或者建立数据库连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 一般是关闭连接和清空状态的收尾操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">open</span><br><span class="line">open</span><br><span class="line">open</span><br><span class="line">open</span><br><span class="line"><span class="number">2</span>&gt; (<span class="number">2</span>,sensor_7)</span><br><span class="line"><span class="number">2</span>&gt; (<span class="number">2</span>,sensor_1)</span><br><span class="line"><span class="number">3</span>&gt; (<span class="number">3</span>,sensor_10)</span><br><span class="line"><span class="number">1</span>&gt; (<span class="number">1</span>,sensor_6)</span><br><span class="line"><span class="number">1</span>&gt; (<span class="number">1</span>,sensor_1)</span><br><span class="line">close</span><br><span class="line">close</span><br><span class="line"><span class="number">4</span>&gt; (<span class="number">4</span>,sensor_1)</span><br><span class="line"><span class="number">4</span>&gt; (<span class="number">4</span>,sensor_1)</span><br><span class="line">close</span><br><span class="line">close</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于设置了执行环境 env 的并行度为 4，所以有 4 个 slot 执行自定义的 RichFunction，输出 4 次 open 和 close。</p>
</blockquote>
</li>
</ul>
<h3 id="数据重分区操作"><a href="#数据重分区操作" class="headerlink" title="数据重分区操作"></a>数据重分区操作</h3><ul>
<li><p>在多并行度的情况下，Flink 对数据的分配方式有多种：</p>
<p><img src="/2021/04/25/flink/image-20210506104650689.png" alt="image-20210506104650689"></p>
</li>
<li><p>常用的分配方式有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the partitioning of the &#123;<span class="doctag">@link</span> DataStream&#125; so that the output elements are broadcasted</span></span><br><span class="line"><span class="comment"> * to every parallel instance of the next operation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The DataStream with broadcast partitioning set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataStream&lt;T&gt; <span class="title">broadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setConnectionType(<span class="keyword">new</span> BroadcastPartitioner&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the partitioning of the &#123;<span class="doctag">@link</span> DataStream&#125; so that the output elements are broadcasted</span></span><br><span class="line"><span class="comment"> * to every parallel instance of the next operation. In addition, it implicitly as many &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.api.common.state.BroadcastState broadcast states&#125; as the specified</span></span><br><span class="line"><span class="comment"> * descriptors which can be used to store the element of the stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> broadcastStateDescriptors the descriptors of the broadcast states to create.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> BroadcastStream&#125; which can be used in the &#123;<span class="doctag">@link</span> #connect(BroadcastStream)&#125;</span></span><br><span class="line"><span class="comment"> *     to create a &#123;<span class="doctag">@link</span> BroadcastConnectedStream&#125; for further processing of the elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BroadcastStream&lt;T&gt; <span class="title">broadcast</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> MapStateDescriptor&lt;?, ?&gt;... broadcastStateDescriptors)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(broadcastStateDescriptors);</span><br><span class="line">    <span class="keyword">final</span> DataStream&lt;T&gt; broadcastStream = setConnectionType(<span class="keyword">new</span> BroadcastPartitioner&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BroadcastStream&lt;&gt;(environment, broadcastStream, broadcastStateDescriptors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the partitioning of the &#123;<span class="doctag">@link</span> DataStream&#125; so that the output elements are shuffled</span></span><br><span class="line"><span class="comment"> * uniformly randomly to the next operation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The DataStream with shuffle partitioning set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataStream&lt;T&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setConnectionType(<span class="keyword">new</span> ShufflePartitioner&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the partitioning of the &#123;<span class="doctag">@link</span> DataStream&#125; so that the output elements are forwarded to</span></span><br><span class="line"><span class="comment"> * the local subtask of the next operation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The DataStream with forward partitioning set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataStream&lt;T&gt; <span class="title">forward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setConnectionType(<span class="keyword">new</span> ForwardPartitioner&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the partitioning of the &#123;<span class="doctag">@link</span> DataStream&#125; so that the output elements are distributed</span></span><br><span class="line"><span class="comment"> * evenly to instances of the next operation in a round-robin fashion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The DataStream with rebalance partitioning set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataStream&lt;T&gt; <span class="title">rebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setConnectionType(<span class="keyword">new</span> RebalancePartitioner&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the partitioning of the &#123;<span class="doctag">@link</span> DataStream&#125; so that the output elements are distributed</span></span><br><span class="line"><span class="comment"> * evenly to a subset of instances of the next operation in a round-robin fashion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The subset of downstream operations to which the upstream operation sends elements depends</span></span><br><span class="line"><span class="comment"> * on the degree of parallelism of both the upstream and downstream operation. For example, if</span></span><br><span class="line"><span class="comment"> * the upstream operation has parallelism 2 and the downstream operation has parallelism 4, then</span></span><br><span class="line"><span class="comment"> * one upstream operation would distribute elements to two downstream operations while the other</span></span><br><span class="line"><span class="comment"> * upstream operation would distribute to the other two downstream operations. If, on the other</span></span><br><span class="line"><span class="comment"> * hand, the downstream operation has parallelism 2 while the upstream operation has parallelism</span></span><br><span class="line"><span class="comment"> * 4 then two upstream operations will distribute to one downstream operation while the other</span></span><br><span class="line"><span class="comment"> * two upstream operations will distribute to the other downstream operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In cases where the different parallelisms are not multiples of each other one or several</span></span><br><span class="line"><span class="comment"> * downstream operations will have a differing number of inputs from upstream operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The DataStream with rescale partitioning set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataStream&lt;T&gt; <span class="title">rescale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setConnectionType(<span class="keyword">new</span> RescalePartitioner&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the partitioning of the &#123;<span class="doctag">@link</span> DataStream&#125; so that the output values all go to the first</span></span><br><span class="line"><span class="comment"> * instance of the next processing operator. Use this setting with care since it might cause a</span></span><br><span class="line"><span class="comment"> * serious performance bottleneck in the application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The DataStream with shuffle partitioning set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataStream&lt;T&gt; <span class="title">global</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setConnectionType(<span class="keyword">new</span> GlobalPartitioner&lt;T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认情况下，使用的分配方式是 rebalance 策略，即轮询。</strong></p>
</li>
<li><p><strong>DataStream 类中，<code>partitionCustom(...)</code> 用于自定义重分区</strong>。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/5 17:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTest6_Partition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);<span class="comment">// SingleOutputStreamOperator</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.SingleOutputStreamOperator多并行度时，默认分配方式是rebalance，即轮询方式分配</span></span><br><span class="line">        dataStream.print(<span class="string">&quot;rebalance&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.shuffle (并非批处理中的获取一批后才打乱，这里每次获取到直接打乱且分区)</span></span><br><span class="line">        DataStream&lt;String&gt; shuffleStream = inputStream.shuffle();</span><br><span class="line">        shuffleStream.print(<span class="string">&quot;shuffle&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.keyBy (按Hash，然后取模)</span></span><br><span class="line">        dataStream.keyBy(SensorReading::getId).print(<span class="string">&quot;keyBy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.global (直接发送给第一个分区，少数特殊情况才用)</span></span><br><span class="line">        dataStream.global().print(<span class="string">&quot;global&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">shuffle:<span class="number">2</span>&gt; sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">shuffle:<span class="number">3</span>&gt; sensor_1,<span class="number">1547718207</span>,<span class="number">36.3</span></span><br><span class="line">shuffle:<span class="number">3</span>&gt; sensor_1,<span class="number">1547718212</span>,<span class="number">37.1</span></span><br><span class="line">rebalance:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">shuffle:<span class="number">4</span>&gt; sensor_6,<span class="number">1547718201</span>,<span class="number">15.4</span></span><br><span class="line">shuffle:<span class="number">1</span>&gt; sensor_7,<span class="number">1547718202</span>,<span class="number">6.7</span></span><br><span class="line">shuffle:<span class="number">4</span>&gt; sensor_10,<span class="number">1547718205</span>,<span class="number">38.1</span></span><br><span class="line">rebalance:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">32.8</span>&#125;</span><br><span class="line">rebalance:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">rebalance:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">rebalance:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">rebalance:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line">shuffle:<span class="number">4</span>&gt; sensor_1,<span class="number">1547718209</span>,<span class="number">32.8</span></span><br><span class="line">rebalance:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">keyBy:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">keyBy:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">keyBy:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">global:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">keyBy:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">32.8</span>&#125;</span><br><span class="line">global:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">global:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">32.8</span>&#125;</span><br><span class="line">global:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">keyBy:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">global:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">global:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">global:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line">keyBy:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718207</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">keyBy:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h3><ul>
<li><p>Flink 没有类似于 Spark 中的 foreach 方法，让用户进行迭代的操作。<strong>所有对外的输出操作都要利用 Sink 完成</strong>，最后通过类似如下的方式，完成整个任务的最终输出操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.addSink(<span class="keyword">new</span> MySink(xxxx))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Flink 官方提供了一部分框架的 Sink。除此以外，需要用户自定义实现 Sink。</p>
</li>
<li><p>地址：<a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/connectors/datastream/overview/">https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/connectors/datastream/overview/</a></p>
<p><img src="/2021/04/25/flink/image-20210506131527104.png" alt="image-20210506131527104"></p>
</li>
</ul>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul>
<li><p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/6 12:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinkTest1_Kafka</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建Kafka消费者</span></span><br><span class="line">        Properties consumerProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">        consumerProperties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        consumerProperties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">        consumerProperties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>);</span><br><span class="line">        consumerProperties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        consumerProperties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        FlinkKafkaConsumer&lt;String&gt; consumer = <span class="keyword">new</span> FlinkKafkaConsumer&lt;&gt;(<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> SimpleStringSchema(), consumerProperties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从Kafka读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.addSource(consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.序列化从Kafka中读取的数据</span></span><br><span class="line">        DataStream&lt;String&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>])).toString();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.创建Kafka生产者</span></span><br><span class="line">        Properties producerProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">        producerProperties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        producerProperties.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;producer-group&quot;</span>);</span><br><span class="line">        producerProperties.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        producerProperties.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.ByteArraySerializer&quot;</span>);</span><br><span class="line">        FlinkKafkaProducer&lt;String&gt; producer = <span class="keyword">new</span> FlinkKafkaProducer&lt;&gt;(<span class="string">&quot;sinkTest&quot;</span>, <span class="keyword">new</span> SimpleStringSchema(), producerProperties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.将数据写入Kafka</span></span><br><span class="line">        dataStream.addSink(producer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul>
<li><p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bahir<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-redis_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/6 12:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinkTest2_Redis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.定义jedis连接配置(我这里连接的是docker的redis)</span></span><br><span class="line">        FlinkJedisPoolConfig redisConfig = <span class="keyword">new</span> FlinkJedisPoolConfig.Builder()</span><br><span class="line">                .setHost(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line">                .setPort(<span class="number">6379</span>)</span><br><span class="line">                .setPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                .setDatabase(<span class="number">0</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.将数据写入Redis</span></span><br><span class="line">        dataStream.addSink(<span class="keyword">new</span> RedisSink&lt;&gt;(redisConfig, <span class="keyword">new</span> MyRedisMapper()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.自定义RedisMapper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisMapper</span> <span class="keyword">implements</span> <span class="title">RedisMapper</span>&lt;<span class="title">SensorReading</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义保存数据到Redis的命令，存成哈希表：hset sensor_temp id temperature</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RedisCommandDescription <span class="title">getCommandDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RedisCommandDescription(RedisCommand.HSET, <span class="string">&quot;sensor_temp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKeyFromData</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sensorReading.getId();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getValueFromData</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sensorReading.getTemperature().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 Redis 数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">localhost:0&gt;hgetall sensor_temp</span><br><span class="line">1) &quot;sensor_1&quot;</span><br><span class="line">2) &quot;37.1&quot;</span><br><span class="line">3) &quot;sensor_6&quot;</span><br><span class="line">4) &quot;15.4&quot;</span><br><span class="line">5) &quot;sensor_7&quot;</span><br><span class="line">6) &quot;6.7&quot;</span><br><span class="line">7) &quot;sensor_10&quot;</span><br><span class="line">8) &quot;38.1&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><ul>
<li><p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch7_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/6 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinkTest3_Es</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.定义es的连接配置</span></span><br><span class="line">        List&lt;HttpHost&gt; httpHosts = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// org.apache.http.HttpHost;</span></span><br><span class="line">        httpHosts.add(<span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.将数据写入es</span></span><br><span class="line">        dataStream.addSink(<span class="keyword">new</span> ElasticsearchSink.Builder&lt;&gt;(httpHosts, <span class="keyword">new</span> MyEsSinkFunction()).build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.实现自定义的ES写入操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEsSinkFunction</span> <span class="keyword">implements</span> <span class="title">ElasticsearchSinkFunction</span>&lt;<span class="title">SensorReading</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SensorReading sensorReading, RuntimeContext runtimeContext, RequestIndexer requestIndexer)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 定义写入的数据source</span></span><br><span class="line">            HashMap&lt;String, String&gt; dataSource = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">            dataSource.put(<span class="string">&quot;id&quot;</span>, sensorReading.getId());</span><br><span class="line">            dataSource.put(<span class="string">&quot;temp&quot;</span>, sensorReading.getTemperature().toString());</span><br><span class="line">            dataSource.put(<span class="string">&quot;ts&quot;</span>, sensorReading.getTimestamp().toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建请求，作为向es发起的写入命令(ES7统一type就是_doc，不再允许指定type)</span></span><br><span class="line">            IndexRequest indexRequest = Requests.indexRequest()</span><br><span class="line">                    .index(<span class="string">&quot;sensor&quot;</span>)</span><br><span class="line">                    .source(dataSource);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 用index发送请求</span></span><br><span class="line">            requestIndexer.add(indexRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 ElasticSearch 数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl <span class="string">&quot;localhost:9200/sensor/_search?pretty&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 1,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : &#123;</span><br><span class="line">      &quot;value&quot; : 7,</span><br><span class="line">      &quot;relation&quot; : &quot;eq&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot; : 1.0,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;sensor&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;jciyWXcBiXrGJa12kSQt&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;temp&quot; : &quot;35.8&quot;,</span><br><span class="line">          &quot;id&quot; : &quot;sensor_1&quot;,</span><br><span class="line">          &quot;ts&quot; : &quot;1547718199&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;sensor&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;jsiyWXcBiXrGJa12kSQu&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;temp&quot; : &quot;15.4&quot;,</span><br><span class="line">          &quot;id&quot; : &quot;sensor_6&quot;,</span><br><span class="line">          &quot;ts&quot; : &quot;1547718201&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;sensor&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;j8iyWXcBiXrGJa12kSQu&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;temp&quot; : &quot;6.7&quot;,</span><br><span class="line">          &quot;id&quot; : &quot;sensor_7&quot;,</span><br><span class="line">          &quot;ts&quot; : &quot;1547718202&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;sensor&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;kMiyWXcBiXrGJa12kSQu&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;temp&quot; : &quot;38.1&quot;,</span><br><span class="line">          &quot;id&quot; : &quot;sensor_10&quot;,</span><br><span class="line">          &quot;ts&quot; : &quot;1547718205&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;sensor&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;kciyWXcBiXrGJa12kSQu&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;temp&quot; : &quot;36.3&quot;,</span><br><span class="line">          &quot;id&quot; : &quot;sensor_1&quot;,</span><br><span class="line">          &quot;ts&quot; : &quot;1547718207&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;sensor&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;ksiyWXcBiXrGJa12kSQu&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;temp&quot; : &quot;32.8&quot;,</span><br><span class="line">          &quot;id&quot; : &quot;sensor_1&quot;,</span><br><span class="line">          &quot;ts&quot; : &quot;1547718209&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;sensor&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;k8iyWXcBiXrGJa12kSQu&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;temp&quot; : &quot;37.1&quot;,</span><br><span class="line">          &quot;id&quot; : &quot;sensor_1&quot;,</span><br><span class="line">          &quot;ts&quot; : &quot;1547718212&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="JDBC-自定义-Sink"><a href="#JDBC-自定义-Sink" class="headerlink" title="JDBC 自定义 Sink"></a>JDBC 自定义 Sink</h4><ul>
<li><p>以 MySQL 为例，添加 MySQL 连接依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/6 13:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinkTest4_Jdbc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从文件读取数据，单线程读取</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>).setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用之前编写的随机变动温度的SourceFunction来生成数据，数据一直生成</span></span><br><span class="line">        <span class="comment">/*DataStream&lt;SensorReading&gt; dataStream = env.addSource(new SourceTest4_UDF.MySensorSource());*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将数据写入MySQL</span></span><br><span class="line">        dataStream.addSink(<span class="keyword">new</span> MyJdbcSink());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.实现自定义的SinkFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJdbcSink</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>&lt;<span class="title">SensorReading</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 声明连接和预编译语句</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement insertStmt = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement updateStmt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 创建连接</span></span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/flink_test?useUnicode=true&amp;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;serverTimezone=Asia/Shanghai&amp;characterEncoding=UTF-8&amp;useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;example&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建预编译语句，有占位符，可传入参数</span></span><br><span class="line">            insertStmt = connection.prepareStatement(<span class="string">&quot;insert into sensor_temp (id, temp) values (?, ?)&quot;</span>);</span><br><span class="line">            updateStmt = connection.prepareStatement(<span class="string">&quot;update sensor_temp set temp = ? where id = ?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每来一条数据，调用连接，执行sql</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(SensorReading sensorReading, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 直接执行更新语句，如果没有更新那么就插入</span></span><br><span class="line">            updateStmt.setDouble(<span class="number">1</span>, sensorReading.getTemperature());</span><br><span class="line">            updateStmt.setString(<span class="number">2</span>, sensorReading.getId());</span><br><span class="line">            updateStmt.execute();</span><br><span class="line">            <span class="keyword">if</span> (updateStmt.getUpdateCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                insertStmt.setString(<span class="number">1</span>, sensorReading.getId());</span><br><span class="line">                insertStmt.setDouble(<span class="number">2</span>, sensorReading.getTemperature());</span><br><span class="line">                insertStmt.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            insertStmt.close();</span><br><span class="line">            updateStmt.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 MySQL 数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM sensor_temp;</span></span><br><span class="line">+-----------+--------------------+</span><br><span class="line">| id        | temp               |</span><br><span class="line">+-----------+--------------------+</span><br><span class="line">| sensor_3  | 20.489172407885917 |</span><br><span class="line">| sensor_10 |  73.01289164711463 |</span><br><span class="line">| sensor_4  | 43.402500895809744 |</span><br><span class="line">| sensor_1  |  6.894772325662007 |</span><br><span class="line">| sensor_2  | 101.79309911751122 |</span><br><span class="line">| sensor_7  | 63.070612021580324 |</span><br><span class="line">| sensor_8  |  63.82606628090501 |</span><br><span class="line">| sensor_5  |  57.67115738487047 |</span><br><span class="line">| sensor_6  |  50.84442627975055 |</span><br><span class="line">| sensor_9  |  52.58400793021675 |</span><br><span class="line">+-----------+--------------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM sensor_temp;</span></span><br><span class="line">+-----------+--------------------+</span><br><span class="line">| id        | temp               |</span><br><span class="line">+-----------+--------------------+</span><br><span class="line">| sensor_3  | 19.498209543035923 |</span><br><span class="line">| sensor_10 |  71.92981963197121 |</span><br><span class="line">| sensor_4  | 43.566017489470426 |</span><br><span class="line">| sensor_1  |  6.378208186786803 |</span><br><span class="line">| sensor_2  | 101.71010087830145 |</span><br><span class="line">| sensor_7  |  62.11402602179431 |</span><br><span class="line">| sensor_8  |  64.33196455020062 |</span><br><span class="line">| sensor_5  |  56.39071692662006 |</span><br><span class="line">| sensor_6  | 48.952784757264894 |</span><br><span class="line">| sensor_9  | 52.078086096436685 |</span><br><span class="line">+-----------+--------------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Flink-的-Window"><a href="#Flink-的-Window" class="headerlink" title="Flink 的 Window"></a>Flink 的 Window</h2><h3 id="Window-概述"><a href="#Window-概述" class="headerlink" title="Window 概述"></a>Window 概述</h3><img src="/2021/04/25/flink/bounded-unbounded.png" alt="img" style="zoom: 33%;">

<ul>
<li>Streaming 流式计算是一种被设计用于处理无限数据集的数据处理引擎，无限数据集是指一种不断增长的本质上无限的数据集，而 <strong>Window 是一种切割无限数据为有限块进行处理的手段。</strong></li>
<li><strong>Window 是无限数据流处理的核心，Window 将一个无限的 stream 拆分成有限大小的 “buckets” 桶，我们可以在这些桶上做计算操作。</strong></li>
</ul>
<h3 id="Window-类型"><a href="#Window-类型" class="headerlink" title="Window 类型"></a>Window 类型</h3><h4 id="时间窗口-Time-Window"><a href="#时间窗口-Time-Window" class="headerlink" title="时间窗口 (Time Window)"></a>时间窗口 (Time Window)</h4><ul>
<li><p>按照时间生成 Window。</p>
</li>
<li><p><strong>滚动时间窗口 (Tumbling Windows)</strong></p>
<ul>
<li><p>滚动窗口分配器将每个元素分配到一个指定窗口大小的窗口中，滚动窗口有一个固定的大小，并且不会出现重叠。</p>
</li>
<li><p>原理：依据<strong>固定的窗口长度</strong>对数据进行切片。</p>
</li>
<li><p><strong>特点：时间对齐，窗口长度固定，没有重叠。</strong></p>
</li>
<li><p>适用场景：适合做 BI 统计等 (做每个时间段的聚合计算)。</p>
</li>
<li><p>例如，如果指定了一个 5 分钟大小的滚动窗口，窗口的创建如下图所示：</p>
<img src="/2021/04/25/flink/image-20210506215448736.png" alt="image-20210506215448736" style="zoom: 80%;">
</li>
</ul>
</li>
<li><p><strong>滑动时间窗口 (Sliding Windows)</strong></p>
<ul>
<li><p>滑动窗口是固定窗口的更广义的一种形式。滑动窗口分配器将元素分配到固定长度的窗口中，与滚动窗口类似，窗口的大小由窗口大小参数来配置，另一个窗口滑动参数控制滑动窗口开始的频率。因此，滑动窗口如果滑动参数小于窗口大小的话，窗口是可以重叠的，在这种情况下元素会被分配到多个窗口中。</p>
</li>
<li><p>原理：滑动窗口由<strong>固定的窗口长度</strong>和<strong>滑动间隔</strong>组成。</p>
</li>
<li><p><strong>特点：时间对齐，窗口长度固定，可以有重叠。</strong></p>
</li>
<li><p>适用场景：对最近一个时间段内的统计 (比如求某接口最近 5 min 的失败率来决定是否要报警)。</p>
</li>
<li><p>例如，你有 10 分钟的窗口和 5 分钟的滑动，那么每个窗口中 5 分钟的窗口里包含着上个 10 分钟产生的数据，如下图所示：</p>
<img src="/2021/04/25/flink/image-20210507095457119.png" alt="image-20210507095457119" style="zoom:80%;">
</li>
</ul>
</li>
<li><p><strong>会话窗口 (Session Windows)</strong></p>
<ul>
<li><p>session 窗口分配器通过 session 活动来对元素进行分组，session 窗口跟滚动窗口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况，相反，当它在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关闭。一个 session 窗口通过一个 session 间隔来配置，这个 session 间隔定义了非活跃周期的长度，当这个非活跃周期产生，那么当前的 session 将关闭并且后续的元素将被分配到新的 session 窗口中去。</p>
</li>
<li><p>由一系列事件组合一个<strong>指定时间长度的 timeout 间隙</strong>组成，类似于 web 应用的 session，也就是一段时间没有接收到新数据就会生成新的窗口。</p>
</li>
<li><p><strong>特点：时间无对齐。</strong></p>
<img src="/2021/04/25/flink/image-20210507101757027.png" alt="image-20210507101757027" style="zoom:80%;">

</li>
</ul>
</li>
</ul>
<h4 id="计数窗口-Count-Window"><a href="#计数窗口-Count-Window" class="headerlink" title="计数窗口 (Count Window)"></a>计数窗口 (Count Window)</h4><ul>
<li><p>按照指定的数据条数生成一个 Window，与时间无关。</p>
</li>
<li><p><strong>滚动计数窗口</strong></p>
</li>
<li><p><strong>滑动计数窗口</strong></p>
</li>
</ul>
<h3 id="Window-API"><a href="#Window-API" class="headerlink" title="Window API"></a>Window API</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>Flink 使用 <code>window()</code> 来定义一个窗口，然后基于这个 Window 去做一些聚合或者其他处理操作。</p>
<ul>
<li><p><code>window()</code> 是最基础的定义窗口的方法。</p>
</li>
<li><p><strong><code>window()</code> 必须在 keyBy 之后才能使用</strong>。</p>
<ul>
<li>DataStream 的 <code>windowAll()</code> 类似数据传输分区的 global 操作，这个操作是 non-parallel 的 (并行度强行为 1)，所有的数据都会被传递到同一个算子 operator 上，官方建议如果非必要就不要用这个 API。</li>
</ul>
</li>
<li><p><strong><code>window()</code> 之后需要有一个窗口函数。</strong></p>
</li>
<li><p>一个完整的窗口操作参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Double&gt;&gt; minTempPerWindowStream =</span><br><span class="line">        datastream								---&gt; 数据流</span><br><span class="line">                .map(<span class="keyword">new</span> MyMapper())</span><br><span class="line">                .keyBy(data -&gt; data.f0)			---&gt; 分组</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">15</span>))	---&gt; 开窗</span><br><span class="line">                .minBy(<span class="number">1</span>);						---&gt; 窗口函数</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>window()</code> 需要接收一个输入参数：WindowAssigner (窗口分配器)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Windows this data stream to a &#123;<span class="doctag">@code</span> WindowedStream&#125;, which evaluates windows over a key</span></span><br><span class="line"><span class="comment"> * grouped stream. Elements are put into windows by a &#123;<span class="doctag">@link</span> WindowAssigner&#125;. The grouping of</span></span><br><span class="line"><span class="comment"> * elements is done both by key and by window.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.windowing.triggers.Trigger&#125; can be defined to</span></span><br><span class="line"><span class="comment"> * specify when windows are evaluated. However, &#123;<span class="doctag">@code</span> WindowAssigners&#125; have a default &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * Trigger&#125; that is used if a &#123;<span class="doctag">@code</span> Trigger&#125; is not specified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> assigner The &#123;<span class="doctag">@code</span> WindowAssigner&#125; that assigns elements to windows.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The trigger windows data stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> &lt;W extends Window&gt; <span class="function">WindowedStream&lt;T, KEY, W&gt; <span class="title">window</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowAssigner&lt;? <span class="keyword">super</span> T, W&gt; assigner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowedStream&lt;&gt;(<span class="keyword">this</span>, assigner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>WindowAssigner 是一个抽象类，负责将每条输入的数据分发到正确的 Window 中。</p>
</li>
<li><p>WindowAssigner 的实现类位于 <code>org.apache.flink.streaming.api.windowing.assigners</code> 包下：</p>
<p><img src="/2021/04/25/flink/image-20210507152955485.png" alt="image-20210507152955485"></p>
<ul>
<li><p>说明：这些实现类的构造方法多是 protected 或 privated 的，需要通过类中的静态方法如 <code>of()</code> 或 <code>withGap()</code> 来获取一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataStream</span><br><span class="line">        .keyBy(SensorReading::getId)</span><br><span class="line">        .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">15</span>)))</span><br><span class="line">        .minBy(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>归纳起来，Flink 提供了四种类型通用的 WindowAssigner：</p>
<ul>
<li><strong>滚动窗口 (tumbling window)</strong></li>
<li><strong>滑动窗口 (sliding window)</strong></li>
<li><strong>会话窗口 (session window)</strong></li>
<li><strong>全局窗口 (global window)</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>除了 <code>.window()</code>，Flink 提供了更加简单的 <code>.timeWindow() </code> 和 <code>.countWindow() </code> 方法，用于定义时间窗口和计数窗口。</p>
</li>
</ul>
<h4 id="创建不同类型的窗口"><a href="#创建不同类型的窗口" class="headerlink" title="创建不同类型的窗口"></a>创建不同类型的窗口</h4><ul>
<li><p>Flink 创建窗口的方法有多种，实际使用时，按需求创建。</p>
</li>
<li><p>滚动时间窗口 (tumbling time window)：当时间达到窗口大小时，就会触发窗口的执行。</p>
<ul>
<li><p><code>.window(TumblingProcessingTimeWindows.of(Time.seconds(10)))</code></p>
</li>
<li><p><code>.window(TumblingEventTimeWindows.of(Time.seconds(10)))</code></p>
</li>
<li><p><code>.timeWindow(Time.seconds(15))</code>，Flink 1.12.1 版本已弃用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Windows this &#123;<span class="doctag">@code</span> KeyedStream&#125; into tumbling time windows.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a shortcut for either &#123;<span class="doctag">@code</span> .window(TumblingEventTimeWindows.of(size))&#125; or &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * .window(TumblingProcessingTimeWindows.of(size))&#125; depending on the time characteristic set</span></span><br><span class="line"><span class="comment"> * using &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.streaming.api.environment.StreamExecutionEnvironment#setStreamTimeCharacteristic(org.apache.flink.streaming.api.TimeCharacteristic)&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size The size of the window.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> Please use &#123;<span class="doctag">@link</span> #window(WindowAssigner)&#125; with either &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> *     TumblingEventTimeWindows&#125; or &#123;<span class="doctag">@link</span> TumblingProcessingTimeWindows&#125;. For more information,</span></span><br><span class="line"><span class="comment"> *     see the deprecation notice on &#123;<span class="doctag">@link</span> TimeCharacteristic&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> window(TumblingProcessingTimeWindows.of(size));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window(TumblingEventTimeWindows.of(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>滑动时间窗口 (sliding time window)：两个参数，前者是 window_size，后者是 sliding_size。每隔 sliding_size 计算输出结果一次，每一次计算的 window 范围是 window_size 内的所有元素。</p>
<ul>
<li><p><code>.window(TumblingProcessingTimeWindows.of(Time.seconds(10), Time.seconds(5)))</code></p>
</li>
<li><p><code>.window(TumblingEventTimeWindows.of(Time.seconds(10), Time.seconds(5s)))</code></p>
</li>
<li><p><code>.timeWindow(Time.seconds(15), Time.seconds(5))</code>，Flink 1.12.1 版本已弃用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Windows this &#123;<span class="doctag">@code</span> KeyedStream&#125; into sliding time windows.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a shortcut for either &#123;<span class="doctag">@code</span> .window(SlidingEventTimeWindows.of(size, slide))&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> .window(SlidingProcessingTimeWindows.of(size, slide))&#125; depending on the time</span></span><br><span class="line"><span class="comment"> * characteristic set using &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.streaming.api.environment.StreamExecutionEnvironment#setStreamTimeCharacteristic(org.apache.flink.streaming.api.TimeCharacteristic)&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size The size of the window.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> Please use &#123;<span class="doctag">@link</span> #window(WindowAssigner)&#125; with either &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> *     SlidingEventTimeWindows&#125; or &#123;<span class="doctag">@link</span> SlidingProcessingTimeWindows&#125;. For more information,</span></span><br><span class="line"><span class="comment"> *     see the deprecation notice on &#123;<span class="doctag">@link</span> TimeCharacteristic&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size, Time slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> window(SlidingProcessingTimeWindows.of(size, slide));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window(SlidingEventTimeWindows.of(size, slide));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>会话窗口 (session window)</p>
<ul>
<li><code>.window(ProcessingTimeSessionWindows.withGap(Time.minutes(10)))</code></li>
<li><code>.window(EventTimeSessionWindows.withGap(Time.minutes(10)))</code></li>
</ul>
</li>
<li><p>滚动计数窗口 (tumbling count window)：当元素数量达到窗口大小时，就会触发窗口的执行。</p>
<ul>
<li><code>.countWindow(5)</code></li>
</ul>
</li>
<li><p>滑动计数窗口 (sliding count window)：两个参数，前者是 window_size，后者是 sliding_size。每隔 sliding_size 计算输出结果一次，每一次计算的 window 范围是 window_size 内的所有元素。</p>
<ul>
<li><code>.countWindow(10, 2)</code></li>
</ul>
</li>
</ul>
<h4 id="窗口函数-window-function"><a href="#窗口函数-window-function" class="headerlink" title="窗口函数 (window function)"></a>窗口函数 (window function)</h4><ul>
<li><p>window function 定义了要对窗口中收集的数据做的计算操作，主要分为两类。</p>
</li>
<li><p><strong>增量聚合函数 (incremental aggregation functions)</strong></p>
<ul>
<li><p><strong>每条数据到来就进行计算，保持一个简单的状态。</strong>(来一条处理一条，但是不输出，到窗口临界位置才输出)</p>
</li>
<li><p>典型的增量聚合函数有 ReduceFunction，AggregateFunction。</p>
</li>
<li><p>ReduceFunction：</p>
<ul>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base interface for Reduce functions. Reduce functions combine groups of elements to a single</span></span><br><span class="line"><span class="comment"> * value, by taking always two elements and combining them into one. Reduce functions may be used on</span></span><br><span class="line"><span class="comment"> * entire data sets, or on grouped data sets. In the latter case, each group is reduced</span></span><br><span class="line"><span class="comment"> * individually.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For a reduce functions that work on an entire group at the same time (such as the</span></span><br><span class="line"><span class="comment"> * MapReduce/Hadoop-style reduce), see &#123;<span class="doctag">@link</span> GroupReduceFunction&#125;. In the general case,</span></span><br><span class="line"><span class="comment"> * ReduceFunctions are considered faster, because they allow the system to use more efficient</span></span><br><span class="line"><span class="comment"> * execution strategies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The basic syntax for using a grouped ReduceFunction is as follows:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * DataSet&lt;X&gt; input = ...;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DataSet&lt;X&gt; result = input.groupBy(&lt;key-definition&gt;).reduce(new MyReduceFunction());</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Like all functions, the ReduceFunction needs to be serializable, as defined in &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.io.Serializable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; Type of the elements that this function processes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReduceFunction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The core method of ReduceFunction, combining two values into one value of the same type. The</span></span><br><span class="line"><span class="comment">     * reduce function is consecutively applied to all values of a group until only a single value</span></span><br><span class="line"><span class="comment">     * remains.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value1 The first value to combine.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value2 The second value to combine.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The combined value of both input values.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the</span></span><br><span class="line"><span class="comment">     *     operation to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">reduce</span><span class="params">(T value1, T value2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/7 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1_TimeWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据，对于开窗，从本地读取数据时，耗时很短，可能窗口的临界点还没到，程序就结束了，也就看不到效果</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.开窗测试，时间窗口，增量聚合函数</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; resultStream = dataStream.keyBy(SensorReading::getId)</span><br><span class="line">                .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">15</span>)))</span><br><span class="line">                <span class="comment">// 归约</span></span><br><span class="line">                .reduce(<span class="keyword">new</span> ReduceFunction&lt;SensorReading&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> SensorReading <span class="title">reduce</span><span class="params">(SensorReading value1, SensorReading value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(value1.getId(), value2.getTimestamp(),</span><br><span class="line">                                Math.max(value1.getTemperature(), value2.getTemperature()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/WINDOWS/system32$ nc -tl 7777</span><br><span class="line">sensor_1,1547718212,37.1</span><br><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_1,1547718209,32.8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">3&gt; SensorReading</span>&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718209</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>AggregateFunction：</p>
<ul>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> AggregateFunction&#125; is a flexible aggregation function, characterized by the following</span></span><br><span class="line"><span class="comment"> * features:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;The aggregates may use different types for input values, intermediate aggregates, and</span></span><br><span class="line"><span class="comment"> *       result type, to support a wide range of aggregation types.</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;Support for distributive aggregations: Different intermediate aggregates can be merged</span></span><br><span class="line"><span class="comment"> *       together, to allow for pre-aggregation/final-aggregation optimizations.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@code</span> AggregateFunction&#125;&#x27;s intermediate aggregate (in-progress aggregation state) is</span></span><br><span class="line"><span class="comment"> * called the &lt;i&gt;accumulator&lt;/i&gt;. Values are added to the accumulator, and final aggregates are</span></span><br><span class="line"><span class="comment"> * obtained by finalizing the accumulator state. This supports aggregation functions where the</span></span><br><span class="line"><span class="comment"> * intermediate state needs to be different than the aggregated values and the final result type,</span></span><br><span class="line"><span class="comment"> * such as for example &lt;i&gt;average&lt;/i&gt; (which typically keeps a count and sum). Merging intermediate</span></span><br><span class="line"><span class="comment"> * aggregates (partial aggregates) means merging the accumulators.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The AggregationFunction itself is stateless. To allow a single AggregationFunction instance to</span></span><br><span class="line"><span class="comment"> * maintain multiple aggregates (such as one aggregate per key), the AggregationFunction creates a</span></span><br><span class="line"><span class="comment"> * new accumulator whenever a new aggregation is started.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Aggregation functions must be &#123;<span class="doctag">@link</span> Serializable&#125; because they are sent around between</span></span><br><span class="line"><span class="comment"> * distributed processes during distributed execution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h1&gt;Example: Average and Weighted Average&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * // the accumulator, which holds the state of the in-flight aggregate</span></span><br><span class="line"><span class="comment"> * public class AverageAccumulator &#123;</span></span><br><span class="line"><span class="comment"> *     long count;</span></span><br><span class="line"><span class="comment"> *     long sum;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // implementation of an aggregation function for an &#x27;average&#x27;</span></span><br><span class="line"><span class="comment"> * public class Average implements AggregateFunction&lt;Integer, AverageAccumulator, Double&gt; &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public AverageAccumulator createAccumulator() &#123;</span></span><br><span class="line"><span class="comment"> *         return new AverageAccumulator();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public AverageAccumulator merge(AverageAccumulator a, AverageAccumulator b) &#123;</span></span><br><span class="line"><span class="comment"> *         a.count += b.count;</span></span><br><span class="line"><span class="comment"> *         a.sum += b.sum;</span></span><br><span class="line"><span class="comment"> *         return a;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public AverageAccumulator add(Integer value, AverageAccumulator acc) &#123;</span></span><br><span class="line"><span class="comment"> *         acc.sum += value;</span></span><br><span class="line"><span class="comment"> *         acc.count++;</span></span><br><span class="line"><span class="comment"> *         return acc;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public Double getResult(AverageAccumulator acc) &#123;</span></span><br><span class="line"><span class="comment"> *         return acc.sum / (double) acc.count;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // implementation of a weighted average</span></span><br><span class="line"><span class="comment"> * // this reuses the same accumulator type as the aggregate function for &#x27;average&#x27;</span></span><br><span class="line"><span class="comment"> * public class WeightedAverage implements AggregateFunction&lt;Datum, AverageAccumulator, Double&gt; &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public AverageAccumulator createAccumulator() &#123;</span></span><br><span class="line"><span class="comment"> *         return new AverageAccumulator();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public AverageAccumulator merge(AverageAccumulator a, AverageAccumulator b) &#123;</span></span><br><span class="line"><span class="comment"> *         a.count += b.count;</span></span><br><span class="line"><span class="comment"> *         a.sum += b.sum;</span></span><br><span class="line"><span class="comment"> *         return a;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public AverageAccumulator add(Datum value, AverageAccumulator acc) &#123;</span></span><br><span class="line"><span class="comment"> *         acc.count += value.getWeight();</span></span><br><span class="line"><span class="comment"> *         acc.sum += value.getValue();</span></span><br><span class="line"><span class="comment"> *         return acc;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public Double getResult(AverageAccumulator acc) &#123;</span></span><br><span class="line"><span class="comment"> *         return acc.sum / (double) acc.count;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;IN&gt; The type of the values that are aggregated (input values) ---&gt; 聚合值的类型(输入值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;ACC&gt; The type of the accumulator (intermediate aggregate state). ---&gt; 累加器的类型(中间聚合状态)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;OUT&gt; The type of the aggregated result ---&gt; 聚合结果的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AggregateFunction</span>&lt;<span class="title">IN</span>, <span class="title">ACC</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new accumulator, starting a new aggregate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The new accumulator is typically meaningless unless a value is added via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #add(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The accumulator is the state of a running aggregation. When a program has multiple</span></span><br><span class="line"><span class="comment">     * aggregates in progress (such as per key and window), the state (per key and window) is the</span></span><br><span class="line"><span class="comment">     * size of the accumulator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A new accumulator, corresponding to an empty aggregate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ACC <span class="title">createAccumulator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds the given input value to the given accumulator, returning the new accumulator value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;For efficiency, the input accumulator may be modified and returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value The value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulator The accumulator to add the value to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The accumulator with the updated state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ACC <span class="title">add</span><span class="params">(IN value, ACC accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the result of the aggregation from the accumulator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulator The accumulator of the aggregation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The final aggregation result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">OUT <span class="title">getResult</span><span class="params">(ACC accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merges two accumulators, returning an accumulator with the merged state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This function may reuse any of the given accumulators as the target for the merge and</span></span><br><span class="line"><span class="comment">     * return that. The assumption is that the given accumulators will not be used any more after</span></span><br><span class="line"><span class="comment">     * having been passed to this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a An accumulator to merge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b Another accumulator to merge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The accumulator with the merged state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ACC <span class="title">merge</span><span class="params">(ACC a, ACC b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/7 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1_TimeWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据，对于开窗，从本地读取数据时，耗时很短，可能窗口的临界点还没到，程序就结束了，也就看不到效果</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.开窗测试，时间窗口，增量聚合函数</span></span><br><span class="line">        DataStream&lt;Integer&gt; resultStream = dataStream.keyBy(SensorReading::getId)</span><br><span class="line">                .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">15</span>)))</span><br><span class="line">                <span class="comment">// 统计每个分组下数据的个数，中间聚合状态的类型和最终输出的类型是一致的</span></span><br><span class="line">                .aggregate(<span class="keyword">new</span> AggregateFunction&lt;SensorReading, Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 创建一个累加器</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 初始值，从0开始</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 来一条数据后，该怎么累加</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">add</span><span class="params">(SensorReading value, Integer accumulator)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 累加器基础上+1</span></span><br><span class="line">                        <span class="keyword">return</span> accumulator + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回最终的处理结果</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">getResult</span><span class="params">(Integer accumulator)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 就是返回累加器</span></span><br><span class="line">                        <span class="keyword">return</span> accumulator;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// merge方法一般在session window中使用，可能会存在一些合并的操作</span></span><br><span class="line">                    <span class="comment">// 不存在分区合并，因为当前处理的都是keyBy之后的</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">merge</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 为防止意外，将两个状态a和b相加</span></span><br><span class="line">                        <span class="keyword">return</span> a + b;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/WINDOWS/system32$ nc -tl 7777</span><br><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_1,1547718207,36.3</span><br><span class="line">sensor_1,1547718209,32.8</span><br><span class="line">sensor_1,1547718212,37.1</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">3&gt; 2</span></span><br><span class="line"><span class="function">2&gt; 1</span></span><br><span class="line"><span class="function">3&gt; 2</span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>全窗口函数 (full window functions)</strong></p>
<ul>
<li><p><strong>先把窗口所有数据收集起来，等到计算的时候再遍历所有数据。</strong>(来一条存放一条，到窗口临界位置才遍历且计算、输出)</p>
</li>
<li><p>典型的全窗口函数有 ProcessWindowFunction，WindowFunction。</p>
</li>
<li><p>ProcessWindowFunction：</p>
<ul>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base abstract class for functions that are evaluated over keyed (grouped) windows using a context</span></span><br><span class="line"><span class="comment"> * for retrieving extra information.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;IN&gt; The type of the input value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;OUT&gt; The type of the output value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;KEY&gt; The type of the key.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;W&gt; The type of &#123;<span class="doctag">@code</span> Window&#125; that this window function can be applied on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates the window and outputs none or several elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key for which this window is evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context in which the window is being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements The elements in the window being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out A collector for emitting elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deletes any state in the &#123;<span class="doctag">@code</span> Context&#125; when the Window expires (the watermark passes its</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> maxTimestamp&#125; + &#123;<span class="doctag">@code</span> allowedLateness&#125;).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context to which the window is being evaluated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The context holding window metadata. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Returns the window that is being evaluated. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the current processing time. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the current event-time watermark. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * State accessor for per-key and per-window state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt;If you use per-window state you have to ensure that you clean it up by</span></span><br><span class="line"><span class="comment">         * implementing &#123;<span class="doctag">@link</span> ProcessWindowFunction#clear(Context)&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** State accessor for per-key global state. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/7 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1_TimeWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据，对于开窗，从本地读取数据时，耗时很短，可能窗口的临界点还没到，程序就结束了，也就看不到效果</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.开窗测试，时间窗口，全窗口函数</span></span><br><span class="line">        DataStream&lt;Tuple3&lt;String, Long, Integer&gt;&gt; resultStream = dataStream.keyBy(SensorReading::getId)</span><br><span class="line">                .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">15</span>)))</span><br><span class="line">                <span class="comment">// 统计每个分组下数据的个数</span></span><br><span class="line">                .process(<span class="keyword">new</span> ProcessWindowFunction&lt;SensorReading, Tuple3&lt;String, Long, Integer&gt;, String, TimeWindow&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String key, Context context, Iterable&lt;SensorReading&gt; elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Collector&lt;Tuple3&lt;String, Long, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 把elements转换为List，然后其长度就是当前分组下数据的个数</span></span><br><span class="line">                        Integer count = IteratorUtils.toList(elements.iterator()).size();</span><br><span class="line">                        <span class="comment">// 输出一个三元组：key，窗口结束时间，数据个数</span></span><br><span class="line">                        out.collect(<span class="keyword">new</span> Tuple3&lt;&gt;(key, context.window().getEnd(), count));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/WINDOWS/system32$ nc -tl 7777</span><br><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_1,1547718209,32.8</span><br><span class="line">sensor_1,1547718212,37.1    ---&gt; 此数据的输入与前面相同的key的时间间隔，超出15s，在下一个窗口处理</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">4&gt; <span class="params">(sensor_7,<span class="number">1620451335000</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">3&gt; <span class="params">(sensor_1,<span class="number">1620451335000</span>,<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">3&gt; <span class="params">(sensor_1,<span class="number">1620451365000</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>WindowFunction：</p>
<ul>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base interface for functions that are evaluated over keyed (grouped) windows.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;IN&gt; The type of the input value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;OUT&gt; The type of the output value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;KEY&gt; The type of the key.    ---&gt; 分组的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;W&gt; The type of &#123;<span class="doctag">@code</span> Window&#125; that this window function can be applied on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates the window and outputs none or several elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key for which this window is evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> window The window that is being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input The elements in the window being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out A collector for emitting elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(KEY key, W window, Iterable&lt;IN&gt; input, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/7 12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1_TimeWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据，对于开窗，从本地读取数据时，耗时很短，可能窗口的临界点还没到，程序就结束了，也就看不到效果</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.开窗测试，时间窗口，全窗口函数</span></span><br><span class="line">        DataStream&lt;Tuple3&lt;String, Long, Integer&gt;&gt; resultStream = dataStream.keyBy(SensorReading::getId)</span><br><span class="line">                .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">15</span>)))</span><br><span class="line">                <span class="comment">// 统计每个分组下数据的个数</span></span><br><span class="line">                .apply(<span class="keyword">new</span> WindowFunction&lt;SensorReading, Tuple3&lt;String, Long, Integer&gt;, String, TimeWindow&gt;() &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    input：当前输入的所有的数据</span></span><br><span class="line"><span class="comment">                    out：当前输出的数据</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(String key, TimeWindow window, Iterable&lt;SensorReading&gt; input,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Collector&lt;Tuple3&lt;String, Long, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 把input转换为List，然后其长度就是当前分组下数据的个数</span></span><br><span class="line">                        Integer count = IteratorUtils.toList(input.iterator()).size();</span><br><span class="line">                        <span class="comment">// 输出一个三元组：key，窗口结束时间，数据个数</span></span><br><span class="line">                        out.collect(<span class="keyword">new</span> Tuple3&lt;&gt;(key, window.getEnd(), count));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/WINDOWS/system32$ nc -tl 7777</span><br><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_1,1547718209,32.8</span><br><span class="line">sensor_1,1547718212,37.1    ---&gt; 此数据的输入与前面相同的key的时间间隔，超出15s，在下一个窗口处理</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">3&gt; <span class="params">(sensor_1,<span class="number">1620450990000</span>,<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">4&gt; <span class="params">(sensor_7,<span class="number">1620450990000</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">3&gt; <span class="params">(sensor_1,<span class="number">1620451095000</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>前面的例子是以时间窗口写的，下面以计数窗口为例。</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XiSun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/8 13:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest2_CountWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据，对于开窗，从本地读取数据时，耗时很短，可能窗口的临界点还没到，程序就结束了，也就看不到效果</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.开窗测试，技术窗口，增量聚合函数</span></span><br><span class="line">        DataStream&lt;Double&gt; resultStream = dataStream.keyBy(SensorReading::getId)</span><br><span class="line">                <span class="comment">// 4个数开一个窗口，隔两个数滑动一次</span></span><br><span class="line">                .countWindow(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">                <span class="comment">// 计算窗口内数据温度的平均值</span></span><br><span class="line">                .aggregate(<span class="keyword">new</span> MyAvgTemp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAvgTemp</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Tuple2</span>&lt;<span class="title">Double</span>, <span class="title">Integer</span>&gt;, <span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Double, Integer&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0.0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Double, Integer&gt; <span class="title">add</span><span class="params">(SensorReading value, Tuple2&lt;Double, Integer&gt; accumulator)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 每来一条数据，把温度值加到二元组的第一个元素上，二元组第二个元素自增1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(accumulator.f0 + value.getTemperature(), accumulator.f1 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">getResult</span><span class="params">(Tuple2&lt;Double, Integer&gt; accumulator)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 返回所有数据温度的平均值</span></span><br><span class="line">            <span class="keyword">return</span> accumulator.f0 / accumulator.f1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Double, Integer&gt; <span class="title">merge</span><span class="params">(Tuple2&lt;Double, Integer&gt; a, Tuple2&lt;Double, Integer&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP-OM8IACS:/mnt/c/WINDOWS/system32$ nc -tl 7777</span><br><span class="line">sensor_1,1547718199,1</span><br><span class="line">sensor_1,1547718199,2</span><br><span class="line">sensor_1,1547718199,3</span><br><span class="line">sensor_1,1547718199,4</span><br><span class="line">sensor_1,1547718199,5</span><br><span class="line">sensor_1,1547718199,6</span><br><span class="line">sensor_1,1547718199,7</span><br><span class="line">sensor_1,1547718199,8</span><br><span class="line">sensor_1,1547718199,9</span><br><span class="line">sensor_1,1547718199,10</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">3&gt; 1.5   ---&gt; <span class="params">(<span class="number">1</span>+<span class="number">2</span>)</span>/2</span></span><br><span class="line"><span class="function">3&gt; 2.5   ---&gt; <span class="params">(<span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>)</span>/4</span></span><br><span class="line"><span class="function">3&gt; 4.5   ---&gt; <span class="params">(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>+<span class="number">6</span>)</span>/4</span></span><br><span class="line"><span class="function">3&gt; 6.5   ---&gt; <span class="params">(<span class="number">5</span>+<span class="number">6</span>+<span class="number">7</span>+<span class="number">8</span>)</span>/4</span></span><br><span class="line"><span class="function">3&gt; 8.5   ---&gt; <span class="params">(<span class="number">7</span>+<span class="number">8</span>+<span class="number">9</span>+<span class="number">10</span>)</span>/4</span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>滑动的距离是 2，因此前两个数计算一次平均值</strong>，后两个数来时，与前面两个数组成一个完整窗口 4 个数，计算一次平均值，后面都是 4 个数计算一次平均值。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="其他可选-API"><a href="#其他可选-API" class="headerlink" title="其他可选 API"></a>其他可选 API</h3><ul>
<li><p><code>.trigger()</code>：触发器，定义 window 什么时候关闭，触发计算并输出结果。一般不使用。</p>
</li>
<li><p><code>.evictor()</code>：移除器，定义移除某些数据的逻辑。一般不使用。</p>
</li>
<li><p><code>.allowedLateness()</code>：允许处理迟到的数据。</p>
</li>
<li><p><code>.sideOutputLateData()</code>：将迟到的数据放入侧输出流。</p>
</li>
<li><p><code>.getSideOutput()</code>：获取侧输出流。</p>
</li>
<li><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OutputTag&lt;SensorReading&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;late&quot;</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;SensorReading&gt; sumStream = dataStream.keyBy(SensorReading::getId)</span><br><span class="line">    			  .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">15</span>)))</span><br><span class="line"><span class="comment">//                .trigger()</span></span><br><span class="line"><span class="comment">//                .evictor()</span></span><br><span class="line">    			  <span class="comment">// 允许1分钟内的迟到数据&lt;=比如数据产生时间在窗口范围内，但是要处理的时候已经超过窗口时间了</span></span><br><span class="line">    			  .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">    			  <span class="comment">// 侧输出流，迟到超过1分钟的数据，收集于此</span></span><br><span class="line">                  .sideOutputLateData(outputTag)</span><br><span class="line">                  .sum(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">sumStream.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Window-API-总览"><a href="#Window-API-总览" class="headerlink" title="Window API 总览"></a>Window API 总览</h3><p><img src="/2021/04/25/flink/image-20210508161548431.png" alt="image-20210508161548431"></p>
<h2 id="Flink-的时间语义和-Wartermark"><a href="#Flink-的时间语义和-Wartermark" class="headerlink" title="Flink 的时间语义和 Wartermark"></a>Flink 的时间语义和 Wartermark</h2><h3 id="Flink-中的时间语义"><a href="#Flink-中的时间语义" class="headerlink" title="Flink 中的时间语义"></a>Flink 中的时间语义</h3><img src="/2021/04/25/flink/image-20210508172915347.png" alt="image-20210508172915347" style="zoom:80%;">

<ul>
<li><strong>Event Time：事件创建的时间。</strong><ul>
<li>Event Time 是事件创建的时间。它通常由事件中的时间戳描述，例如采集的日志数据中，每一条日志都会记录自己的生成时间，Flink 通过时间戳分配器访问事件时间戳。</li>
</ul>
</li>
<li>Ingestion Time：数据进入Flink 的时间。</li>
<li>Processing Time：执行操作算子的本地系统时间，与机器相关。</li>
</ul>
<h3 id="哪种时间语义更重要"><a href="#哪种时间语义更重要" class="headerlink" title="哪种时间语义更重要"></a>哪种时间语义更重要</h3><img src="/2021/04/25/flink/image-20210508173159146.png" alt="image-20210508173159146" style="zoom:80%;">

<ul>
<li>不同的时间语义有不同的应用场合。</li>
<li>我们<strong>往往更关心事件时间 (Event Time)。</strong></li>
</ul>
<img src="/2021/04/25/flink/image-20210508173336325.png" alt="image-20210508173336325" style="zoom:80%;">

<ul>
<li>这里假设玩游戏，两分钟内如果过 5 关就有奖励。用户坐地铁玩游戏，进入隧道前已经过 3 关，在隧道中又过了 5 关。但是信号不好，后 5 关通关的信息，等到出隧道的时候 (8:23:20) 才正式到达服务器。</li>
<li>在这个应用场合下，如果为了用户体验，则不应该使用 Processing Time，而是应该按照 Event Time 处理信息，保证用户获得游戏奖励。</li>
<li>Event Time 可以从日志数据的时间戳 (timestamp) 中提取：<ul>
<li><code>2017-11-02 18:37:15.624 INFO Fail over to rm</code></li>
</ul>
</li>
</ul>
<h3 id="在代码中设置-Event-Time"><a href="#在代码中设置-Event-Time" class="headerlink" title="在代码中设置 Event Time"></a>在代码中设置 Event Time</h3><ul>
<li><p>在 Flink 的流式处理中，绝大部分的业务都会使用 Event Time，一般只在 Event Time 无法使用时，才会被迫使用 Processing Time 或者 Ingestion Time。</p>
</li>
<li><p>如果要使用 Event Time，那么需要引入 Event Time 的时间属性，引入方式如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 从调用时刻开始给env创建的每一个stream追加时间特征</span></span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><h4 id="Watermark-的基本概念"><a href="#Watermark-的基本概念" class="headerlink" title="Watermark 的基本概念"></a>Watermark 的基本概念</h4><ul>
<li><p>我们知道，流处理从事件产生，到流经 Source，再到 Operator，中间是有一个过程和时间的，虽然大部分情况下，流到 Operator 的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、分布式等原因，导致乱序的产生，所谓乱序，就是指 Flink 接收到的事件的先后顺序不是严格按照事件的 Event Time 顺序排列的。那么此时出现一个问题，一旦出现乱序，如果只根据 Event Time 决定 Window 的运行，我们不能明确数据是否全部到位，但又不能无限期的等下去，此时必须要有个机制来保证一个特定的时间后，必须触发 Window 去进行计算了，这个特别的机制，就是 Watermark。</p>
<p><img src="/2021/04/25/flink/image-20210802131640148.png" alt="image-20210802131640148"></p>
<p><img src="/2021/04/25/flink/image-20210804102019506.png" alt="image-20210804102019506"></p>
<ul>
<li>当 Flink 以 Event Time 模式处理数据流时，它会根据数据里的时间戳来处理基于时间的算子。</li>
<li>由于网络、分布式等原因，会导致乱序数据的产生。</li>
<li>乱序数据会让窗口计算不准确。</li>
<li>遇到一个时间戳达到了窗口关闭时间，不应该立刻触发窗口计算，而是等待一段时间，等迟到的数据来了再关闭窗口。</li>
</ul>
</li>
<li><p>Watermark 是一种衡量 Event Time 进展的机制。</p>
</li>
<li><p><strong>Watermark 是用于处理乱序事件的，而正确的处理乱序事件，通常用 Watermark 机制结合 Window 来实现。</strong></p>
</li>
<li><p>数据流中的 Watermark 用于表示 timestamp 小于 Watermark 的数据，都已经到达了，因此，Window 的执行也是由 Watermark 触发的。</p>
</li>
<li><p>Watermark 可以理解成一个延迟触发机制，我们可以设置 Watermark 的延时时长 t，每次系统会校验已经到达的数据中最大的 maxEventTime，然后认定 Event Time 小于 maxEventTime - t 的所有数据都已经到达，如果有窗口的停止时间等于 maxEventTime – t (说明这个窗口的所有数据都已到达)，那么这个窗口被触发执行。</p>
</li>
<li><p>Watermark 用来让程序自己平衡延迟和结果正确性。</p>
</li>
<li><p>有序流的 Watermarker 如下图所示：(Watermark 的延时时长设置为 0s)</p>
<p><img src="/2021/04/25/flink/image-20210803225357577.png" alt="image-20210803225357577"></p>
</li>
<li><p>乱序流的 Watermarker 如下图所示：(Watermark 的延时时长设置为 2s)</p>
<p><img src="/2021/04/25/flink/image-20210803225534170.png" alt="image-20210803225534170"></p>
<ul>
<li>当 Flink 接收到数据时，会按照一定的规则去生成 Watermark，这条 Watermark 就等于当前所有到达数据中的 maxEventTime - 延时时长 t，也就是说，Watermark 是基于数据携带的时间戳生成的，一旦 Watermark 比当前未触发的窗口的停止时间要晚，那么就会触发相应窗口的执行。由于 Event Time 是由数据携带的，因此，如果运行过程中无法获取新的数据，那么没有被触发的窗口将永远都不被触发。上图中，我们设置的允许最大延时时长为 2s，所以时间戳为 7s 的事件对应的 Watermark 是 5s，时间戳为 12s 的事件的 Watermark 是 10s，如果我们的 Window 1 是 1s ~ 5s，Window 2 是 6s ~ 10s，那么时间戳为 7s 的事件到达时的 Watermarker 恰好触发 Window 1，时间戳为 12s 的事件到达时的 Watermark 恰好触发 Window 2。</li>
<li>Watermark 就是触发前一窗口的 “关窗时间”，一旦触发关门那么以当前时刻为准在窗口范围内的所有所有数据都会收入窗中。</li>
<li>只要新来的数据没有达到 Watermark，那么不管现实中的时间推进了多久，都不会触发关窗。</li>
</ul>
</li>
<li><p>Watermark 的延时时长，应结合实际数据到达的迟到程度来设置。比如下图所示，当前到达数据的最大时间戳为 5s，其后续迟到数据有 2s 和 3s，那 Watermark 延时时长 t 应设置为 3s。</p>
<p><img src="/2021/04/25/flink/image-20210804104402570.png" alt="image-20210804104402570"></p>
<ul>
<li><p>上图中，Watermark 的变化规律：1s 数据为 -2，4s 数据为 1，5s 数据为 2，2s 数据为 2，3s 数据为 2，6s 数据为 3。</p>
<ul>
<li>Watermark 只单调递增，所以 2s 和 3s 的数据，都为 2。</li>
</ul>
</li>
<li><p>如果有设置为 2s 的 Window，其会在 5s 数据到达时，触发执行。如果有设置为 5s 的 Window，则会在 8s 数据到达时，才会触发执行。</p>
</li>
<li><p>具体的数据流向，可参考下图：</p>
<p><img src="/2021/04/25/flink/image-20210804112151265.png" alt="image-20210804112151265"></p>
<ul>
<li>从图中可以看出，当 8s 数据到达时，Watermark 为 5，此时，触发 0 ~ 5s 的 Window 数据桶关闭，并输出一次结果，如果 8s 数据不到达，0 ~ 5s 的数据桶，会一直开启。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Watermark-的特点"><a href="#Watermark-的特点" class="headerlink" title="Watermark 的特点"></a>Watermark 的特点</h4><p><img src="/2021/04/25/flink/image-20210804095939601.png" alt="image-20210804095939601"></p>
<ul>
<li><p>上图中，三角形表示数据自带的时间戳。</p>
</li>
<li><p>Watermark 是一条特殊的数据记录，其本质上就是一个带时间戳的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.flink.api.common.eventtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Watermark</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Thread local formatter for stringifying the timestamps. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; TS_FORMATTER = ThreadLocal.withInitial(</span><br><span class="line">      () -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** The watermark that signifies end-of-event-time. */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Watermark MAX_WATERMARK = <span class="keyword">new</span> Watermark(Long.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** The timestamp of the watermark in milliseconds. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new watermark with the given timestamp in milliseconds.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Watermark</span><span class="params">(<span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the timestamp associated with this Watermark.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> timestamp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Formats the timestamp of this watermark, assuming it is a millisecond timestamp.</span></span><br><span class="line"><span class="comment">    * The returned format is &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFormattedTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> TS_FORMATTER.get().format(<span class="keyword">new</span> Date(timestamp));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span> == o ||</span><br><span class="line">            o != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            o.getClass() == Watermark.class &amp;&amp;</span><br><span class="line">            ((Watermark) o).timestamp == <span class="keyword">this</span>.timestamp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Long.hashCode(timestamp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Watermark @ &quot;</span> + timestamp + <span class="string">&quot; (&quot;</span> + getFormattedTimestamp() + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Watermark 必须单调递增，以确保任务的事件时间时钟在向前推进，而不是在后退。</p>
</li>
<li><p>Watermark 与数据的时间戳相关。</p>
</li>
<li><p>Watermark 可以为负值，表示事件还未发生。</p>
</li>
</ul>
<h4 id="Watermark-的传递"><a href="#Watermark-的传递" class="headerlink" title="Watermark 的传递"></a>Watermark 的传递</h4><p><img src="/2021/04/25/flink/image-20210804113522284.png" alt="image-20210804113522284"></p>
<ul>
<li>Watermark 向下游传递：上游接收到 Watermark 后，会广播到下游的所有任务。</li>
<li>当上游存在多个并行任务时，下游子任务可能会接收到上游广播的多个 Watermark，此时，当前子任务会取时间戳最小的那个 Watermark，因为这样才能保证上游并行任务的每一个，Watermark 之前的数据都到了。</li>
<li>上图 1 中，上游四条并行的数据流，从上到下，当前广播即将到达的 Watermark 分别为 4s，7s 和 6s，而 Task 在之前已经到达并保存的 Watermark 分别为 2s，4s，3s 和 6s，Task 的 Watermark 为 2s。</li>
<li>上图 2 中，Task 接收到第一个分区新的 Watermark 4s，第一个分区的 Watermark 由 2s 更新为 4s，整个 Task 的 Watermark 对比更新为 3s，并广播到下游所有任务。</li>
<li>上图 3 中，Task 接收到第二个分区新的 Watermark 7s，第二个分区的 Watermark 由 4s 更新为 7s，整个 Task 的 Watermark 对比仍为 3s，此时，Watermark 未更新，不广播到下游。</li>
<li>上图 4 中，Task 接收到第三个分区新的 Watermark 6s，第三个分区的 Watermark 由 3s 更新为 6s，整个 Task 的 Watermark 对比更新为 4s，并广播到下游所有任务。</li>
</ul>
<h4 id="Watermark-的引入"><a href="#Watermark-的引入" class="headerlink" title="Watermark 的引入"></a>Watermark 的引入</h4><ul>
<li><p>引入 Watermark，需要设置时间语义。</p>
<ul>
<li>Event Time 的使用一定要指定数据源中的时间戳，否则程序无法知道事件的事件时间是什么 (数据源里的数据没有时间戳的话，就只能使用 Processing Time 了)。</li>
</ul>
</li>
<li><p>升序数据 (数据流的时间戳是单调递增的，也就是说没有乱序，即理想数据)，不需要延迟触发，可以只指定时间戳，使用 AscendingTimestampExtractor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3_Watermark1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置Event Time时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.方式一：理想数据，使用AscendingTimestampExtractor</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; watermarkStream = dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 因为sensorReading的时间戳是秒，要转换为毫秒</span></span><br><span class="line">                <span class="keyword">return</span> sensorReading.getTimestamp() * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 侧输出流</span></span><br><span class="line">        OutputTag&lt;SensorReading&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;late&quot;</span>) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.基于事件时间的开窗聚合，统计15秒内温度的最小值</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = watermarkStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">15</span>))</span><br><span class="line">                .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">                .sideOutputLateData(outputTag)</span><br><span class="line">                .minBy(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最小值</span></span><br><span class="line">        minTempStream.print(<span class="string">&quot;minTemp&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印迟到数据</span></span><br><span class="line">        minTempStream.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>乱序数据，需要设置延迟触发，使用 BoundedOutOfOrdernessTimestampExtractor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3_Watermark2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置Event Time时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.方式二：乱序数据，使用BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line">        <span class="comment">// 需要指定延时时长，此处设置为Time.seconds(2)，即2s，实际上生产时，按实际情况设置，可能更多是毫秒级别</span></span><br><span class="line">        <span class="comment">// import org.apache.flink.streaming.api.windowing.time.Time;</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; watermarkStream = dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 因为sensorReading的时间戳是秒，要转换为毫秒</span></span><br><span class="line">                <span class="keyword">return</span> sensorReading.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 侧输出流</span></span><br><span class="line">        OutputTag&lt;SensorReading&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;late&quot;</span>) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.基于事件时间的开窗聚合，统计15秒内温度的最小值</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = watermarkStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">15</span>))</span><br><span class="line">                .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">                .sideOutputLateData(outputTag)</span><br><span class="line">                .minBy(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最小值</span></span><br><span class="line">        minTempStream.print(<span class="string">&quot;minTemp&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印迟到数据</span></span><br><span class="line">        minTempStream.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Flink 最新版本中，上面两种方式已经被弃用，建议使用 <code>.assignTimestampsAndWatermarks(WatermarkStrategy)</code> 替代。</p>
</li>
<li><p>AscendingTimestampExtractor 和 BoundedOutOfOrdernessTimestampExtractor，本质上都是 TimestampAssigner 接口的实现类。</p>
</li>
<li><p>Flink 暴露了 TimestampAssigner 接口供我们实现，我们可以自定义如何从事件数据中抽取时间戳以及生成 Watermark。</p>
</li>
<li><p>TimestampAssigner 接口定义了抽取时间戳，以及生成 Watermark 的方法，有两种类型：AssignerWithPeriodicWatermarks 和 AssignerWithPunctuatedWatermarks。</p>
</li>
</ul>
<h5 id="AssignerWithPeriodicWatermarks"><a href="#AssignerWithPeriodicWatermarks" class="headerlink" title="AssignerWithPeriodicWatermarks"></a>AssignerWithPeriodicWatermarks</h5><ul>
<li><p>周期性的生成 Watermark，系统会周期性的将 Watermark 插入到流中 (Watermark 实际上也是一种特殊的事件)。</p>
</li>
<li><p>在设置时间语义时，Processing Time 语义下默认周期是 0 毫秒，Event Time 和 Ingestion Time 语义下默认周期是 200 毫秒，可以使用 <code>ExecutionConfig.setAutoWatermarkInterval()</code> 进行设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStreamTimeCharacteristic</span><span class="params">(TimeCharacteristic characteristic)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.timeCharacteristic = Preconditions.checkNotNull(characteristic);</span><br><span class="line">   <span class="keyword">if</span> (characteristic == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">      getConfig().setAutoWatermarkInterval(<span class="number">0</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      getConfig().setAutoWatermarkInterval(<span class="number">200</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔5秒生成一个Watermark</span></span><br><span class="line">env.getConfig().setAutoWatermarkInterval(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>产生 Watermark 的逻辑：每隔周期时间，Flink 会调用一次 AssignerWithPeriodicWatermarks 的 <code>getCurrentWatermark()</code>。如果方法返回一个时间戳大于之前 Watermark 的时间戳，新的 Watermark 会被插入到流中。如果方法返回的时间戳小于等于之前 Watermark 的时间戳，则不会产生新的 Watermark。这种检查模式，保证了 Watermark 是单调递增的。</p>
</li>
<li><p>前面升序和乱序使用的 AscendingTimestampExtractor 和 BoundedOutOfOrdernessTimestampExtractor，都是基于周期性 Watermark 的。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3_Watermark3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置Event Time时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.周期性的生成Watermark</span></span><br><span class="line">        env.getConfig().setAutoWatermarkInterval(<span class="number">5000</span>);<span class="comment">// 每隔5秒生成一个Watermark</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; watermarkStream = dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> AssignerWithPeriodicWatermarks&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Long bound = <span class="number">60</span> * <span class="number">1000L</span>;<span class="comment">// 延迟一分钟</span></span><br><span class="line">            <span class="keyword">private</span> Long maxTs = Long.MIN_VALUE;<span class="comment">// 当前最大时间戳</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回Watermark</span></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Watermark <span class="title">getCurrentWatermark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Watermark(maxTs - bound);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前到达数据的时间戳，与之前保存的最大时间戳对比，拿到当前数据到达后，最大的时间戳</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading sensorReading, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                maxTs = Math.max(maxTs, sensorReading.getTimestamp() * <span class="number">1000L</span>);</span><br><span class="line">                <span class="keyword">return</span> sensorReading.getTimestamp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 侧输出流</span></span><br><span class="line">        OutputTag&lt;SensorReading&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;late&quot;</span>) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.基于事件时间的开窗聚合，统计15秒内温度的最小值</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = watermarkStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">15</span>))</span><br><span class="line">                .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">                .sideOutputLateData(outputTag)</span><br><span class="line">                .minBy(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最小值</span></span><br><span class="line">        minTempStream.print(<span class="string">&quot;minTemp&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印迟到数据</span></span><br><span class="line">        minTempStream.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="AssignerWithPunctuatedWatermarks"><a href="#AssignerWithPunctuatedWatermarks" class="headerlink" title="AssignerWithPunctuatedWatermarks"></a>AssignerWithPunctuatedWatermarks</h5><ul>
<li><p>没有时间周期规律，间断式地生成 Watermark。</p>
</li>
<li><p>和周期性生成的方式不同，这种方式不是固定时间的，而是可以根据需要对每条数据进行筛选和处理。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3_Watermark4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置Event Time时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.间断性的生成Watermark，只给sensor_1的传感器的数据流插入Watermark</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; watermarkStream = dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> AssignerWithPunctuatedWatermarks&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Long bound = <span class="number">60</span> * <span class="number">1000L</span>;<span class="comment">// 延迟一分钟</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading sensorReading, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> sensorReading.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Watermark <span class="title">checkAndGetNextWatermark</span><span class="params">(SensorReading sensorReading, <span class="keyword">long</span> extractedTimestamp)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;sensor_1&quot;</span>.equals(sensorReading.getId())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Watermark(extractedTimestamp - bound);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 侧输出流</span></span><br><span class="line">        OutputTag&lt;SensorReading&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;late&quot;</span>) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.基于事件时间的开窗聚合，统计15秒内温度的最小值</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = watermarkStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">15</span>))</span><br><span class="line">                .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">                .sideOutputLateData(outputTag)</span><br><span class="line">                .minBy(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最小值</span></span><br><span class="line">        minTempStream.print(<span class="string">&quot;minTemp&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印迟到数据</span></span><br><span class="line">        minTempStream.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Watermark-的设定"><a href="#Watermark-的设定" class="headerlink" title="Watermark 的设定"></a>Watermark 的设定</h4><ul>
<li>在 Flink 中，Watermark 由应用程序开发人员生成，这通常需要对相应的领域有一定的了解。</li>
<li>如果 Watermark 设置的延迟太长，收到结果的速度可能就会很慢，解决办法是在 Watermark 到达之前输出一个近似结果。</li>
<li>如果 Watermark 设置的延迟太短，则可能收到错误结果，不过 Flink 处理迟到数据的机制 (侧输出流等) 可以解决这个问题。</li>
<li>Watermark 设置的位置离 Source 越近越好。</li>
</ul>
<h3 id="Evnet-Time-在-Window-中的测试说明"><a href="#Evnet-Time-在-Window-中的测试说明" class="headerlink" title="Evnet Time 在 Window 中的测试说明"></a>Evnet Time 在 Window 中的测试说明</h3><h4 id="流的并行度为-1"><a href="#流的并行度为-1" class="headerlink" title="流的并行度为 1"></a>流的并行度为 1</h4><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3_Watermark2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置Event Time时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        dataStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.乱序数据设置Watermark</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; watermarkStream = dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 因为sensorReading的时间戳是秒，要转换为毫秒</span></span><br><span class="line">                <span class="keyword">return</span> sensorReading.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 侧输出流</span></span><br><span class="line">        OutputTag&lt;SensorReading&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;late&quot;</span>) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.基于事件时间的开窗聚合，统计15秒内温度的最小值，并设置窗口延迟1分钟关闭，同时，窗口关闭后的迟到数据都输出到侧输出流</span></span><br><span class="line">        <span class="comment">// 这个延迟1分钟，是基于Event Time的，不是现实中的1分钟</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = watermarkStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">15</span>))</span><br><span class="line">                .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">                .sideOutputLateData(outputTag)</span><br><span class="line">                .minBy(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最小值</span></span><br><span class="line">        minTempStream.print(<span class="string">&quot;minTemp&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印迟到数据</span></span><br><span class="line">        minTempStream.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP<span class="literal">-OM8IACS</span>:/mnt/c/Users/XiSun<span class="variable">$</span> nc <span class="literal">-lk</span> <span class="number">7777</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">sensor_6,<span class="number">1547718201</span>,<span class="number">15.4</span></span><br><span class="line">sensor_7,<span class="number">1547718202</span>,<span class="number">6.7</span></span><br><span class="line">sensor_10,<span class="number">1547718205</span>,<span class="number">38.1</span></span><br><span class="line">sensor_1,<span class="number">1547718206</span>,<span class="number">36.3</span></span><br><span class="line">sensor_1,<span class="number">1547718210</span>,<span class="number">34.7</span></span><br><span class="line">sensor_1,<span class="number">1547718212</span>,<span class="number">37.1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">SensorReading</span>&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718206</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line">SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718210</span>, temperature=<span class="number">34.7</span>&#125;</span><br><span class="line">SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">37.1</span>&#125;</span><br><span class="line">minTemp&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">minTemp&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">minTemp&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">minTemp&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码分析：窗口起始点的确定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, TimeWindow&gt; <span class="title">timeWindow</span><span class="params">(Time size)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &#123;</span><br><span class="line">      <span class="keyword">return</span> window(TumblingProcessingTimeWindows.of(size));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Event Time语义</span></span><br><span class="line">      <span class="keyword">return</span> window(TumblingEventTimeWindows.of(size));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TumblingEventTimeWindows</span> <span class="keyword">extends</span> <span class="title">WindowAssigner</span>&lt;<span class="title">Object</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">TumblingEventTimeWindows</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Math.abs(offset) &gt;= size) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;TumblingEventTimeWindows parameters must satisfy abs(offset) &lt; size&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.size = size;</span><br><span class="line">      <span class="keyword">this</span>.offset = offset;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 此方法确定当前数据数据哪个窗口，即如何开窗</span></span><br><span class="line">   <span class="comment">// element：当前数据；timestamp：当前数据的时间戳</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Collection&lt;TimeWindow&gt; <span class="title">assignWindows</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, WindowAssignerContext context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (timestamp &gt; Long.MIN_VALUE) &#123;</span><br><span class="line">         <span class="comment">// Long.MIN_VALUE is currently assigned when no timestamp is present</span></span><br><span class="line">         <span class="comment">// 确定起始点</span></span><br><span class="line">         <span class="keyword">long</span> start = TimeWindow.getWindowStartWithOffset(timestamp, offset, size);</span><br><span class="line">         <span class="keyword">return</span> Collections.singletonList(<span class="keyword">new</span> TimeWindow(start, start + size));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Record has Long.MIN_VALUE timestamp (= no timestamp marker). &quot;</span> +</span><br><span class="line">               <span class="string">&quot;Is the time characteristic set to &#x27;ProcessingTime&#x27;, or did you forget to call &quot;</span> +</span><br><span class="line">               <span class="string">&quot;&#x27;DataStream.assignTimestampsAndWatermarks(...)&#x27;?&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Method to get the window start for a timestamp.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> timestamp epoch millisecond to get the window start.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> offset The offset which window start would be shifted by.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> windowSize The size of the generated windows.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> window start</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// timestamp：当前数据的时间戳；offset：偏移量，未设置时默认为0；windowSize：开窗大小</span></span><br><span class="line">   <span class="comment">// offset一般用于处理不同时区的偏移时间。标准时间是按伦敦所在时区，如果在北京时间东八区，获取的时间戳比标准时间早8个小时，</span></span><br><span class="line">   <span class="comment">// 如果想统计每天0点到0点的窗口，应该设置偏移量offset为-8h</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getWindowStartWithOffset</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">long</span> offset, <span class="keyword">long</span> windowSize：开窗大小)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// offset为0，此式化简为timestamp减去timestamp对windowSize取余，结果是windowSize的整数倍</span></span><br><span class="line">      <span class="keyword">return</span> timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由以上分析，第一个数据时间戳为 1547718199，开窗尺寸为 15s，则窗口起始点为：<code>1547718199 - 1547718199 % 15 = 1547718195</code>。而窗口尺寸为 15s，则后续窗口为：[195, 210)，[210, 225)，[225, 240)，以此类推。后续到达的每个数据，也会进入对应的数据桶中。</p>
<p><img src="/2021/04/25/flink/image-20210806151223965.png" alt="image-20210806151223965"></p>
</li>
<li><p>从图中可以看出，因为 Watermark 延时时长设置为 2s，所以当 <code>sensor_1,1547718212,37.1</code> 数据到达时，会触发 [195, 210) 窗口关闭 (因为设置了窗口延迟 1 分钟关闭，212 数据到达时，会触发窗口返回一个结果，之后 1 分钟之内，来一个新数据会返回一个结果，直到 272 数据到达时，窗口关闭，关闭之后的迟到数据，都会输出到侧输出流)，这也是第一个被触发关闭的窗口。然后根据 id 分组，输出四个结果。其中，sensor_1 对应的最小温度值为 <code>sensor_1,1547718199,35.8</code>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="流的并行度不为-1"><a href="#流的并行度不为-1" class="headerlink" title="流的并行度不为 1"></a>流的并行度不为 1</h4><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3_Watermark2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置Event Time时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        dataStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.乱序数据设置Watermark</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; watermarkStream = dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 因为sensorReading的时间戳是秒，要转换为毫秒</span></span><br><span class="line">                <span class="keyword">return</span> sensorReading.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 侧输出流</span></span><br><span class="line">        OutputTag&lt;SensorReading&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;late&quot;</span>) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.基于事件时间的开窗聚合，统计15秒内温度的最小值，并设置窗口延迟1分钟关闭，同时，窗口关闭后的迟到数据都输出到侧输出流</span></span><br><span class="line">        <span class="comment">// 这个延迟1分钟，是基于Event Time的，不是现实中的1分钟</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = watermarkStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">15</span>))</span><br><span class="line">                .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">                .sideOutputLateData(outputTag)</span><br><span class="line">                .minBy(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最小值</span></span><br><span class="line">        minTempStream.print(<span class="string">&quot;minTemp&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印迟到数据</span></span><br><span class="line">        minTempStream.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP<span class="literal">-OM8IACS</span>:/mnt/c/Users/Ziyoo<span class="variable">$</span> nc <span class="literal">-lk</span> <span class="number">7777</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">sensor_6,<span class="number">1547718201</span>,<span class="number">15.4</span></span><br><span class="line">sensor_7,<span class="number">1547718202</span>,<span class="number">6.7</span></span><br><span class="line">sensor_10,<span class="number">1547718205</span>,<span class="number">38.1</span></span><br><span class="line">sensor_1,<span class="number">1547718206</span>,<span class="number">36.3</span></span><br><span class="line">sensor_1,<span class="number">1547718210</span>,<span class="number">34.7</span></span><br><span class="line">sensor_1,<span class="number">1547718212</span>,<span class="number">33.1</span></span><br><span class="line">sensor_1,<span class="number">1547718212</span>,<span class="number">31.9</span></span><br><span class="line">sensor_1,<span class="number">1547718212</span>,<span class="number">30.8</span></span><br><span class="line">sensor_1,<span class="number">1547718212</span>,<span class="number">36.7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">2&gt; SensorReading</span>&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line"><span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line"><span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line"><span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718206</span>, temperature=<span class="number">36.3</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718210</span>, temperature=<span class="number">34.7</span>&#125;</span><br><span class="line"><span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">33.1</span>&#125;</span><br><span class="line"><span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">31.9</span>&#125;</span><br><span class="line"><span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">30.8</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">36.7</span>&#125;</span><br><span class="line">minTemp:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_7&#x27;</span>, timestamp=<span class="number">1547718202</span>, temperature=<span class="number">6.7</span>&#125;</span><br><span class="line">minTemp:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718205</span>, temperature=<span class="number">38.1</span>&#125;</span><br><span class="line">minTemp:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718201</span>, temperature=<span class="number">15.4</span>&#125;</span><br><span class="line">minTemp:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时，第一条数据是 199，如前面分析，开窗仍为 [195, 210)，[210, 225)，[225, 240)，依次类推。Scoket 文本流的并行度为 1，map 算子的并行度为 4。因此，每条数据会轮询的方式进入 map 算子。数据桶的分布情况如下：</p>
<p><img src="/2021/04/25/flink/image-20210809131823596.png" alt="image-20210809131823596"></p>
</li>
<li><p>由 Watermark 的传递可知，对于四个分区，只有每个分区的 Watermark 都更新为 210s 时，才会触发 [195, 210) 窗口的关闭，也就是最有一条数据 <code>sensor_1,1547718212,36.7</code> 到达时，触发输出计算结果。其中，sensor_1 对应的最小温度值为 <code>sensor_1,1547718199,35.8</code>。</p>
<ul>
<li><p>第一条数据 <code>sensor_1,1547718199,35.8</code> 到达时，第一个分区的 Watermark 是 197s，其他三个分区的 Watermark 是初始值，是一个很大的负值。此时，下游任务的 Watermark 取四个分区的最小值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.currentMaxTimestamp = Long.MIN_VALUE + <span class="keyword">this</span>.maxOutOfOrderness;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果继续输入数据，可得相应结果。从结果中可以看出，数据通过轮询方式进入四个并行的分区中，当四个分区的 Watermark 都更新为 225s 和 240s 时，才会触发 [210, 225) 和 [225, 240) 窗口输出结果。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sensor_10,<span class="number">1547718227</span>,<span class="number">3.1</span></span><br><span class="line">sensor_10,<span class="number">1547718227</span>,<span class="number">3.2</span></span><br><span class="line">sensor_10,<span class="number">1547718227</span>,<span class="number">3.3</span></span><br><span class="line">sensor_10,<span class="number">1547718227</span>,<span class="number">3.4</span></span><br><span class="line">sensor_10,<span class="number">1547718242</span>,<span class="number">4.1</span></span><br><span class="line">sensor_10,<span class="number">1547718242</span>,<span class="number">4.2</span></span><br><span class="line">sensor_10,<span class="number">1547718242</span>,<span class="number">4.3</span></span><br><span class="line">sensor_10,<span class="number">1547718242</span>,<span class="number">4.4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718227</span>, temperature=<span class="number">3.1</span>&#125;</span><br><span class="line"><span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718227</span>, temperature=<span class="number">3.2</span>&#125;</span><br><span class="line"><span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718227</span>, temperature=<span class="number">3.3</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718227</span>, temperature=<span class="number">3.4</span>&#125;</span><br><span class="line">minTemp:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718212</span>, temperature=<span class="number">30.8</span>&#125;</span><br><span class="line"><span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718242</span>, temperature=<span class="number">4.1</span>&#125;</span><br><span class="line"><span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718242</span>, temperature=<span class="number">4.2</span>&#125;</span><br><span class="line"><span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718242</span>, temperature=<span class="number">4.3</span>&#125;</span><br><span class="line"><span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718242</span>, temperature=<span class="number">4.4</span>&#125;</span><br><span class="line">minTemp:<span class="number">2</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718227</span>, temperature=<span class="number">3.1</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Flink-的状态管理"><a href="#Flink-的状态管理" class="headerlink" title="Flink 的状态管理"></a>Flink 的状态管理</h2><ul>
<li><p>流式计算分为无状态和有状态两种情况。无状态的计算观察每个独立事件，并根据最后一个事件输出结果。例如，流处理应用程序从传感器接收温度读数，并在温度超过 90 度时发出警告。有状态的计算则会基于多个事件输出结果。以下是一些例子：</p>
<ul>
<li>所有类型的窗口。例如，计算过去一小时的平均温度，就是有状态的计算。</li>
<li>所有用于复杂事件处理的状态机。例如，若在一分钟内收到两个相差 20 度以上的温度读数，则发出警告，这是有状态的计算。</li>
<li>流与流之间的所有关联操作，以及流与静态表或动态表之间的关联操作，都是有状态的计算。</li>
</ul>
</li>
<li><p>下图展示了无状态流处理和有状态流处理的主要区别。无状态流处理分别接收每条数据记录 (图中的黑条)，然后根据最新输入的数据生成输出数据 (白条)。有状态流处理会维护状态 (根据每条输入记录进行更新)，并基于最新输入的记录和当前的状态值生成输出记录 (灰条)。</p>
<p><img src="/2021/04/25/flink/image-20210809231831959.png" alt="image-20210809231831959"></p>
<ul>
<li>上图中输入数据由黑条表示。无状态流处理每次只转换一条输入记录，并且仅根据最新的输入记录输出结果 (白条)。有状态流处理维护所有已处理记录的状态值，并根据每条新输入的记录更新状态，因此输出记录 (灰条) 反映的是综合考虑多个事件之后的结果。</li>
</ul>
</li>
<li><p>尽管无状态的计算很重要，但是流处理对有状态的计算更感兴趣。事实上，正确地实现有状态的计算比实现无状态的计算难得多。旧的流处理系统并不支持有状态的计算，而新一代的流处理系统则将状态及其正确性视为重中之重。</p>
</li>
</ul>
<h3 id="Flink-中的状态"><a href="#Flink-中的状态" class="headerlink" title="Flink 中的状态"></a>Flink 中的状态</h3><p><img src="/2021/04/25/flink/image-20210806165916098.png" alt="image-20210806165916098"></p>
<ul>
<li>Flink 内置的很多算子，数据源 Source，数据存储 Sink 都是有状态的，流中的数据都是 buffer records，会保存一定的元素或者元数据。例如：ProcessWindowFunction 会缓存输入流的数据，ProcessFunction 会保存设置的定时器信息等等。</li>
<li>由一个任务维护，并且用来计算某个结果的所有数据，都属于这个任务的状态。</li>
<li>可以认为状态就是一个本地变量 (保存在内存中)，可以被任务的业务逻辑访问。</li>
<li>Flink 会进行状态管理，包括状态一致性、故障处理以及高效存储和访问，以便开发人员可以专注于应用程序的逻辑。</li>
<li>在 Flink 中，状态始终与特定算子相关联。</li>
<li>为了使运行时的 Flink 了解算子的状态，算子需要预先注册其状态。</li>
<li>总的说来，有两种类型的状态：<ul>
<li>算子状态 (Operator State)<ul>
<li>算子状态的作用范围限定为算子任务。</li>
<li>后面的算子任务，无法访问前面的算子任务的状态。</li>
</ul>
</li>
<li>键控状态 (Keyed State)<ul>
<li>根据输入数据流中定义的键 (key) 来维护和访问。</li>
<li>访问原则：只有当前 key 对应的数据，才能访问当前 key 对应的状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算子状态-Operator-State"><a href="#算子状态-Operator-State" class="headerlink" title="算子状态 (Operator State)"></a>算子状态 (Operator State)</h3><p><img src="/2021/04/25/flink/image-20210809154103959.png" alt="image-20210809154103959"></p>
<ul>
<li>算子状态的作用范围限定为算子任务，由同一并行任务所处理的所有数据都可以访问到相同的状态。<ul>
<li>到达当前算子的所有任务，共享算子状态，不论这些任务的 key 是否相同。注意：需要是同一个分区的。如果一个算子有多个并行分区，每一个分区的子任务，享有自己所在分区的算子状态。</li>
</ul>
</li>
<li>状态对于同一子任务而言是共享的。</li>
<li>算子状态不能由相同或不同算子的另一个子任务访问。</li>
</ul>
<h4 id="算子状态数据结构"><a href="#算子状态数据结构" class="headerlink" title="算子状态数据结构"></a>算子状态数据结构</h4><ul>
<li><p>列表状态 (List state)</p>
<ul>
<li>将状态表示为一组数据的列表。</li>
<li>列表状态方便于后续算子任务可能存在的并行度的调整。</li>
</ul>
</li>
<li><p>联合列表状态 (Union list state)</p>
<ul>
<li><p>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保存点 (savepoint) 启动应用程序时如何恢复。</p>
<p><img src="/2021/04/25/flink/image-20210809163414850.png" alt="image-20210809163414850"></p>
<p><img src="/2021/04/25/flink/image-20210809163742517.png" alt="image-20210809163742517"></p>
</li>
</ul>
</li>
<li><p>广播状态 (Broadcast state)</p>
<ul>
<li>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态。比如：算子的状态是某个配置项，则其对每项任务都是相同的状态。</li>
</ul>
</li>
</ul>
<h4 id="算子状态的使用"><a href="#算子状态的使用" class="headerlink" title="算子状态的使用"></a>算子状态的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTest1_OperatorState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.定义一个有状态的map操作，统计当前分区数据个数</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; resultStream = dataStream.map(<span class="keyword">new</span> MyCountMapper());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义MapFunction</span></span><br><span class="line">    <span class="comment">// ListCheckpointed&lt;Integer&gt;：列表状态，存放当前要保存的算子状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCountMapper</span> <span class="keyword">implements</span> <span class="title">MapFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Integer</span>&gt;, <span class="title">ListCheckpointed</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个本地变量，作为算子状态</span></span><br><span class="line">        <span class="comment">// 算子状态，从使用上来看，就相当于一个本地变量</span></span><br><span class="line">        <span class="keyword">private</span> Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">map</span><span class="params">(SensorReading value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存状态使用的方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">snapshotState</span><span class="params">(<span class="keyword">long</span> checkpointId, <span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singletonList(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复状态使用的方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreState</span><span class="params">(List&lt;Integer&gt; state)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 可能有多个分区，每个分区都有自己的算子状态</span></span><br><span class="line">            <span class="keyword">for</span> (Integer num : state) &#123;</span><br><span class="line">                count += num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="键控状态-Keyed-State"><a href="#键控状态-Keyed-State" class="headerlink" title="键控状态 (Keyed State)"></a>键控状态 (Keyed State)</h3><p><img src="/2021/04/25/flink/image-20210809170614289.png" alt="image-20210809170614289"></p>
<ul>
<li><p>键控状态是根据输入数据流中定义的键 (key) 来维护和访问的。</p>
</li>
<li><p>Flink 为每个 key 维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个 key 对应的状态。</p>
</li>
<li><p>当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的 key。因此，具有相同 key 的所有数据都会访问相同的状态。</p>
<ul>
<li>不同 key 的数据，即使分配在同一个 Task 内，也会按 key 保存不同的状态，访问时，不同的 key 之间不共享状态。</li>
</ul>
</li>
<li><p>键控状态很类似于一个分布式的 key-value map 数据结构，只能用于 KeyedStream (keyBy 算子处理之后)。</p>
</li>
</ul>
<h4 id="键控状态数据结构"><a href="#键控状态数据结构" class="headerlink" title="键控状态数据结构"></a>键控状态数据结构</h4><ul>
<li>值状态 (Value state)<ul>
<li><code>ValueState&lt;T&gt;</code>：将状态表示为单个的值，值的类型为 T。<ul>
<li><code>ValueState.value()</code>：get 操作。</li>
<li><code>ValueState.update(T value)</code>：set 操作。</li>
<li><code>ValueState.clear()</code>：清空。</li>
</ul>
</li>
</ul>
</li>
<li>列表状态 (List state)<ul>
<li><code>ListState&lt;T&gt;</code>：将状态表示为一组数据的列表，列表里的元素的数据类型为 T。<ul>
<li><code>ListState.add(T value)</code></li>
<li><code>ListState.addAll(List&lt;T&gt; values)</code></li>
<li><code>ListState.get()</code>：返回 <code>Iterable&lt;T&gt;</code>。</li>
<li><code>ListState.update(List&lt;T&gt; values)</code></li>
<li><code>ListState.clear()</code>：清空。</li>
</ul>
</li>
</ul>
</li>
<li>映射状态 (Map state)<ul>
<li><code>MapState&lt;K, V&gt;</code>：将状态表示为一组 Key-Value 对。<ul>
<li><code>MapState.get(UK key)</code></li>
<li><code>MapState.put(UK key, UV value)</code></li>
<li><code>MapState.contains(UK key)</code></li>
<li><code>MapState.remove(UK key)</code></li>
<li><code>MapState.clear()</code>：清空。</li>
</ul>
</li>
</ul>
</li>
<li>聚合状态 (Reducing state &amp; Aggregating state)<ul>
<li><code>ReducingState&lt;T&gt;</code> 或 <code>AggregatingState&lt;I, O&gt;</code>：将状态表示为一个用于聚合操作的列表。</li>
<li><code>State.clear()</code>：清空。</li>
</ul>
</li>
</ul>
<h4 id="键控状态的使用"><a href="#键控状态的使用" class="headerlink" title="键控状态的使用"></a>键控状态的使用</h4><ul>
<li><p>声明一个键控状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyCountState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Integer&gt;(<span class="string">&quot;key-count&quot;</span>, Integer.class, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>需要使用运行时上下文，意味着键控状态的使用不同于算子状态，必须要在富函数中实现。</li>
<li>在 <code>open()</code> 中赋值 state 变量。</li>
<li>通过 RuntimeContext 注册 StateDescriptor。StateDescriptor 以状态 state 的名字和存储的数据类型为参数。state 的名字不能重复。</li>
</ul>
</li>
<li><p>读取状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer count = keyCountState.value();</span><br></pre></td></tr></table></figure>
</li>
<li><p>对状态赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyCountState.update(count);</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTest2_KeyedState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.定义一个有状态的map操作，统计当前分区数据个数</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; resultStream = dataStream</span><br><span class="line">                .keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .map(<span class="keyword">new</span> MyKeyCountMapper());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义RichMapFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKeyCountMapper</span> <span class="keyword">extends</span> <span class="title">RichMapFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 值状态</span></span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Integer&gt; keyCountState;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其它类型状态的声明</span></span><br><span class="line">        <span class="keyword">private</span> ListState&lt;String&gt; myListState;<span class="comment">// 列表状态</span></span><br><span class="line">        <span class="keyword">private</span> MapState&lt;String, Double&gt; myMapState;<span class="comment">// 映射状态</span></span><br><span class="line">        <span class="keyword">private</span> ReducingState&lt;SensorReading&gt; myReducingState;<span class="comment">// 聚合状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须要在open方法里赋值，不同状态的名称不能相同</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 值状态的赋值，此处初始值为0，如果不设置，则是null，在使用时需要先判断是否为null</span></span><br><span class="line">            <span class="comment">// 但此方法已被弃用，推荐不设初始值，在使用时手动判断并赋值</span></span><br><span class="line">            keyCountState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Integer&gt;(<span class="string">&quot;key-count&quot;</span>, Integer.class, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其它类型状态的赋值</span></span><br><span class="line">            myListState = getRuntimeContext().getListState(<span class="keyword">new</span> ListStateDescriptor&lt;String&gt;(<span class="string">&quot;my-list&quot;</span>, String.class));</span><br><span class="line">            myMapState = getRuntimeContext().getMapState(<span class="keyword">new</span> MapStateDescriptor&lt;String, Double&gt;(<span class="string">&quot;my-map&quot;</span>, String.class, Double.class));</span><br><span class="line">            myReducingState = getRuntimeContext().getReducingState(<span class="keyword">new</span> ReducingStateDescriptor&lt;SensorReading&gt;(<span class="string">&quot;my-reduce&quot;</span>, <span class="keyword">new</span> ReduceFunction&lt;SensorReading&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> SensorReading <span class="title">reduce</span><span class="params">(SensorReading value1, SensorReading value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 按照具体需求，返回对应的对象</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, SensorReading.class));<span class="comment">// 聚合状态需要传入一个聚合函数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">map</span><span class="params">(SensorReading value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 值状态的使用，先取值，再赋值</span></span><br><span class="line">            Integer count = keyCountState.value();</span><br><span class="line">            count++;</span><br><span class="line">            keyCountState.update(count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其它状态API调用</span></span><br><span class="line">            <span class="comment">// list state --- List的常规操作</span></span><br><span class="line">            Iterable&lt;String&gt; lists = myListState.get();<span class="comment">// 取</span></span><br><span class="line">            <span class="keyword">for</span> (String str : lists) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">            myListState.add(<span class="string">&quot;hello&quot;</span>);<span class="comment">// 一个一个追加，也可以addAll()添加一个List</span></span><br><span class="line">            myListState.clear();<span class="comment">// 清空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// map state --- Map的常规操作</span></span><br><span class="line">            myMapState.get(<span class="string">&quot;1&quot;</span>);<span class="comment">// 取</span></span><br><span class="line">            myMapState.put(<span class="string">&quot;2&quot;</span>, <span class="number">12.3</span>);<span class="comment">// 存</span></span><br><span class="line">            myMapState.remove(<span class="string">&quot;2&quot;</span>);<span class="comment">// 移除一个</span></span><br><span class="line">            myMapState.clear();<span class="comment">// 清空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// reducing state</span></span><br><span class="line">            SensorReading sensorReading = myReducingState.get();<span class="comment">// 取</span></span><br><span class="line">            myReducingState.add(value);<span class="comment">// 会调用聚合状态声明的聚合函数来处理传入的值</span></span><br><span class="line">            myReducingState.clear();<span class="comment">// 清空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例：检测传感器的温度值，如果连续的两个温度差值超过 10 度，就输出报警。</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTest3_KeyedStateApplicationCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.定义一个flatmap操作，检测温度跳变，输出报警</span></span><br><span class="line">        <span class="comment">// map是一对一，实际情况时，可能有null数据，输出结果可能不同于输入数据，因此选择flatmap</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, Double, Double&gt;&gt; resultStream = dataStream</span><br><span class="line">                .keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> TempChangeWarning(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        resultStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义函数类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TempChangeWarning</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">SensorReading</span>, <span class="title">Tuple3</span>&lt;<span class="title">String</span>, <span class="title">Double</span>, <span class="title">Double</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 温度跳变阈值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> threshold;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TempChangeWarning</span><span class="params">(<span class="keyword">double</span> threshold)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义值状态，保存上一次的温度值</span></span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Double&gt; lastTempState;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 赋值，不定义初始值，使用时判断</span></span><br><span class="line">            lastTempState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Double&gt;(<span class="string">&quot;last-temp-state&quot;</span>, Double.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(SensorReading sensorReading, Collector&lt;Tuple3&lt;String, Double, Double&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Double lastTempValue = lastTempState.value();</span><br><span class="line">            <span class="comment">// 如果状态不为null，那么就判断两次温度差值</span></span><br><span class="line">            <span class="keyword">if</span> (lastTempValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前温度与上一次温度的差值</span></span><br><span class="line">                <span class="keyword">double</span> diff = Math.abs(sensorReading.getTemperature() - lastTempValue);</span><br><span class="line">                <span class="keyword">if</span> (diff &gt;= threshold) &#123;</span><br><span class="line">                    <span class="comment">// 输出报警信息</span></span><br><span class="line">                    out.collect(<span class="keyword">new</span> Tuple3&lt;&gt;(sensorReading.getId(), lastTempValue, sensorReading.getTemperature()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新状态为当前温度</span></span><br><span class="line">            lastTempState.update(sensorReading.getTemperature());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            lastTempState.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数输入：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP<span class="literal">-OM8IACS</span>:/mnt/c/Users/Ziyoo<span class="variable">$</span> nc <span class="literal">-lk</span> <span class="number">7777</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">36.3</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">37.9</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">48</span></span><br><span class="line">sensor_6,<span class="number">1547718201</span>,<span class="number">15.4</span></span><br><span class="line">sensor_6,<span class="number">1547718201</span>,<span class="number">35</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">36.9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">3&gt; <span class="params">(sensor_1,<span class="number">37.9</span>,<span class="number">48.0</span>)</span></span></span><br><span class="line"><span class="function">3&gt; <span class="params">(sensor_6,<span class="number">15.4</span>,<span class="number">35.0</span>)</span></span></span><br><span class="line"><span class="function">3&gt; <span class="params">(sensor_1,<span class="number">48.0</span>,<span class="number">36.9</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入 <code>sensor_1,1547718199,48</code> 时触发 sensor_1 报警，输入 <code>sensor_6,1547718201,35</code> 时触发 sensor_6 报警，输入 <code>sensor_1,1547718199,36.9</code> 时再次触发 sensor_1 报警。</p>
</li>
</ul>
</li>
</ul>
<h3 id="状态后端-State-Backends"><a href="#状态后端-State-Backends" class="headerlink" title="状态后端 (State Backends)"></a>状态后端 (State Backends)</h3><ul>
<li>每传入一条数据，有状态的算子任务都会读取和更新状态。</li>
<li>由于有效的状态访问对于处理数据的低延迟至关重要，因此每个并行任务都会在本地维护其状态，以确保快速的状态访问。</li>
<li>状态的存储、访问以及维护，由一个可插入的组件决定，这个组件就叫做状态后端 (state backend)。</li>
<li>状态后端主要负责两件事：本地的状态管理，以及将检查点 (Checkpoint) 状态写入远程存储。</li>
</ul>
<h4 id="选择一个状态后端"><a href="#选择一个状态后端" class="headerlink" title="选择一个状态后端"></a>选择一个状态后端</h4><ul>
<li><p>MemoryStateBackend</p>
<ul>
<li>内存级的状态后端，会将键控状态作为内存中的对象进行管理，将它们存储在 TaskManager 的 JVM 堆上，而将 Checkpoint 存储在 JobManager 的内存中。</li>
<li>特点：快速、低延迟，但不稳定。</li>
</ul>
</li>
<li><p>FsStateBackend</p>
<ul>
<li>将 Checkpoint 存到远程的持久化文件系统 (FileSystem) 上，而对于本地状态，跟 MemoryStateBackend 一样，也会存储在 TaskManager 的 JVM 堆上。</li>
<li>同时拥有内存级的本地访问速度，和更好的容错保证。</li>
</ul>
</li>
<li><p>RocksDBStateBackend</p>
<ul>
<li><p>将所有状态序列化后，存入本地的 RocksDB 中存储。</p>
</li>
<li><p>RocksDB 的支持并不直接包含在 Flink 中，需要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="状态后端的使用配置"><a href="#状态后端的使用配置" class="headerlink" title="状态后端的使用配置"></a>状态后端的使用配置</h4><ul>
<li><p>在 conf/flink-conf.yaml 配置文件中：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#==============================================================================</span></span><br><span class="line"><span class="comment"># Fault tolerance and checkpointing</span></span><br><span class="line"><span class="comment">#==============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The backend that will be used to store operator state checkpoints if</span></span><br><span class="line"><span class="comment"># checkpointing is enabled.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Supported backends are &#x27;jobmanager&#x27;, &#x27;filesystem&#x27;, &#x27;rocksdb&#x27;, or the</span></span><br><span class="line"><span class="comment"># &lt;class-name-of-factory&gt;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># state.backend: filesystem</span></span><br><span class="line"><span class="comment"># 默认使用FsStateBackend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory for checkpoints filesystem, when using any of the default bundled</span></span><br><span class="line"><span class="comment"># state backends.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">state.checkpoints.dir:</span> <span class="string">hdfs://mghadoop:8020/flink-checkpoints</span></span><br><span class="line"><span class="comment"># checkpoints保存路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default target directory for savepoints, optional.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># state.savepoints.dir: hdfs://namenode-host:port/flink-checkpoints</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Flag to enable/disable incremental checkpoints for backends that</span></span><br><span class="line"><span class="comment"># support incremental checkpoints (like the RocksDB state backend). </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># state.backend.incremental: false</span></span><br><span class="line"><span class="comment"># 是否增量化的进行checkpoints保存，默认false，比如FsStateBackend不容易支持此操作，但RocksDB可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The failover strategy, i.e., how the job computation recovers from task failures.</span></span><br><span class="line"><span class="comment"># Only restart tasks that may have been affected by the task failure, which typically includes</span></span><br><span class="line"><span class="comment"># downstream tasks and potentially upstream tasks if their produced data is no longer available for consumption.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobmanager.execution.failover-strategy:</span> <span class="string">region</span></span><br><span class="line"><span class="comment"># 区域重启的策略，即需要重启时，不是把所有的任务全部停掉再重启，而是只对受影响的区域执行重启，其他区域正常执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在代码中对每个任务配置：</p>
<ul>
<li><p>MemoryStateBackend</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.setStateBackend(<span class="keyword">new</span> MemoryStateBackend());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MemoryStateBackend 的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryStateBackend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, DEFAULT_MAX_STATE_SIZE, TernaryBoolean.UNDEFINED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asynchronousSnapshots：是否开启异步快照，即执行快照时，不影响任务的继续操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryStateBackend</span><span class="params">(<span class="keyword">boolean</span> asynchronousSnapshots)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, DEFAULT_MAX_STATE_SIZE, TernaryBoolean.fromBoolean(asynchronousSnapshots));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>FsStateBackend</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要传入一个checkpoints保存路径对应的uri</span></span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> FsStateBackend(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>RocksDBStateBackend</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 需要传入一个checkpoints保存路径对应的uri</span></span><br><span class="line">    env.setStateBackend(<span class="keyword">new</span> RocksDBStateBackend(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException exception) &#123;</span><br><span class="line">    exception.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>RocksDBStateBackend 的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RocksDBStateBackend</span><span class="params">(String checkpointDataUri)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">new</span> Path(checkpointDataUri)).toUri());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enableIncrementalCheckpointing：是否开启增量化的进行checkpoints保存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RocksDBStateBackend</span><span class="params">(String checkpointDataUri, <span class="keyword">boolean</span> enableIncrementalCheckpointing)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">new</span> Path(checkpointDataUri)).toUri(), enableIncrementalCheckpointing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Flink-的容错机制"><a href="#Flink-的容错机制" class="headerlink" title="Flink 的容错机制"></a>Flink 的容错机制</h2><h3 id="一致性检查点-Checkpoint"><a href="#一致性检查点-Checkpoint" class="headerlink" title="一致性检查点 (Checkpoint)"></a>一致性检查点 (Checkpoint)</h3><p><img src="/2021/04/25/flink/image-20210810161328004.png" alt="image-20210810161328004"></p>
<ul>
<li>Flink 故障恢复机制的核心，就是应用状态的一致性检查点。</li>
<li>有状态流应用的一致检查点，其实就是所有任务的状态，在某个时间点的一份拷贝 (一份快照)；这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候。</li>
</ul>
<h3 id="从检查点恢复状态"><a href="#从检查点恢复状态" class="headerlink" title="从检查点恢复状态"></a>从检查点恢复状态</h3><ul>
<li><p>在执行流应用程序期间，Flink 会定期保存状态的一致检查点。</p>
</li>
<li><p>如果发生故障， Flink 将会使用最近的检查点来一致恢复应用程序的状态，并重新启动处理流程。</p>
<p><img src="/2021/04/25/flink/image-20210810162207412.png" alt="image-20210810162207412"></p>
</li>
<li><p>遇到故障之后，第一步就是重启应用：</p>
<p><img src="/2021/04/25/flink/image-20210810162427408.png" alt="image-20210810162427408"></p>
</li>
<li><p>第二步是从 Checkpoint 中读取状态，将状态重置：</p>
<p><img src="/2021/04/25/flink/image-20210810162656149.png" alt="image-20210810162656149"></p>
<ul>
<li>从检查点重新启动应用程序后，其内部状态与检查点完成时的状态完全相同。</li>
</ul>
</li>
<li><p>第三步，开始消费并处理检查点到发生故障之间的所有数据：</p>
<p><img src="/2021/04/25/flink/image-20210810163340480.png" alt="image-20210810163340480"></p>
</li>
<li><p>这种检查点的保存和恢复机制可以为应用程序状态提供 “精确一次” (exactly-once) 的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流就都会被重置到检查点完成时的位置。</p>
</li>
</ul>
<h3 id="检查点的实现算法"><a href="#检查点的实现算法" class="headerlink" title="检查点的实现算法"></a>检查点的实现算法</h3><ul>
<li>一种简单的想法：<ul>
<li>暂停应用，保存状态到检查点，再重新恢复应用。</li>
</ul>
</li>
<li>Flink 的改进实现：<ul>
<li>基于 Chandy-Lamport 算法的分布式快照。</li>
<li>将检查点的保存和数据处理分离开，不暂停整个应用。</li>
</ul>
</li>
</ul>
<h3 id="Flink-检查点算法"><a href="#Flink-检查点算法" class="headerlink" title="Flink 检查点算法"></a>Flink 检查点算法</h3><ul>
<li><p>Flink 检查点算法的正式名称是异步分界线快照 (asynchronous barrier snapshotting)。</p>
</li>
<li><p>检查点分界线 (Checkpoint Barrier)</p>
<ul>
<li>Flink 的检查点算法用到了一种称为分界线 (barrier) 的特殊数据形式，用来把一条流上数据按照不同的检查点分开。</li>
<li>分界线之前到来的数据导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中。</li>
</ul>
</li>
<li><p>假设现在是一个有两个输入流的应用程序，用并行的两个 Source 任务来读取。</p>
<p><img src="/2021/04/25/flink/image-20210810171057951.png" alt="image-20210810171057951"></p>
</li>
<li><p>首先，JobManager 会向每个 Source 任务同时发送一条带有新检查点 ID 的消息，通过这种方式来启动检查点。</p>
<p><img src="/2021/04/25/flink/image-20210810172052882.png" alt="image-20210810172052882"></p>
</li>
<li><p>然后，每个数据源将它们的状态写入检查点，并向后续任务广播发出一个检查点 barrier。状态后端在状态存入检查点之后，会返回通知给 Source 任务，Source 任务就会向 JobManager 确认检查点完成。</p>
<p><img src="/2021/04/25/flink/image-20210810173003834.png" alt="                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "></p>
</li>
<li><p>之后，每个 Source 发送的 barrier 向下游传递，sum 任务 (下游任务) 会等待所有输入分区的 barrier 到达，这叫分界线对齐。</p>
<p><img src="/2021/04/25/flink/image-20210810214432904.png" alt="image-20210810214432904"></p>
<ul>
<li>对于 barrier 已经到达的分区，继续到达的数据会被缓存。</li>
<li>而 barrier 尚未到达的分区，数据会被正常处理。</li>
</ul>
</li>
<li><p>当收到所有输入分区的 barrier 时，任务就将其状态保存到状态后端的检查点中，然后将 barrier 继续向下游转发。</p>
<p><img src="/2021/04/25/flink/image-20210810220612064.png" alt="image-20210810220612064"></p>
</li>
<li><p>向下游转发检查点 barrier 后，任务继续正常的数据处理。</p>
<p><img src="/2021/04/25/flink/image-20210810231203921.png" alt="image-20210810231203921"></p>
</li>
<li><p>Sink 任务收到 barrier 后，也向 JobManager 确认状态保存到 checkpoint 完毕。</p>
<p><img src="/2021/04/25/flink/image-20210810231535649.png" alt="image-20210810231535649"></p>
</li>
<li><p>至此，当所有任务都确认已成功将状态保存到检查点时，当前这个检查点就真正完成了。</p>
</li>
<li><p>如果检查点操作失败，Flink 可以丢弃该检查点并继续正常执行，因为之后的某一个检查点可能会成功。虽然恢复时间可能更长，但是对于状态的保证依旧很有力。只有在一系列连续的检查点操作失败之后，Flink 才会抛出错误，因为这通常预示着发生了严重且持久的错误。</p>
</li>
</ul>
<h3 id="保存点-Savepoints"><a href="#保存点-Savepoints" class="headerlink" title="保存点 (Savepoints)"></a>保存点 (Savepoints)</h3><ul>
<li>Flink 还提供了可以自定义的镜像保存功能，就是保存点 (savepoints)。</li>
<li>原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为就是具有一些额外元数据的检查点。<ul>
<li>检查点可以看作是自动存盘，保存点可以看作是手动存盘。</li>
</ul>
</li>
<li>Flink不会自动创建保存点，因此用户 (或者外部调度程序) 必须明确地触发创建操作。</li>
<li>保存点是一个强大的功能。除了故障恢复外，保存点可以用于：有计划的手动备份，更新应用程序，版本迁移，暂停和重启应用，等等。</li>
</ul>
<h3 id="检查点的使用配置"><a href="#检查点的使用配置" class="headerlink" title="检查点的使用配置"></a>检查点的使用配置</h3><ul>
<li><p>检查点默认情况下关闭，需要手动设置才能开启使用。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTest4_FaultTolerance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.检查点的配置</span></span><br><span class="line">        <span class="comment">// 开启检查点，参数表示每隔300毫秒触发一次Checkpoint，默认为500毫秒</span></span><br><span class="line">        env.enableCheckpointing(<span class="number">300L</span>);</span><br><span class="line">        <span class="comment">// 状态一致性的选择</span></span><br><span class="line">        env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line">        <span class="comment">// 执行Checkpoint的超时时间，60s内完成，否则丢掉此次的Checkpoint</span></span><br><span class="line">        env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000L</span>);</span><br><span class="line">        <span class="comment">// 最大同时执行Checkpoint的数量，是指前一个Checkpoint还未执行结束，下一个Checkpoint已经开始执行，</span></span><br><span class="line">        <span class="comment">// 默认为1，即只能前一个Checkpoint执行完成后，下一个Checkpoint才能开始</span></span><br><span class="line">        env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 两个Checkpoint之间最小的时间间隔，即前一个Checkpoint执行完成时间，与下一个Checkpoint执行开始时间之间的最小间隔</span></span><br><span class="line">        <span class="comment">// 可以防止Checkpoint处理过慢，整个集群都在处理Checkpoint，而没有时间处理真正的数据</span></span><br><span class="line">        <span class="comment">// 设置最小时间间隔后，则最大同时执行Checkpoint的数量就只能为1</span></span><br><span class="line">        env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">100L</span>);</span><br><span class="line">        <span class="comment">// 倾向于使用Checkpoint进行故障回复，即使存在一个更近的Savepoint，默认false</span></span><br><span class="line">        env.getCheckpointConfig().setPreferCheckpointForRecovery(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 允许Checkpoint失败的次数，默认为0，即Checkpoint执行时如果失败了，会认为是整个任务失败，需要重启</span></span><br><span class="line">        env.getCheckpointConfig().setTolerableCheckpointFailureNumber(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.重启策略的配置</span></span><br><span class="line">        <span class="comment">// env.setRestartStrategy(RestartStrategies.noRestart());// 不重启，若工作失败则直接宣告失败，不启用Checkpoint时的策略</span></span><br><span class="line">        <span class="comment">// env.setRestartStrategy(RestartStrategies.fallBackRestart());// 回滚重启，将重启的策略交给上级的资源管理平台</span></span><br><span class="line">        <span class="comment">// 固定延迟重启，每隔30s重启一次，尝试3次，超过之后，工作宣告失败。</span></span><br><span class="line">        <span class="comment">// 启用Checkpoint后，这是默认的重启策略，尝试重启次数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="comment">// env.setRestartStrategy(RestartStrategies.fixedDelayRestart(3, 30000L));</span></span><br><span class="line">        <span class="comment">// 失败率重启，常用，任务失败后重启工作，如果10min内失败次数超过3次，则工作宣告失败，连续两次重启尝试中间隔1min</span></span><br><span class="line">        env.setRestartStrategy(RestartStrategies.failureRateRestart(<span class="number">3</span>, Time.minutes(<span class="number">10</span>), Time.minutes(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.打印</span></span><br><span class="line">        dataStream.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Flink-的状态一致性"><a href="#Flink-的状态一致性" class="headerlink" title="Flink 的状态一致性"></a>Flink 的状态一致性</h2><h3 id="状态一致性的概念"><a href="#状态一致性的概念" class="headerlink" title="状态一致性的概念"></a>状态一致性的概念</h3><p><img src="/2021/04/25/flink/image-20210812151826568.png" alt="image-20210812151826568"></p>
<ul>
<li>当在分布式系统中引入状态时，自然也引入了一致性问题。一致性实际上是 “正确性级别” 的另一种说法，也就是说在成功处理故障并恢复之后得到的结果，与没有发生任何故障时得到的结果相比，前者到底有多正确？举例来说，假设要对最近一小时登录的用户计数。在系统经历故障之后，计数结果是多少？如果有偏差，是有漏掉的计数还是重复计数？</li>
<li>有状态的流处理，内部每个算子任务都可以有自己的状态</li>
<li>对于流处理器内部来说，所谓的状态一致性，其实就是我们所说的计算结果要保证准确。</li>
<li>一条数据不应该丢失，也不应该重复计算。</li>
<li>在遇到故障时可以恢复状态，恢复以后的重新计算，结果应该也是完全正确的。</li>
</ul>
<h3 id="状态一致性的级别"><a href="#状态一致性的级别" class="headerlink" title="状态一致性的级别"></a>状态一致性的级别</h3><ul>
<li>在流处理中，一致性可以分为 3 个级别。</li>
<li>AT-MOST-ONCE：最多一次。<ul>
<li>当任务故障时，最简单的做法是什么都不干，既不恢复丢失的状态，也不处理丢失的数据。at-most-once 语义的含义是最多处理一次事件。</li>
</ul>
</li>
<li>AT-LEAST-ONCE：至少一次。<ul>
<li>在大多数的真实应用场景，我们希望不丢失事件。这种类型的保障称为 at-least-once，意思是所有的事件都得到了处理，但一些事件可能被处理多次。这表示计算结果可能大于正确值，但绝不会小于正确值。</li>
</ul>
</li>
<li>EXACTLY-ONCE：精确一次。<ul>
<li>恰好处理一次是最严格的保证，也是最难实现的。恰好处理一次语义不仅仅意味着没有事件丢失，还意味着针对每一个数据，内部状态仅仅更新一次。</li>
</ul>
</li>
<li>曾经，at-least-once 非常流行。第一代流处理器 (如 Storm 和 Samza) 刚问世时，只保证 at-least-once，原因有二：<ul>
<li>保证 exactly-once 的系统实现起来更复杂。这在基础架构层 (决定什么代表正确，以及 exactly-once 的范围是什么) 和实现层都很有挑战性。</li>
<li>流处理系统的早期用户愿意接受框架的局限性，并在应用层想办法弥补 (例如使应用程序具有幂等性，或者用批量计算层再做一遍计算)。</li>
</ul>
</li>
<li>最先保证 exactly-once 的系统 (Storm Trident 和 Spark Streaming)，在性能和表现力这两个方面付出了很大的代价。为了保证 exactly-once，这些系统无法单独地对每条记录运用应用逻辑，而是同时处理多条 (一批) 记录，保证对每一批的处理要么全部成功，要么全部失败。这就导致在得到结果前，必须等待一批记录处理结束。因此，用户经常不得不使用两个流处理框架 (一个用来保证 exactly-once，另一个用来对每个元素做低延迟处理)，结果使基础设施更加复杂。曾经，用户不得不在保证 exactly-once 与获得低延迟和效率之间权衡利弊。而 Flink 避免了这种权衡。</li>
<li>Flink 的一个重大价值在于， 它既保证了 exactly-once ，也具有低延迟和高吞吐力的处理能力。从根本上说，Flink 通过使自身满足所有需求来避免权衡，它是业界的一次意义重大的技术飞跃。尽管这在外行看来很神奇，但是一旦了解，就会恍然大悟。</li>
</ul>
<h3 id="exactly-once-的实现"><a href="#exactly-once-的实现" class="headerlink" title="exactly-once 的实现"></a>exactly-once 的实现</h3><p><img src="/2021/04/25/flink/image-20210812173118769.png" alt="image-20210812173118769"></p>
<ul>
<li>Flink 使用了一种轻量级快照机制 —— 检查点 (Checkpoint) 来保证 exactly-once 语义。</li>
<li>有状态流应用的一致检查点，其实就是：所有任务的状态，在某个时间点的一份拷贝 (一份快照)。而这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候。</li>
<li>应用状态的一致检查点，是 Flink 故障恢复机制的核心。</li>
</ul>
<h3 id="端到端-end-to-end-状态一致性"><a href="#端到端-end-to-end-状态一致性" class="headerlink" title="端到端 (end-to-end) 状态一致性"></a>端到端 (end-to-end) 状态一致性</h3><ul>
<li>目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在 Flink 流处理器内部保证的；而在真实应用中，流处理应用除了流处理器以外还包含了数据源 (例如 Kafka) 和输出到持久化系统。</li>
<li>端到端的一致性保证，意味着结果的正确性贯穿了整个流处理应用的始终；每一个组件都需要保证它自己的一致性。</li>
<li>整个端到端的一致性级别取决于所有组件中一致性最弱的组件。</li>
</ul>
<h3 id="端到端-exactly-once"><a href="#端到端-exactly-once" class="headerlink" title="端到端 exactly-once"></a>端到端 exactly-once</h3><ul>
<li>内部保证 —— Checkpoint 机制。</li>
<li>Source 端 —— 可重设数据的读取位置。</li>
<li>Sink 端 —— 从故障恢复时，数据不会重复写入外部系统。有两种实现方式：<ul>
<li>幂等写入</li>
<li>事务写入</li>
</ul>
</li>
</ul>
<h4 id="幂等写入-Idempotent-Writes"><a href="#幂等写入-Idempotent-Writes" class="headerlink" title="幂等写入 (Idempotent Writes)"></a>幂等写入 (Idempotent Writes)</h4><p><img src="/2021/04/25/flink/image-20210812232358366.png" alt="image-20210812232358366"></p>
<ul>
<li>所谓幂等操作，是说一个操作，可以重复执行很多次，但只导致一次结果更改，也就是说，后面再重复执行就不起作用了。</li>
<li>能够保证最终的结果是正确的，但不能保证中间过程全部正确。当前一个 Checkpoint 结束，后一个 Checkpoint 还未开始时，中间的数据会被处理，也会输出结果，此时如果出现故障，回滚到前一个 Checkpoint 保存的状态，中间的数据又会被处理一次并输出结果。虽然最终的结果只会保留一次，但中间过程会对外界造成一种反复执行的错觉。</li>
</ul>
<h4 id="事务写入-Transactional-Writes"><a href="#事务写入-Transactional-Writes" class="headerlink" title="事务写入 (Transactional Writes)"></a>事务写入 (Transactional Writes)</h4><ul>
<li>事务（Transaction）<ul>
<li>应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。</li>
<li>具有原子性：一个事务中的一系列的操作要么全部成功，要么一个都不做</li>
</ul>
</li>
<li><strong>实现思想：构建的事务对应着 Flink 的 Checkpoint 机制，等到 Checkpoint 真正完成的时候，才把所有对应的结果写入 Sink 系统中。</strong></li>
<li>有两种实现方式：<ul>
<li>预写日志</li>
<li>两阶段提交</li>
</ul>
</li>
</ul>
<h5 id="预写日志-Write-Ahead-Log，WAL"><a href="#预写日志-Write-Ahead-Log，WAL" class="headerlink" title="预写日志 (Write-Ahead-Log，WAL)"></a>预写日志 (Write-Ahead-Log，WAL)</h5><ul>
<li>把结果数据先当成状态保存，然后在收到 Checkpoint 完成的通知时，一次性写入 Sink 系统。</li>
<li>简单易于实现，由于数据提前在状态后端中做了缓存，所以无论什么 Sink 系统，都能用这种方式一批搞定。</li>
<li>预写日志在特殊情况下不能真正实现 exactly-once，比如数据提交时，不能保证一定是全部提交，可能是提交一半另一半还未提交时，任务出现故障。</li>
<li>DataStream API 提供了一个模板类：GenericWriteAheadSink，来实现这种事务性 Sink。</li>
</ul>
<h5 id="两阶段提交-Two-Phase-Commit，2PC"><a href="#两阶段提交-Two-Phase-Commit，2PC" class="headerlink" title="两阶段提交 (Two-Phase-Commit，2PC)"></a>两阶段提交 (Two-Phase-Commit，2PC)</h5><ul>
<li><p>对于每个 Checkpoint，Sink 任务会启动一个事务，并将接下来所有接收的数据添加到事务里。</p>
</li>
<li><p>然后将这些数据写入外部 Sink 系统，但不提交它们 —— 这时只是 “预提交”。</p>
</li>
<li><p>当它收到 Checkpoint 完成的通知时，它才正式提交事务，实现结果的真正写入。</p>
</li>
<li><p>这种方式真正实现了 exactly-once，它需要一个提供事务支持的外部 Sink 系统。Flink 提供了 TwoPhaseCommitSinkFunction 接口，来实现两阶段提交的 Sink。比如，FlinkKakfaProducer 就继承了这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkKafkaProducer</span>&lt;<span class="title">IN</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">TwoPhaseCommitSinkFunction</span>&lt;<span class="title">IN</span>, <span class="title">FlinkKafkaProducer</span>.<span class="title">KafkaTransactionState</span>, <span class="title">FlinkKafkaProducer</span>.<span class="title">KafkaTransactionContext</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseCommitSinkFunction</span>&lt;<span class="title">IN</span>, <span class="title">TXN</span>, <span class="title">CONTEXT</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>&lt;<span class="title">IN</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">CheckpointedFunction</span>, <span class="title">CheckpointListener</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/25/flink/image-20210813095330140.png" alt="image-20210813095330140"></p>
</li>
</ul>
<h5 id="2PC-对外部-Sink-系统的要求"><a href="#2PC-对外部-Sink-系统的要求" class="headerlink" title="2PC 对外部 Sink 系统的要求"></a>2PC 对外部 Sink 系统的要求</h5><ul>
<li>外部 Sink 系统必须提供事务支持，或者 Sink 任务必须能够模拟外部系统上的事务</li>
<li>在 Checkpoint 的间隔期间里，必须能够开启一个事务并接受数据写入</li>
<li>在收到 Checkpoint 完成的通知之前，事务必须是 “等待提交” 的状态。在故障恢复的情况下，这可能需要一些时间。如果这个时候 Sink 系统关闭事务 (例如超时了)，那么未提交的数据就会丢失。</li>
<li>Sink 任务必须能够在进程失败后恢复事务。</li>
<li>提交事务必须是幂等操作。</li>
</ul>
<h3 id="不同-Source-和-Sink-的一致性保证"><a href="#不同-Source-和-Sink-的一致性保证" class="headerlink" title="不同 Source 和 Sink 的一致性保证"></a>不同 Source 和 Sink 的一致性保证</h3><p><img src="/2021/04/25/flink/image-20210813102001911.png" alt="image-20210813102001911"></p>
<blockquote>
<p>2PC 是最精准，也是最难实现得一种方式。</p>
</blockquote>
<h3 id="Flink-Kafka-端到端状态一致性的保证"><a href="#Flink-Kafka-端到端状态一致性的保证" class="headerlink" title="Flink + Kafka 端到端状态一致性的保证"></a>Flink + Kafka 端到端状态一致性的保证</h3><ul>
<li>内部 —— 利用 Checkpoint 机制，把状态存盘，发生故障的时候可以恢复，保证内部的状态一致性。</li>
<li>Source —— Kafka Consumer 作为 Source，可以自动将偏移量保存下来，如果后续任务出现了故障，恢复的时候可以由连接器重置偏移量，重新消费数据，保证一致性。</li>
<li>Sink —— Kafka Producer 作为 Sink，采用两阶段提交 sink，需要实现一个 TwoPhaseCommitSinkFunction。</li>
</ul>
<h4 id="Exactly-once-两阶段提交图解"><a href="#Exactly-once-两阶段提交图解" class="headerlink" title="Exactly-once 两阶段提交图解"></a>Exactly-once 两阶段提交图解</h4><ul>
<li><p>定义一个任务，JobManager 协调各个 TaskManager 进行 Checkpoint 存储。Checkpoint 保存在 StateBackend中，默认 StateBackend 是内存级的，也可以改为文件级的进行持久化保存。</p>
<p><img src="/2021/04/25/flink/image-20210813104309481.png" alt="image-20210813104309481"></p>
</li>
<li><p>第一步：当 Checkpoint 启动时，JobManager 会将检查点分界线 (barrier) 注入数据流。barrier 会在算子间传递下去。</p>
<p><img src="/2021/04/25/flink/image-20210813104522976.png" alt="image-20210813104522976"></p>
</li>
<li><p>第二步：每个算子会对当前的状态做个快照，并保存到状态后端。Checkpoint 机制可以保证内部的状态一致性。</p>
<p><img src="/2021/04/25/flink/image-20210813104938956.png" alt="image-20210813104938956"></p>
</li>
<li><p>第三步：与第二步类似，后续每个内部的 transform 任务遇到 barrier 时，都会先把状态保存到 Checkpoint 里，然后通知 JobManager，barrier 继续向下游传递。最后，数据先到达 Sink 任务，Sink 会把数据写入外部 Kafka，这些数据都属于预提交的事务 TX1；然后，barrier 后到达 Sink 任务，Sink 会先把自己的状态保存到状态后端，并开启一个新的预提交事务 TX2，barrier 后的数据属于这个新的预提交事务。(因为流的并行度可能不为 1，当前的 Sink 任务收到了 barrier，不代表所有的 Sink 任务都收到了，此时，不能正式提交事务)</p>
<p><img src="/2021/04/25/flink/image-20210813110109944.png" alt="image-20210813110109944"></p>
</li>
<li><p>第四步：当所有算子任务的快照完成，也就是当前的 Checkpoint 完成时，JobManager 会向所有任务发通知，确认当前 Checkpoint 完成。Sink 任务收到确认通知后，会正式提交之前的事务，Kafka 中未确认数据改为 “已确认”。</p>
<p><img src="/2021/04/25/flink/image-20210813111720234.png" alt="image-20210813111720234"></p>
</li>
</ul>
<h4 id="Exactly-once-两阶段提交步骤"><a href="#Exactly-once-两阶段提交步骤" class="headerlink" title="Exactly-once 两阶段提交步骤"></a>Exactly-once 两阶段提交步骤</h4><ul>
<li>第一条数据来了之后，开启一个 Kafka 的事务 (transaction)，记作 TX1，数据正常写入 Kafka 分区日志，但标记为未提交，这就是 “预提交”；</li>
<li>Jobmanager 触发 Checkpoint 操作，barrier 从 Source 开始向下传递，遇到 barrier 的算子将状态存入状态后端，并通知 Jobmanager；</li>
<li>Sink 连接器收到 barrier，保存当前状态，存入 Checkpoint，通知 Jobmanager，并开启下一阶段的事务 TX2，用于提交下个检查点前的数据；</li>
<li>Jobmanager 收到所有任务的通知，发出确认信息，表示 Checkpoint 完成；</li>
<li>Sink 任务收到 Jobmanager 的确认信息，正式提交这段时间的数据，即 TX1 的数据；</li>
<li>外部 Kafka 关闭事务 TX1，提交的数据可以正常消费了。</li>
<li><strong>注意：Kafka 事务默认超时时间 <code>transaction.timeout.ms</code> 设置为 60s，Checkpoint 设置的超时时间不能大于 Kafka 事务的超时时间，否则，可能当 Checkpoint 仍在尝试执行时，Kafka 事务已经到达超时时间关闭了，当 Checkpoint 正常执行完成时，Kafka 之前预提交的数据就会丢失。同时，Kafka 下游的消费者，需要设置隔离级别 <code>isolation.level</code> 为 <code>read_committed</code> (默认为 <code>read_uncommitted</code>），保证 Kafka 未提交的数据不能被消费。</strong></li>
</ul>
<h2 id="ProcessFunction-API-底层-API"><a href="#ProcessFunction-API-底层-API" class="headerlink" title="ProcessFunction API (底层 API)"></a>ProcessFunction API (底层 API)</h2><ul>
<li><p>之前学习的转换算子是无法访问事件的时间戳信息和水位线信息的。而这在一些应用场景下，极为重要。例如 MapFunction 这样的 map 转换算子就无法访问时间戳或者当前事件的事件时间。</p>
</li>
<li><p>基于此，DataStream API 提供了一系列的 Low-Level 转换算子。可以访问时间戳、Watermark 以及注册定时事件。还可以输出特定的一些事件，例如超时事件等。Process Function 用来构建事件驱动的应用以及实现自定义的业务逻辑 (使用之前的 Window 函数和转换算子无法实现)。例如，Flink SQL 就是使用 Process Function 实现的。</p>
</li>
<li><p>Flink 提供了 8 个 Process Function：</p>
<ul>
<li><p>ProcessFunction</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFunction</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Process one element from the input stream.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This function can output zero or more elements using the &#123;<span class="doctag">@link</span> Collector&#125; parameter</span></span><br><span class="line"><span class="comment">    * and also update internal state or set timers using the &#123;<span class="doctag">@link</span> Context&#125; parameter.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value The input value.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ctx A &#123;<span class="doctag">@link</span> Context&#125; that allows querying the timestamp of the element and getting</span></span><br><span class="line"><span class="comment">    *            a &#123;<span class="doctag">@link</span> TimerService&#125; for registering timers and querying the time. The</span></span><br><span class="line"><span class="comment">    *            context is only valid during the invocation of this method, do not store it.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> out The collector for returning result values.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the operation</span></span><br><span class="line"><span class="comment">    *                   to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// I：输入参数   ctx：上下文   O：输出类型</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(I value, Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called when a timer set using &#123;<span class="doctag">@link</span> TimerService&#125; fires.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> timestamp The timestamp of the firing timer.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ctx An &#123;<span class="doctag">@link</span> OnTimerContext&#125; that allows querying the timestamp of the firing timer,</span></span><br><span class="line"><span class="comment">    *            querying the &#123;<span class="doctag">@link</span> TimeDomain&#125; of the firing timer and getting a</span></span><br><span class="line"><span class="comment">    *            &#123;<span class="doctag">@link</span> TimerService&#125; for registering timers and querying the time.</span></span><br><span class="line"><span class="comment">    *            The context is only valid during the invocation of this method, do not store it.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> out The collector for returning result values.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the operation</span></span><br><span class="line"><span class="comment">    *                   to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Information available in an invocation of &#123;<span class="doctag">@link</span> #processElement(Object, Context, Collector)&#125;</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Timestamp of the element currently being processed or timestamp of a firing timer.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;p&gt;This might be &#123;<span class="doctag">@code</span> null&#125;, for example if the time characteristic of your program</span></span><br><span class="line"><span class="comment">       * is set to &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.TimeCharacteristic#ProcessingTime&#125;.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Long <span class="title">timestamp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * A &#123;<span class="doctag">@link</span> TimerService&#125; for querying time and registering timers.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimerService <span class="title">timerService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Information available in an invocation of &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OnTimerContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The &#123;<span class="doctag">@link</span> TimeDomain&#125; of the firing timer.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimeDomain <span class="title">timeDomain</span><span class="params">()</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KeyedProcessFunction</p>
</li>
<li><p>CoProcessFunction</p>
</li>
<li><p>ProcessJoinFunction</p>
</li>
<li><p>BroadcastProcessFunction</p>
</li>
<li><p>KeyedBroadcastProcessFunction</p>
</li>
<li><p>ProcessWindowFunction</p>
</li>
<li><p>ProcessAllWindowFunction</p>
</li>
</ul>
</li>
</ul>
<h3 id="KeyedProcessFunction"><a href="#KeyedProcessFunction" class="headerlink" title="KeyedProcessFunction"></a>KeyedProcessFunction</h3><ul>
<li><p>这里重点介绍 KeyedProcessFunction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A keyed function that processes elements of a stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For every element in the input stream &#123;<span class="doctag">@link</span> #processElement(Object, Context, Collector)&#125;</span></span><br><span class="line"><span class="comment"> * is invoked. This can produce zero or more elements as output. Implementations can also</span></span><br><span class="line"><span class="comment"> * query the time and set timers through the provided &#123;<span class="doctag">@link</span> Context&#125;. For firing timers</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125; will be invoked. This can again produce</span></span><br><span class="line"><span class="comment"> * zero or more elements as output and register further timers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Access to keyed state and timers (which are also scoped to a key) is only</span></span><br><span class="line"><span class="comment"> * available if the &#123;<span class="doctag">@code</span> KeyedProcessFunction&#125; is applied on a &#123;<span class="doctag">@code</span> KeyedStream&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; A &#123;<span class="doctag">@code</span> KeyedProcessFunction&#125; is always a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction&#125;. Therefore, access to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RuntimeContext&#125; is always available and setup and</span></span><br><span class="line"><span class="comment"> * teardown methods can be implemented. See</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction#open(org.apache.flink.configuration.Configuration)&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction#close()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; Type of the key.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;I&gt; Type of the input elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;O&gt; Type of the output elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">K</span>, <span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Process one element from the input stream.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This function can output zero or more elements using the &#123;<span class="doctag">@link</span> Collector&#125; parameter</span></span><br><span class="line"><span class="comment">    * and also update internal state or set timers using the &#123;<span class="doctag">@link</span> Context&#125; parameter.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value The input value.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ctx A &#123;<span class="doctag">@link</span> Context&#125; that allows querying the timestamp of the element and getting</span></span><br><span class="line"><span class="comment">    *            a &#123;<span class="doctag">@link</span> TimerService&#125; for registering timers and querying the time. The</span></span><br><span class="line"><span class="comment">    *            context is only valid during the invocation of this method, do not store it.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> out The collector for returning result values.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the operation</span></span><br><span class="line"><span class="comment">    *                   to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(I value, Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called when a timer set using &#123;<span class="doctag">@link</span> TimerService&#125; fires.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> timestamp The timestamp of the firing timer.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ctx An &#123;<span class="doctag">@link</span> OnTimerContext&#125; that allows querying the timestamp, the &#123;<span class="doctag">@link</span> TimeDomain&#125;, and the key</span></span><br><span class="line"><span class="comment">    *            of the firing timer and getting a &#123;<span class="doctag">@link</span> TimerService&#125; for registering timers and querying the time.</span></span><br><span class="line"><span class="comment">    *            The context is only valid during the invocation of this method, do not store it.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> out The collector for returning result values.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the operation</span></span><br><span class="line"><span class="comment">    *                   to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// 定时操作</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Information available in an invocation of &#123;<span class="doctag">@link</span> #processElement(Object, Context, Collector)&#125;</span></span><br><span class="line"><span class="comment">    * or &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Timestamp of the element currently being processed or timestamp of a firing timer.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;p&gt;This might be &#123;<span class="doctag">@code</span> null&#125;, for example if the time characteristic of your program</span></span><br><span class="line"><span class="comment">       * is set to &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.TimeCharacteristic#ProcessingTime&#125;.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Long <span class="title">timestamp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * A &#123;<span class="doctag">@link</span> TimerService&#125; for querying time and registering timers.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimerService <span class="title">timerService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Get key of the element being processed.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> K <span class="title">getCurrentKey</span><span class="params">()</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Information available in an invocation of &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OnTimerContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The &#123;<span class="doctag">@link</span> TimeDomain&#125; of the firing timer.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimeDomain <span class="title">timeDomain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Get key of the firing timer.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> K <span class="title">getCurrentKey</span><span class="params">()</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KeyedProcessFunction 用来操作 KeyedStream。KeyedProcessFunction 会处理流的每一个元素，输出为 0 个、1 个或者多个元素。</p>
</li>
<li><p>所有的 Process Function 都继承自RichFunction 接口，所以都有 <code>open()</code>、<code>close()</code> 和 <code>getRuntimeContext()</code> 等方法。而 <code>KeyedProcessFunction&lt;K, I, O&gt;</code> 还额外提供了两个方法:</p>
<ul>
<li><code>processElement(I value, Context ctx, Collector&lt;O&gt; out)</code>：流中的每一个元素都会调用这个方法，调用结果将会放在 Collector 数据类型中输出。Context 可以访问元素的时间戳，元素的 key，以及 TimerService 时间服务。Context 还可以将结果输出到别的流 (side outputs)。</li>
<li><code>onTimer(long timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</code>：是一个回调函数。当之前注册的定时器触发时调用。参数 timestamp 为定时器所设定的触发的时间戳。Collector 为输出结果的集合。OnTimerContext 和 <code>processElement()</code> 的 Context 参数一样，提供了上下文的一些信息，例如定时器触发的时间信息 (事件时间或者处理时间)。</li>
<li>Context 和 OnTimerContext 所持有的 TimerService 对象拥有以下方法：<ul>
<li><code>long currentProcessingTime()</code>：返回当前处理时间。</li>
<li><code>long currentWatermark()</code>：返回当前 Watermark 的时间戳。</li>
<li><code>void registerProcessingTimeTimer(long timestamp)</code>：会注册当前 key 的 Processing Time 的定时器。当 Processing Time 到达定时时间时，触发 timer。<ul>
<li>当定时器 timer 触发时，会执行回调函数 <code>onTimer()</code>。注意定时器 timer 只能在 keyed streams 上面使用。</li>
</ul>
</li>
<li><code>void registerEventTimeTimer(long timestamp)</code>：会注册当前 key 的 Event Time 定时器。当 Watetmark 大于等于定时器注册的时间时，触发定时器执行回调函数 <code>onTimer()</code>。</li>
<li><code>void deleteProcessingTimeTimer(long timestamp)</code>：删除之前注册处理时间定时器。如果没有这个时间戳的定时器，则不执行。</li>
<li><code>void deleteEventTimeTimer(long timestamp)</code>：删除之前注册的事件时间定时器。如果没有此时间戳的定时器，则不执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTest1_KeyedProcessFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.测试KeyedProcessFunction，先分组然后自定义处理</span></span><br><span class="line">        dataStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .process(<span class="keyword">new</span> MyProcess())</span><br><span class="line">                .print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义的处理函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">Tuple</span>, <span class="title">SensorReading</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Long&gt; tsTimerState;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            tsTimerState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;ts-timer&quot;</span>, Long.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(SensorReading sensorReading, Context ctx, Collector&lt;Integer&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            out.collect(sensorReading.getId().length());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Context的使用</span></span><br><span class="line">            <span class="comment">// 1.获取时间戳</span></span><br><span class="line">            ctx.timestamp();</span><br><span class="line">            <span class="comment">// 2.获取当前key</span></span><br><span class="line">            ctx.getCurrentKey();</span><br><span class="line">            <span class="comment">// 3.按需将满足某条件的数据输出到侧输出流</span></span><br><span class="line">            OutputTag&lt;Double&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;Double&gt;(<span class="string">&quot;temp&quot;</span>) &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">            ctx.output(outputTag, sensorReading.getTemperature());</span><br><span class="line">            <span class="comment">// 4.定时服务</span></span><br><span class="line">            ctx.timerService().currentProcessingTime();<span class="comment">// 获取当前Processing Time</span></span><br><span class="line">            ctx.timerService().currentWatermark();<span class="comment">// 获取当前Watermark</span></span><br><span class="line">            <span class="comment">// 注册Processing Time定时器，参数是要触发时的时间。从1970年1月1日开始的毫秒数，即当前时间基础上延迟1s</span></span><br><span class="line">            ctx.timerService().registerProcessingTimeTimer(ctx.timerService().currentProcessingTime() + <span class="number">1000L</span>);</span><br><span class="line">            <span class="comment">// 保存定时器指定的触发时间状态</span></span><br><span class="line">            tsTimerState.update(ctx.timerService().currentProcessingTime() + <span class="number">1000L</span>);</span><br><span class="line">            <span class="comment">// 注册Event Time定时器，参数是要触发时的时间。在当前参数时间戳基础上延迟10s</span></span><br><span class="line">            ctx.timerService().registerEventTimeTimer((sensorReading.getTimestamp() + <span class="number">10</span>) * <span class="number">1000L</span>);</span><br><span class="line">            <span class="comment">// 取消注册的Processing Time定时器，以定时器设定的时间区分</span></span><br><span class="line">            ctx.timerService().deleteProcessingTimeTimer(ctx.timerService().currentProcessingTime() + <span class="number">1000L</span>);</span><br><span class="line">            <span class="comment">// 删除定时器的操作，可能在定义定时器时间一段时间之后才执行，因此，保存定时器定义时的状态，然后在后续删除时取出这个状态</span></span><br><span class="line">            ctx.timerService().deleteProcessingTimeTimer(tsTimerState.value());</span><br><span class="line">            <span class="comment">// 取消注册的Event Time定时器，以定时器设定的时间区分</span></span><br><span class="line">            ctx.timerService().deleteEventTimeTimer((sensorReading.getTimestamp() + <span class="number">10</span>) * <span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时器触发时执行的方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;Integer&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// timestamp即为触发的定时器的时间</span></span><br><span class="line">            System.out.println(timestamp + <span class="string">&quot;定时器触发&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ctx和out用法与processElement()类似，ctx多了下面这个方法</span></span><br><span class="line">            <span class="comment">// 获取当前的时间语义，PROCESSING_TIME或EVENT_TIME</span></span><br><span class="line">            ctx.timeDomain();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            tsTimerState.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例：监控温度传感器的温度值，如果温度值在 10 秒钟之内 (Processing Time) 连续上升，则报警。</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTest2_ApplicationCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.测试KeyedProcessFunction，先分组然后自定义处理</span></span><br><span class="line">        dataStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .process(<span class="keyword">new</span> TempConsIncreWarning(<span class="number">10</span>))</span><br><span class="line">                .print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义处理函数，检测一段时间内的温度连续上升，输出报警</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TempConsIncreWarning</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">Tuple</span>, <span class="title">SensorReading</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 定义私有属性，当前统计的时间间隔</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Integer interval;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TempConsIncreWarning</span><span class="params">(Integer interval)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.interval = interval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义状态，保存上一次的温度值和定时器时间戳</span></span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Double&gt; lastTempState;</span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Long&gt; timerTsState;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            lastTempState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Double&gt;(<span class="string">&quot;last-temp&quot;</span>, Double.class));</span><br><span class="line">            timerTsState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;timer-ts&quot;</span>, Long.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(SensorReading value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 取出状态</span></span><br><span class="line">            Double lastTemp = lastTempState.value();</span><br><span class="line">            <span class="keyword">if</span> (lastTemp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Long timerTs = timerTsState.value();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果温度出现上升并且没有定时器，注册10秒后触发的定时器，开始等待</span></span><br><span class="line">                <span class="comment">// 之后的温度如果仍在上升，则不需要额外处理，等待定时器触发即可</span></span><br><span class="line">                <span class="keyword">if</span> (value.getTemperature() &gt; lastTemp &amp;&amp; timerTs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 计算定时器触发的时间戳，注意是执行操作算子的本地系统时间，10s时间很快</span></span><br><span class="line">                    <span class="keyword">long</span> ts = ctx.timerService().currentProcessingTime() + interval * <span class="number">1000L</span>;</span><br><span class="line">                    <span class="comment">// 注册定时器</span></span><br><span class="line">                    ctx.timerService().registerProcessingTimeTimer(ts);</span><br><span class="line">                    <span class="comment">// 保存定时器触发的时间戳，用于删除</span></span><br><span class="line">                    timerTsState.update(ts);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.getTemperature() &lt;= lastTemp &amp;&amp; timerTs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果温度下降，那么删除定时器</span></span><br><span class="line">                    ctx.timerService().deleteProcessingTimeTimer(timerTs);</span><br><span class="line">                    timerTsState.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新温度状态</span></span><br><span class="line">            lastTempState.update(value.getTemperature());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 如果触发了定时器，说明10s内温度连续上升，输出报警信息</span></span><br><span class="line">            out.collect(<span class="string">&quot;传感器&quot;</span> + ctx.getCurrentKey().getField(<span class="number">0</span>) + <span class="string">&quot;的温度值&quot;</span> + interval + <span class="string">&quot;s内连续秒上升&quot;</span>);</span><br><span class="line">            <span class="comment">// 触发定时器后，清空</span></span><br><span class="line">            timerTsState.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            lastTempState.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP<span class="literal">-OM8IACS</span>:/mnt/c/Users/Ziyoo<span class="variable">$</span> nc <span class="literal">-lk</span> <span class="number">7777</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">35</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">36.7</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">37.2</span></span><br><span class="line">sensor_6,<span class="number">1547718199</span>,<span class="number">36.7</span></span><br><span class="line">sensor_6,<span class="number">1547718199</span>,<span class="number">35.7</span></span><br><span class="line">sensor_6,<span class="number">1547718199</span>,<span class="number">34.7</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sensor_1 报警信息是从 35 度开始计算的，sensor_6 不会报警。</p>
</blockquote>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">5&gt; 传感器sensor_1温度值10s内连续秒上升</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="侧输出流-SideOutput"><a href="#侧输出流-SideOutput" class="headerlink" title="侧输出流 (SideOutput)"></a>侧输出流 (SideOutput)</h3><ul>
<li><p>大部分的 DataStream API 的算子的输出是单一输出，也就是某种数据类型的流。除了 split 算子，可以将一条流分成多条流，但这些流的数据类型也都相同。ProcessFunction 的 side outputs 功能可以产生多条流，并且这些流的数据类型可以不一样。一个 side output 可以定义为 OutputTag[X] 对象，X 是输出流的数据类型。ProcessFunction 可以通过 Context 对象发射一个事件到一个或者多个 side outputs。</p>
</li>
<li><p>实例：监控传感器温度值，将温度值低于 30 度的数据输出到 side output。</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTest3_SideOuptCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从Scoket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将文件内容转换成SensorReading对象</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个OutputTag，用来表示侧输出流低温流</span></span><br><span class="line">        OutputTag&lt;SensorReading&gt; lowTempTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;lowTemp&quot;</span>) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.测试ProcessFunction，自定义侧输出流实现分流操作</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; highTempStream = dataStream.process(<span class="keyword">new</span> ProcessFunction&lt;SensorReading, SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(SensorReading sensorReading, Context ctx, Collector&lt;SensorReading&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 判断温度，大于30度，高温流输出到主流；小于低温流输出到侧输出流</span></span><br><span class="line">                <span class="keyword">if</span> (sensorReading.getTemperature() &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                    out.collect(sensorReading);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ctx.output(lowTempTag, sensorReading);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印</span></span><br><span class="line">        highTempStream.print(<span class="string">&quot;high-temp&quot;</span>);</span><br><span class="line">        highTempStream.getSideOutput(lowTempTag).print(<span class="string">&quot;low-temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xisun@DESKTOP<span class="literal">-OM8IACS</span>:/mnt/c/Users/Ziyoo<span class="variable">$</span> nc <span class="literal">-lk</span> <span class="number">7777</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">28.7</span></span><br><span class="line">sensor_6,<span class="number">1547718213</span>,<span class="number">15.3</span></span><br><span class="line">sensor_10,<span class="number">1547718213</span>,<span class="number">38.3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.ClosureCleaner)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">high-temp:2&gt; SensorReading</span>&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">35.8</span>&#125;</span><br><span class="line">low-temp:<span class="number">3</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_1&#x27;</span>, timestamp=<span class="number">1547718199</span>, temperature=<span class="number">28.7</span>&#125;</span><br><span class="line">low-temp:<span class="number">4</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_6&#x27;</span>, timestamp=<span class="number">1547718213</span>, temperature=<span class="number">15.3</span>&#125;</span><br><span class="line">high-temp:<span class="number">5</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor_10&#x27;</span>, timestamp=<span class="number">1547718213</span>, temperature=<span class="number">38.3</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与 id 无关，来一条数据判断一次，然后输出结果。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="CoProcessFunction"><a href="#CoProcessFunction" class="headerlink" title="CoProcessFunction"></a>CoProcessFunction</h3><ul>
<li>对于两条输入流，DataStream API 提供了 CoProcessFunction 这样的 low-level 操作。CoProcessFunction 提供了操作每一个输入流的方法：<code>processElement1()</code> 和 <code>processElement2()</code>。</li>
<li>类似于 ProcessFunction，这两种方法都通过 Context 对象来调用。这个 Context 对象可以访问事件数据，定时器时间戳，TimerService，以及 side outputs。CoProcessFunction 也提供了 <code>onTimer()</code> 回调函数。</li>
</ul>
<h2 id="Table-API-与-SQL"><a href="#Table-API-与-SQL" class="headerlink" title="Table API 与 SQL"></a>Table API 与 SQL</h2><ul>
<li>说明：本章节示例的很多方法已过时，此处只做学习用，具体使用时再做更改。</li>
</ul>
<h3 id="Table-API-和-Flink-SQL-是什么"><a href="#Table-API-和-Flink-SQL-是什么" class="headerlink" title="Table API 和 Flink SQL 是什么"></a>Table API 和 Flink SQL 是什么</h3><ul>
<li><p>Flink 对批处理和流处理，提供了统一的上层 API。</p>
<p><img src="/2021/04/25/flink/image-20210817114056535.png" alt="image-20210817114056535"></p>
</li>
<li><p>Table API 是一套内嵌在 Java 和 Scala 语言中的查询 API，它允许以非常直观的方式组合来自一些关系运算符的查询。</p>
</li>
<li><p>Flink 的 SQL 支持基于实现了 SQL 标准的 Apache Calcite。</p>
</li>
<li><p>Table API 是流处理和批处理通用的关系型 API，Table API 可以基于流输入或者批输入来运行而不需要进行任何修改。Table API 是 SQL 语言的超集并专门为 Apache Flink 设计的，Table API 是 Scala 和 Java 语言集成式的 API。与常规 SQL 语言中将查询指定为字符串不同，Table API 查询是以 Java 或 Scala 中的语言嵌入样式来定义的，具有 IDE 支持如自动完成和语法检测。</p>
</li>
<li><p>Maven 引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner-blink_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/25/flink/image-20210817164421379.png" alt="image-20210817164421379"></p>
</li>
<li><p>实例：</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest1_Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.转换成POJO</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.基于流创建一张表，表中的字段就是SensorReading的属性</span></span><br><span class="line">        Table dataTable = tableEnv.fromDataStream(dataStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-1.调用Table API进行转换操作，选取表中指定数据</span></span><br><span class="line">        Table resultTable = dataTable.select(<span class="string">&quot;id, temperature&quot;</span>)</span><br><span class="line">                .where(<span class="string">&quot;id = &#x27;sensor_1&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-2.执行SQL进行查询操作，这种方式与用Table API是等价的</span></span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, dataTable);<span class="comment">// 需要先将表注册，sensor就是表明</span></span><br><span class="line">        String sql = <span class="string">&quot;select id, temperature from sensor where id = &#x27;sensor_1&#x27;&quot;</span>;<span class="comment">// 从注册的表中查询</span></span><br><span class="line">        Table resultSqlTable = tableEnv.sqlQuery(sql);<span class="comment">// 执行sql</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.将6-1和6-2的结果转换成流，然后打印</span></span><br><span class="line">        <span class="comment">// Row.class，org.apache.flink.types.Row，指定查询的结果按行输出</span></span><br><span class="line">        <span class="comment">// 也可以使用自定义的类，如SensorReading.class，但要求该类是public的，且查询的结果和类的属性要能对应</span></span><br><span class="line">        tableEnv.toAppendStream(resultTable, Row.class).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        tableEnv.toAppendStream(resultSqlTable, Row.class).print(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">result&gt; sensor_1,35.8</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,35.8</span></span><br><span class="line"><span class="function">result&gt; sensor_1,36.3</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,36.3</span></span><br><span class="line"><span class="function">result&gt; sensor_1,34.7</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,34.7</span></span><br><span class="line"><span class="function">result&gt; sensor_1,33.1</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,33.1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="程序实现的基本结构"><a href="#程序实现的基本结构" class="headerlink" title="程序实现的基本结构"></a>程序实现的基本结构</h3><ul>
<li><p>Table API 和 SQL 的程序结构，与流式处理的程序结构十分类似：</p>
<img src="/2021/04/25/flink/image-20210817165913353.png" alt="image-20210817165913353" style="zoom:80%;">

</li>
</ul>
<h3 id="不同类型-TableEnvironment-的创建"><a href="#不同类型-TableEnvironment-的创建" class="headerlink" title="不同类型 TableEnvironment 的创建"></a>不同类型 TableEnvironment 的创建</h3><ul>
<li><p>TableEnvironment 是 Flink 中集成 Table API 和 SQL 的核心概念，所有对表的操作都基于 TableEnvironment：</p>
<ul>
<li>注册 Catalog。</li>
<li>在 Catalog 中注册表。</li>
<li>执行 SQL 查询。</li>
<li>注册用户自定义函数 (UDF)。</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest2_CreateTableEnv</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建表处理环境，Flink 1.11版本之前，默认使用老版本planner，1.11版本及之后，默认使用Blink版本</span></span><br><span class="line">        <span class="comment">// 因此，可以自行添加配置，创建所需要的环境版本</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.不同版本环境的创建</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-1.基于老版本planner的流处理</span></span><br><span class="line">        EnvironmentSettings oldStreamSettings = EnvironmentSettings.newInstance()</span><br><span class="line">                .useOldPlanner()<span class="comment">// 老版本</span></span><br><span class="line">                .inStreamingMode()<span class="comment">// 流式处理</span></span><br><span class="line">                .build();</span><br><span class="line">        StreamTableEnvironment oldStreamTableEnv = StreamTableEnvironment.create(env, oldStreamSettings);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-2.基于老版本planner的批处理</span></span><br><span class="line">        ExecutionEnvironment batchEnv = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        BatchTableEnvironment oldBatchTableEnv = BatchTableEnvironment.create(batchEnv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-3.基于Blink的流处理(即新版本)</span></span><br><span class="line">        EnvironmentSettings blinkStreamSettings = EnvironmentSettings.newInstance()</span><br><span class="line">                .useBlinkPlanner()<span class="comment">// 新版本</span></span><br><span class="line">                .inStreamingMode()<span class="comment">// 流式处理</span></span><br><span class="line">                .build();</span><br><span class="line">        StreamTableEnvironment blinkStreamTableEnv = StreamTableEnvironment.create(env, blinkStreamSettings);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-4.基于Blink的批处理(即新版本)</span></span><br><span class="line">        EnvironmentSettings blinkBatchSettings = EnvironmentSettings.newInstance()</span><br><span class="line">                .useBlinkPlanner()<span class="comment">// 新版本</span></span><br><span class="line">                .inBatchMode()<span class="comment">// 批处理</span></span><br><span class="line">                .build();</span><br><span class="line">        TableEnvironment blinkBatchTableEnv = TableEnvironment.create(blinkBatchSettings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="表-Table"><a href="#表-Table" class="headerlink" title="表 (Table)"></a>表 (Table)</h3><ul>
<li>TableEnvironment 可以注册目录 Catalog，并可以基于 Catalog 注册表。</li>
<li>表 (Table) 是由一个 “标识符” (identifier) 来指定的，由 3 部分组成：Catalog 名、数据库 (database) 名和对象名。<ul>
<li>Catalog 名、数据库 (database) 名如果不指定，默认为 defaultCatalog 和 defaultDatabase。</li>
</ul>
</li>
<li>表可以是常规的，也可以是虚拟的 (视图，View)。<ul>
<li>连接到外部系统 (比如 Kafka) 的叫常规表，如果是 Flink 程序转换过程中临时创建的，是虚拟表。</li>
</ul>
</li>
<li>常规表 (Table) 一般可以用来描述外部数据，比如文件、数据库表或消息队列的数据，也可以直接从 DataStream 转换而来。</li>
<li>视图 (View) 可以从现有的表中创建，通常是 Table API 或者 SQL 查询的一个结果集。</li>
</ul>
<h4 id="更新模式"><a href="#更新模式" class="headerlink" title="更新模式"></a>更新模式</h4><ul>
<li>对于流式查询，需要声明如何在表和外部连接器之间执行转换。</li>
<li>与外部系统交换的消息类型，由更新模式 (Update Mode) 指定：<ul>
<li>追加 (Append) 模式<ul>
<li>表只做插入操作，和外部连接器只交换插入 (Insert) 消息。</li>
</ul>
</li>
<li>撤回 (Retract) 模式<ul>
<li>表和外部连接器交换添加 (Add) 和撤回 (Retract) 消息。</li>
<li>插入操作 (Insert) 编码为 Add 消息；删除操作 (Delete) 编码为 Retract 消息；更新操作 (Update) 编码为上一条的 Retract 消息和下一条的 Add 消息。</li>
</ul>
</li>
<li>更新插入 (Upsert) 模式<ul>
<li>更新和插入操作都被编码为 Upsert 消息 (需要指定 key，key 存在为更新操作，不存在为插入操作)；删除操作编码为 Delete 消息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="从文件创建表"><a href="#从文件创建表" class="headerlink" title="从文件创建表"></a>从文件创建表</h4><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest3_CommonApi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.表的创建：连接外部系统，读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-1.读取外部文件创建表</span></span><br><span class="line">        String inputPath = <span class="string">&quot;src/main/resources/sensor.txt&quot;</span>;</span><br><span class="line">        tableEnv.connect(<span class="keyword">new</span> FileSystem().path(inputPath))<span class="comment">// 连接器的描述器</span></span><br><span class="line">                .withFormat(<span class="keyword">new</span> Csv())<span class="comment">// 格式化，也可以是json</span></span><br><span class="line">                .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                        .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">                        .field(<span class="string">&quot;temp&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">                )<span class="comment">// 定义表结构，参考数据库表结构的定义，注意：表结构的顺序，应和文件内字段顺序一一对应，字段名可以不相同</span></span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;inputTable&quot;</span>);<span class="comment">// 注册表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-2.获取注册的表</span></span><br><span class="line">        Table inputTable = tableEnv.from(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line">        inputTable.printSchema();<span class="comment">// 打印表结构</span></span><br><span class="line">        tableEnv.toAppendStream(inputTable, Row.class).print();<span class="comment">// 打印表数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.查询转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4-1.Table API的操作</span></span><br><span class="line">        <span class="comment">// 简单转换</span></span><br><span class="line">        Table resultTable = inputTable.select(<span class="string">&quot;id, temp&quot;</span>)<span class="comment">// 查询id和temp字段</span></span><br><span class="line">                .filter(<span class="string">&quot;id === &#x27;sensor_6&#x27;&quot;</span>);<span class="comment">// 查询id为sensor_6的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 聚合统计</span></span><br><span class="line">        Table aggTable = inputTable.groupBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id, id.count as count, temp.avg as avgTemp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4-2.SQL的操作</span></span><br><span class="line">        tableEnv.sqlQuery(<span class="string">&quot;select id, temp from inputTable where id = &#x27;senosr_6&#x27;&quot;</span>);</span><br><span class="line">        Table sqlAggTable = tableEnv.sqlQuery(<span class="string">&quot;select id, count(id) as cnt, avg(temp) as avgTemp from inputTable group by id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.打印输出</span></span><br><span class="line">        tableEnv.toAppendStream(resultTable, Row.class).print(<span class="string">&quot;result&quot;</span>);<span class="comment">// 来一条数据，resultTable追加一条数据</span></span><br><span class="line">        tableEnv.toRetractStream(aggTable, Row.class).print(<span class="string">&quot;agg&quot;</span>);<span class="comment">// 来一条数据，aggTable更新一次结果</span></span><br><span class="line">        tableEnv.toRetractStream(sqlAggTable, Row.class).print(<span class="string">&quot;sqlagg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Csv (<code>org.apache.flink.table.descriptors.Csv</code>) 需要添加依赖：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 新版本CSV支持 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flink-csv&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Table API 是集成在 Scala 和 Java 语言内的查询 API。</p>
<ul>
<li>Table API 基于代表 “表” 的 Table 类，并提供一整套操作处理的方法 API；这些方法会返回一个新的 Table 对象，表示对输入表应用转换操作的结果。</li>
<li>有些关系型转换操作，可以由多个方法调用组成，构成链式调用结构。</li>
</ul>
</li>
<li><p>Flink 的 SQL 集成，基于实现 了SQL 标准的 Apache Calcite。</p>
<ul>
<li>在 Flink 中，用常规字符串来定义 SQL 查询语句。</li>
<li>SQL 查询的结果，也是一个新的 Table。</li>
</ul>
</li>
</ul>
</li>
<li><p>输入文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/main/resources/sensor.txt</code></p>
</blockquote>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- id: STRING</span><br><span class="line"> |-- timestamp: BIGINT</span><br><span class="line"> |-- temp: DOUBLE</span><br><span class="line"></span><br><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">sensor_1,1547718199,35.8</span></span><br><span class="line"><span class="function">sensor_6,1547718201,15.4</span></span><br><span class="line"><span class="function">sensor_7,1547718202,6.7</span></span><br><span class="line"><span class="function">sensor_10,1547718205,38.1</span></span><br><span class="line"><span class="function">result&gt; sensor_6,15.4</span></span><br><span class="line"><span class="function">sensor_1,1547718206,36.3</span></span><br><span class="line"><span class="function">sensor_1,1547718210,34.7</span></span><br><span class="line"><span class="function">result&gt; sensor_6,15.3</span></span><br><span class="line"><span class="function">sensor_1,1547718212,33.1</span></span><br><span class="line"><span class="function">sensor_6,1547718212,15.3</span></span><br><span class="line"><span class="function">sensor_7,1547718212,6.3</span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">1</span>,<span class="number">35.8</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">1</span>,<span class="number">35.8</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_6,<span class="number">1</span>,<span class="number">15.4</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_6,<span class="number">1</span>,<span class="number">15.4</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_7,<span class="number">1</span>,<span class="number">6.7</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_7,<span class="number">1</span>,<span class="number">6.7</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_10,<span class="number">1</span>,<span class="number">38.1</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_10,<span class="number">1</span>,<span class="number">38.1</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">1</span>,<span class="number">35.8</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">2</span>,<span class="number">36.05</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">1</span>,<span class="number">35.8</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">2</span>,<span class="number">36.05</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">2</span>,<span class="number">36.05</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">3</span>,<span class="number">35.6</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">2</span>,<span class="number">36.05</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">3</span>,<span class="number">35.6</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">4</span>,<span class="number">34.975</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">3</span>,<span class="number">35.6</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">false</span>,sensor_6,<span class="number">1</span>,<span class="number">15.4</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">3</span>,<span class="number">35.6</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_6,<span class="number">2</span>,<span class="number">15.350000000000001</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">4</span>,<span class="number">34.975</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">false</span>,sensor_7,<span class="number">1</span>,<span class="number">6.7</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">false</span>,sensor_6,<span class="number">1</span>,<span class="number">15.4</span>)</span></span></span><br><span class="line"><span class="function">sqlagg&gt; <span class="params">(<span class="keyword">true</span>,sensor_7,<span class="number">2</span>,<span class="number">6.5</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_6,<span class="number">2</span>,<span class="number">15.350000000000001</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">false</span>,sensor_7,<span class="number">1</span>,<span class="number">6.7</span>)</span></span></span><br><span class="line"><span class="function">agg&gt; <span class="params">(<span class="keyword">true</span>,sensor_7,<span class="number">2</span>,<span class="number">6.5</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>表结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- id: STRING</span><br><span class="line"> |-- timestamp: BIGINT</span><br><span class="line"> |-- temp: DOUBLE</span><br></pre></td></tr></table></figure>
</li>
<li><p>表数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">sensor_6,<span class="number">1547718201</span>,<span class="number">15.4</span></span><br><span class="line">sensor_7,<span class="number">1547718202</span>,<span class="number">6.7</span></span><br><span class="line">sensor_10,<span class="number">1547718205</span>,<span class="number">38.1</span></span><br><span class="line">sensor_1,<span class="number">1547718206</span>,<span class="number">36.3</span></span><br><span class="line">sensor_1,<span class="number">1547718210</span>,<span class="number">34.7</span></span><br><span class="line">sensor_1,<span class="number">1547718212</span>,<span class="number">33.1</span></span><br><span class="line">sensor_6,<span class="number">1547718212</span>,<span class="number">15.3</span></span><br><span class="line">sensor_7,<span class="number">1547718212</span>,<span class="number">6.3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>resultTable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result&gt; sensor_6,<span class="number">15.4</span></span><br><span class="line">result&gt; sensor_6,<span class="number">15.3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>aggTable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_1,<span class="number">1</span>,<span class="number">35.8</span>)</span><br><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_6,<span class="number">1</span>,<span class="number">15.4</span>)</span><br><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_7,<span class="number">1</span>,<span class="number">6.7</span>)</span><br><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_10,<span class="number">1</span>,<span class="number">38.1</span>)</span><br><span class="line">agg&gt; (<span class="keyword">false</span>,sensor_1,<span class="number">1</span>,<span class="number">35.8</span>)</span><br><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_1,<span class="number">2</span>,<span class="number">36.05</span>)	<span class="comment">// 2表示的是当前id数据的个数</span></span><br><span class="line">agg&gt; (<span class="keyword">false</span>,sensor_1,<span class="number">2</span>,<span class="number">36.05</span>)</span><br><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_1,<span class="number">3</span>,<span class="number">35.6</span>)</span><br><span class="line">agg&gt; (<span class="keyword">false</span>,sensor_1,<span class="number">3</span>,<span class="number">35.6</span>)</span><br><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_1,<span class="number">4</span>,<span class="number">34.975</span>)</span><br><span class="line">agg&gt; (<span class="keyword">false</span>,sensor_6,<span class="number">1</span>,<span class="number">15.4</span>)</span><br><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_6,<span class="number">2</span>,<span class="number">15.350000000000001</span>)</span><br><span class="line">agg&gt; (<span class="keyword">false</span>,sensor_7,<span class="number">1</span>,<span class="number">6.7</span>)</span><br><span class="line">agg&gt; (<span class="keyword">true</span>,sensor_7,<span class="number">2</span>,<span class="number">6.5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出：对于同一个 id，来一条新数据时，会做一次聚合操作，并撤销前一次的聚合结果 (如 <code>agg&gt; (false,sensor_1,1,35.8)</code>)，再添加聚合后的新结果 (如 <code>agg&gt; (true,sensor_1,2,36.05)</code>)。聚合操作是把新数据的温度值，与之前的聚合结果重新聚合 (此处是取平均值)。</li>
</ul>
</li>
<li><p>sqlAggTable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_1,<span class="number">1</span>,<span class="number">35.8</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_6,<span class="number">1</span>,<span class="number">15.4</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_7,<span class="number">1</span>,<span class="number">6.7</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_10,<span class="number">1</span>,<span class="number">38.1</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">false</span>,sensor_1,<span class="number">1</span>,<span class="number">35.8</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_1,<span class="number">2</span>,<span class="number">36.05</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">false</span>,sensor_1,<span class="number">2</span>,<span class="number">36.05</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_1,<span class="number">3</span>,<span class="number">35.6</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">false</span>,sensor_1,<span class="number">3</span>,<span class="number">35.6</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_1,<span class="number">4</span>,<span class="number">34.975</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">false</span>,sensor_6,<span class="number">1</span>,<span class="number">15.4</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_6,<span class="number">2</span>,<span class="number">15.350000000000001</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">false</span>,sensor_7,<span class="number">1</span>,<span class="number">6.7</span>)</span><br><span class="line">sqlagg&gt; (<span class="keyword">true</span>,sensor_7,<span class="number">2</span>,<span class="number">6.5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>sqlAggTable 与 aggTable 效果一样。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="输出表到文件"><a href="#输出表到文件" class="headerlink" title="输出表到文件"></a>输出表到文件</h4><ul>
<li><p>表的输出，是通过将数据写入 TableSink 来实现的。</p>
</li>
<li><p>TableSink 是一个通用接口，可以支持不同的文件格式、存储数据库和消息队列。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest4_FileOutput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.表的创建：连接外部系统，读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-1.读取外部文件创建表</span></span><br><span class="line">        String inputPath = <span class="string">&quot;src/main/resources/sensor.txt&quot;</span>;</span><br><span class="line">        tableEnv.connect(<span class="keyword">new</span> FileSystem().path(inputPath))<span class="comment">// 连接器的描述器</span></span><br><span class="line">                .withFormat(<span class="keyword">new</span> Csv())<span class="comment">// 格式化，也可以是json</span></span><br><span class="line">                .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                        .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">                        .field(<span class="string">&quot;temp&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">                )<span class="comment">// 定义表结构，参考数据库表结构的定义，注意：表结构的顺序，应和文件内字段顺序一一对应</span></span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;inputTable&quot;</span>);<span class="comment">// 注册表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-2.获取注册的表</span></span><br><span class="line">        Table inputTable = tableEnv.from(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.查询转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4-1.Table API的操作</span></span><br><span class="line">        <span class="comment">// 简单转换</span></span><br><span class="line">        Table resultTable = inputTable.select(<span class="string">&quot;id, temp&quot;</span>)<span class="comment">// 查询id和temp字段</span></span><br><span class="line">                .filter(<span class="string">&quot;id === &#x27;sensor_6&#x27;&quot;</span>);<span class="comment">// 查询id为sensor_6的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 聚合统计</span></span><br><span class="line">        Table aggTable = inputTable.groupBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id, id.count as count, temp.avg as avgTemp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4-2.SQL的操作</span></span><br><span class="line">        tableEnv.sqlQuery(<span class="string">&quot;select id, temp from inputTable where id = &#x27;senosr_6&#x27;&quot;</span>);</span><br><span class="line">        Table sqlAggTable = tableEnv.sqlQuery(<span class="string">&quot;select id, count(id) as cnt, avg(temp) as avgTemp from inputTable group by id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.输出到文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5-1.连接外部文件，注册输出表</span></span><br><span class="line">        String outputPath = <span class="string">&quot;src/main/resources/out.txt&quot;</span>;</span><br><span class="line">        tableEnv.connect(<span class="keyword">new</span> FileSystem().path(outputPath))<span class="comment">// 连接器的描述器</span></span><br><span class="line">                .withFormat(<span class="keyword">new</span> Csv())<span class="comment">// 格式化</span></span><br><span class="line">                .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                        .field(<span class="string">&quot;temperature&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">                )<span class="comment">// 定义表结构，注意：表结构的内容，应和前面创建的表的字段的顺序一一对应，字段名可以不相同</span></span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;outputTable&quot;</span>);<span class="comment">// 注册表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5-2.写出到外部文件</span></span><br><span class="line">        <span class="comment">// 注意：aggTable或sqlAggTable不支持往外部文件写入，因为外部文件写入只能追加数据，</span></span><br><span class="line">        <span class="comment">// 而aggTable或sqlAggTable存在数据更新，无法操控文件把旧数据删除再更新为新数据</span></span><br><span class="line">        resultTable.executeInsert(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务，使用executeInsert()后，不需要再次执行execute()</span></span><br><span class="line">        <span class="comment">// env.execute();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/main/resources/sensor.txt</code></p>
</blockquote>
</li>
<li><p>输出文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensor_6,15.4</span><br><span class="line">sensor_6,15.3</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>src/main/resources/out.txt</code></p>
</blockquote>
</li>
</ul>
<h4 id="对接-Kafka"><a href="#对接-Kafka" class="headerlink" title="对接 Kafka"></a>对接 Kafka</h4><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest4_KafkaPipeLine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.连接Kafka，读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-1.创建表</span></span><br><span class="line">        tableEnv</span><br><span class="line">                .connect(<span class="keyword">new</span> Kafka()</span><br><span class="line">                        .version(<span class="string">&quot;2.3&quot;</span>)</span><br><span class="line">                        .topic(<span class="string">&quot;sensor&quot;</span>)</span><br><span class="line">                        .property(<span class="string">&quot;zookeeper.connect&quot;</span>, <span class="string">&quot;localhost:2181&quot;</span>)</span><br><span class="line">                        .property(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .withFormat(<span class="keyword">new</span> Csv())</span><br><span class="line">                .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                        .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">                        .field(<span class="string">&quot;temp&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">                )</span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3-2.获取注册的表</span></span><br><span class="line">        Table sensorTable = tableEnv.from(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.查询转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4-1.简单转换</span></span><br><span class="line">        Table resultTable = sensorTable.select(<span class="string">&quot;id, temp&quot;</span>)</span><br><span class="line">                .filter(<span class="string">&quot;id === &#x27;sensor_6&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4-2.聚合统计</span></span><br><span class="line">        Table aggTable = sensorTable.groupBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id, id.count as count, temp.avg as avgTemp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.建立Kafka连接，输出到不同的topic下</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5-1.创建表</span></span><br><span class="line">        tableEnv</span><br><span class="line">                .connect(<span class="keyword">new</span> Kafka()</span><br><span class="line">                        .version(<span class="string">&quot;2.3&quot;</span>)</span><br><span class="line">                        .topic(<span class="string">&quot;sinkTest&quot;</span>)</span><br><span class="line">                        .property(<span class="string">&quot;zookeeper.connect&quot;</span>, <span class="string">&quot;localhost:2181&quot;</span>)</span><br><span class="line">                        .property(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .withFormat(<span class="keyword">new</span> Csv())</span><br><span class="line">                .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                        .field(<span class="string">&quot;temp&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">                )</span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5-2.输出到Kafka</span></span><br><span class="line">        <span class="comment">// 注意：aggTable或sqlAggTable也不支持往Kafka写入</span></span><br><span class="line">        resultTable.executeInsert(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="对接-ES"><a href="#对接-ES" class="headerlink" title="对接 ES"></a>对接 ES</h4><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tableEnv</span><br><span class="line">        .connect(</span><br><span class="line">                <span class="keyword">new</span> Elasticsearch()</span><br><span class="line">                        .version(<span class="string">&quot;6&quot;</span>)</span><br><span class="line">                        .host(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)</span><br><span class="line">                        .index(<span class="string">&quot;sensor&quot;</span>)</span><br><span class="line">                        .documentType(<span class="string">&quot;temp&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">        .inUpsertMode()</span><br><span class="line">        .withFormat(<span class="keyword">new</span> Json())</span><br><span class="line">        .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                .field(<span class="string">&quot;count&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">        )</span><br><span class="line">        .createTemporaryTable(<span class="string">&quot;esOutputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">aggTable.executeInsert(<span class="string">&quot;esOutputTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Json (<code>org.apache.flink.table.descriptors.Json</code>) 需要添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="对接-MySQL"><a href="#对接-MySQL" class="headerlink" title="对接 MySQL"></a>对接 MySQL</h4><ul>
<li><p>引入 MySQL 连接器依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-jdbc_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String sinkDDL =</span><br><span class="line">        <span class="string">&quot;create table jdbcOutputTable (&quot;</span> +</span><br><span class="line">                <span class="string">&quot; id varchar(20) not null, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; cnt bigint not null &quot;</span> +</span><br><span class="line">                <span class="string">&quot;) with (&quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.type&#x27; = &#x27;jdbc&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.url&#x27; = &#x27;jdbc:mysql://localhost:3306/test&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.table&#x27; = &#x27;sensor_count&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.driver&#x27; = &#x27;com.mysql.jdbc.Driver&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.username&#x27; = &#x27;root&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.password&#x27; = &#x27;123456&#x27; )&quot;</span>;</span><br><span class="line"></span><br><span class="line">tableEnv.sqlUpdate(sinkDDL);<span class="comment">// 执行DDL创建表</span></span><br><span class="line"></span><br><span class="line">aggResultSqlTable.insertInto(<span class="string">&quot;jdbcOutputTable&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="将表转换成-DataStream"><a href="#将表转换成-DataStream" class="headerlink" title="将表转换成 DataStream"></a>将表转换成 DataStream</h4><ul>
<li><p>表可以转换为 DataStream 或 DataSet ，这样自定义流处理或批处理程序就可以继续在 Table API 或 SQL 查询的结果上运行了。</p>
</li>
<li><p>将表转换为 DataStream 或 DataSet 时，需要指定生成的数据类型，即要将表的每一行转换成的数据类型。</p>
</li>
<li><p>表作为流式查询的结果，是动态更新的。</p>
</li>
<li><p>转换有两种转换模式：追加 (Append) 模式和撤回 (Retract) 模式。</p>
<ul>
<li><p>追加模式 (Append Mode)</p>
<ul>
<li><p>用于表只会被插入 (Insert) 操作更改的场景。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Row&gt; resultStream = tableEnv.toAppendStream(resultTable, Row.class);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>撤回模式 (Retract Mode)</p>
<ul>
<li><p>用于任何场景。类似于更新模式中的 Retract 模式，它只有 Insert 和 Delete 两类操作。</p>
</li>
<li><p>得到的数据会增加一个 Boolean 类型的标识位 (返回的第一个字段)，用它来表示到底是新增的数据 (Insert)，还是被删除的数据 (Delete)。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; aggResultStream = tableEnv.toRetractStream(aggResultTable, Row.class);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="将-DataStream-转换成表"><a href="#将-DataStream-转换成表" class="headerlink" title="将 DataStream 转换成表"></a>将 DataStream 转换成表</h4><ul>
<li><p>对于一个 DataStream，可以直接转换成 Table，进而方便地调用 Table API 做转换操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; dataStream = ...</span><br><span class="line">Table sensorTable = tableEnv.fromDataStream(dataStream);</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认转换后的 Table schema 和 DataStream 中的字段定义一一对应，也可以单独指定出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; dataStream = ...</span><br><span class="line">Table sensorTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, timestamp as ts, temperature&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="创建临时视图-Temporary-View"><a href="#创建临时视图-Temporary-View" class="headerlink" title="创建临时视图 (Temporary View)"></a>创建临时视图 (Temporary View)</h4><ul>
<li><p>基于 DataStream 创建临时视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;sensorView&quot;</span>, dataStream);</span><br><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;sensorView&quot;</span>, dataStream, <span class="string">&quot;id, temperature, timestamp as ts&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 Table 创建临时视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;sensorView&quot;</span>, sensorTable);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h4><ul>
<li><p>Table API 提供了一种机制来解释计算表的逻辑和优化查询计划。</p>
</li>
<li><p>查看执行计划，可以通过 <code>TableEnvironment.explain(table)</code> 方法或 <code>TableEnvironment.explain()</code> 方法完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String explaination = tableEnv.explain(resultTable);</span><br><span class="line">System.out.println(explaination);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法返回一个字符串，描述三个计划：</p>
<ul>
<li>优化的逻辑查询计划</li>
<li>优化后的逻辑查询计划</li>
<li>实际执行计划</li>
</ul>
</li>
</ul>
<h3 id="流处理和关系代数的区别"><a href="#流处理和关系代数的区别" class="headerlink" title="流处理和关系代数的区别"></a>流处理和关系代数的区别</h3><table>
<thead>
<tr>
<th></th>
<th>关系代数 (表)/SQL</th>
<th>流处理</th>
</tr>
</thead>
<tbody><tr>
<td>处理的数据对象</td>
<td>字段元组的有界集合</td>
<td>字段元组的无限序列</td>
</tr>
<tr>
<td>查询 (Query) 对数据的访问</td>
<td>可以访问到完整的数据输入</td>
<td>无法访问所有数据，必须持续 “等待” 流式输入</td>
</tr>
<tr>
<td>查询终止条件</td>
<td>生成固定大小的结果集后终止</td>
<td>永不停止，根据持续收到的数据不断更新查询结果</td>
</tr>
</tbody></table>
<h3 id="动态表-Dynamic-Tables"><a href="#动态表-Dynamic-Tables" class="headerlink" title="动态表 (Dynamic Tables)"></a>动态表 (Dynamic Tables)</h3><ul>
<li><p>动态表是 Flink 对流数据的 Table API 和 SQL 支持的核心概念。</p>
</li>
<li><p>与表示批处理数据的静态表不同，动态表是随时间变化的。</p>
</li>
<li><p>动态表可以像静态的批处理表一样进行查询，查询一个动态表会产生持续查询 (Continuous Query)。</p>
</li>
<li><p>持续查询永远不会终止，并会生成另一个动态结果表。</p>
</li>
<li><p>持续查询会不断更新其动态结果表，以反映其动态输入表上的更改。</p>
</li>
<li><p>流式表查询 (持续查询) 的处理过程：</p>
<p><img src="/2021/04/25/flink/image-20210819163456431.png" alt="image-20210819163456431"></p>
<ul>
<li>第一步：流被转换为动态表。</li>
<li>第二步：对动态表计算连续查询，生成新的动态表。</li>
<li>第三步：生成的动态表被转换回流。</li>
</ul>
</li>
</ul>
<h4 id="将流转换成动态表"><a href="#将流转换成动态表" class="headerlink" title="将流转换成动态表"></a>将流转换成动态表</h4><ul>
<li><p>为了处理带有关系查询的流，必须先将其转换为表。</p>
</li>
<li><p>从概念上讲，流的每个数据记录，都被解释为对结果表的插入 (Insert) 修改操作：</p>
<p><img src="/2021/04/25/flink/image-20210819164346348.png" alt="image-20210819164346348"></p>
</li>
</ul>
<h4 id="持续查询"><a href="#持续查询" class="headerlink" title="持续查询"></a>持续查询</h4><ul>
<li><p>持续查询会在动态表上做计算处理，并作为结果生成新的动态表：</p>
<p><img src="/2021/04/25/flink/image-20210819164659342.png" alt="image-20210819164659342"></p>
</li>
</ul>
<h4 id="将动态表转换成-DataStream"><a href="#将动态表转换成-DataStream" class="headerlink" title="将动态表转换成 DataStream"></a>将动态表转换成 DataStream</h4><ul>
<li><p>与常规的数据库表一样，动态表可以通过插入 (Insert)、更新 (Update) 和删除 (Delete) 操作，进行持续的修改。</p>
</li>
<li><p>将动态表转换为流或将其写入外部系统时，需要对这些操作进行编码。</p>
<ul>
<li><p>仅追加 (Append-only) 流</p>
<ul>
<li>仅通过插入 (Insert) 更改来修改的动态表，可以直接转换为仅追加流。</li>
</ul>
</li>
<li><p>撤回 (Retract) 流</p>
<ul>
<li><p>撤回流是包含两类消息的流：添加 (Add) 消息和撤回 (Retract) 消息。</p>
<p><img src="/2021/04/25/flink/image-20210819165853317.png" alt="image-20210819165853317"></p>
</li>
</ul>
</li>
<li><p>更新插入 (Upsert) 流</p>
<ul>
<li><p>Upsert 流也包含两种类型的消息：Upsert 消息和删除 (Delete) 消息。</p>
<p><img src="/2021/04/25/flink/image-20210819170050982.png" alt="image-20210819170050982"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="时间特性-Time-Attributes"><a href="#时间特性-Time-Attributes" class="headerlink" title="时间特性 (Time Attributes)"></a>时间特性 (Time Attributes)</h3><ul>
<li>基于时间的操作 (比如 Table API 和 SQL 中窗口操作)，需要定义相关的时间语义和时间数据来源的信息。</li>
<li>Table 可以提供一个逻辑上的时间字段，用于在表处理程序中，指示时间和访问相应的时间戳。</li>
<li>时间属性，可以是每个表 Schema 的一部分。一旦定义了时间属性，它就可以作为一个字段引用，并且可以在基于时间的操作中使用。</li>
<li>时间属性的行为类似于常规时间戳，可以访问，并且进行计算。</li>
</ul>
<h4 id="定义处理时间-Processing-Time"><a href="#定义处理时间-Processing-Time" class="headerlink" title="定义处理时间 (Processing Time)"></a>定义处理时间 (Processing Time)</h4><ul>
<li><p>处理时间语义下，允许表处理程序根据机器的本地时间生成结果。它是时间的最简单概念。它既不需要提取时间戳，也不需要生成 Watermark。</p>
</li>
<li><p>定义处理时间，有三种方法。</p>
</li>
<li><p>方式一：由 DataStream 转换成表时指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table sensorTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, temperature, timestamp, pt.proctime&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在定义 Schema 时，可以使用 .proctime，指定字段名 (如示例中的 pt 字段) 定义处理时间字段。</p>
</li>
<li><p>这个 proctime 属性只能通过附加逻辑字段，来扩展物理 Schema。因此，只能在 Schema 定义的末尾定义它。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest6_TimeAndWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 读入文件数据，得到DataStream</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转换成POJO</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将流转换成表，并定义时间特性，字段名pt自定义，不可与sql关键字冲突，pt是时间戳类型，精确到毫秒</span></span><br><span class="line">        Table dataTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, timestamp as ts, temperature as temp, pt.proctime&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.转换成流输出</span></span><br><span class="line">        dataTable.printSchema();</span><br><span class="line">        tableEnv.toAppendStream(dataTable, Row.class).print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">root</span></span><br><span class="line"><span class="function"> |-- id: STRING</span></span><br><span class="line"><span class="function"> |-- ts: BIGINT</span></span><br><span class="line"><span class="function"> |-- temp: DOUBLE</span></span><br><span class="line"><span class="function"> |-- pt: <span class="title">TIMESTAMP</span><span class="params">(<span class="number">3</span>)</span> *PROCTIME*</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">sensor_1,1547718199,35.8,2021-08-20T02:40:18.998</span></span><br><span class="line"><span class="function">sensor_6,1547718201,15.4,2021-08-20T02:40:19.002</span></span><br><span class="line"><span class="function">sensor_7,1547718202,6.7,2021-08-20T02:40:19.002</span></span><br><span class="line"><span class="function">sensor_10,1547718205,38.1,2021-08-20T02:40:19.002</span></span><br><span class="line"><span class="function">sensor_1,1547718206,36.3,2021-08-20T02:40:19.002</span></span><br><span class="line"><span class="function">sensor_1,1547718210,34.7,2021-08-20T02:40:19.002</span></span><br><span class="line"><span class="function">sensor_1,1547718212,33.1,2021-08-20T02:40:19.002</span></span><br><span class="line"><span class="function">sensor_6,1547718212,15.3,2021-08-20T02:40:19.002</span></span><br><span class="line"><span class="function">sensor_7,1547718212,6.3,2021-08-20T02:40:19.003</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方式二：定义 Table Schema 时指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">    .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">    .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">    .field(<span class="string">&quot;temperature&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">    .field(<span class="string">&quot;pt&quot;</span>, DataTypes.TIMESTAMP(<span class="number">3</span>))</span><br><span class="line">    .proctime()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：在创建表的 DDL 中定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String sinkDDL =</span><br><span class="line">        <span class="string">&quot;create table dataTable (&quot;</span> +</span><br><span class="line">                <span class="string">&quot; id varchar(20) not null, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; ts bigint, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; temperature double, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; pt AS PROCTIME() &quot;</span> +</span><br><span class="line">                <span class="string">&quot;) with (&quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.type&#x27; = &#x27;filesystem&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.path&#x27; = &#x27;/sensor.txt&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;format.type&#x27; = &#x27;csv&#x27;)&quot;</span>;</span><br><span class="line">tableEnv.sqlUpdate(sinkDDL);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="定义事件时间-Event-Time"><a href="#定义事件时间-Event-Time" class="headerlink" title="定义事件时间 (Event Time)"></a>定义事件时间 (Event Time)</h4><ul>
<li><p>事件时间语义下，允许表处理程序根据每个记录中包含的时间生成结果。这样即使在有乱序事件或者延迟事件时，也可以获得正确的结果。</p>
</li>
<li><p>为了处理无序事件，并区分流中的准时和迟到事件；Flink 需要从事件数据中，提取时间戳，并用来推进事件时间的进展。</p>
</li>
<li><p>定义事件时间，同样有三种方法。</p>
</li>
<li><p>方式一：由 DataStream 转换成表时指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将DataStream转换为Table，并指定时间字段</span></span><br><span class="line">Table sensorTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, timestamp.rowtime, temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，直接追加时间字段</span></span><br><span class="line">Table sensorTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, temperature, timestamp, rt.rowtime&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 DataStream 转换成 Table，使用 .rowtime 可以定义事件时间属性。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest6_TimeAndWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定事件时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 读入文件数据，得到DataStream</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转换成POJO，并设置Watermark为2s延迟</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream</span><br><span class="line">                .map(line -&gt; &#123;</span><br><span class="line">                    String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">                &#125;)</span><br><span class="line">                .assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> sensorReading.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将流转换成表</span></span><br><span class="line">        <span class="comment">// 方式一：指定数据的timestamp属性为事件时间，数据的timestamp属性会被覆盖重写</span></span><br><span class="line">        Table dataTable1 = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, timestamp.rowtime as ts, temperature as temp&quot;</span>);</span><br><span class="line">        <span class="comment">// 方式二：追加一个新的字段，数据的原有属性不做变化</span></span><br><span class="line">        Table dataTable2 = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, temperature, timestamp, rt.rowtime&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.转换成流输出</span></span><br><span class="line">        dataTable1.printSchema();</span><br><span class="line">        tableEnv.toAppendStream(dataTable1, Row.class).print();</span><br><span class="line">        </span><br><span class="line">        dataTable2.printSchema();</span><br><span class="line">        tableEnv.toAppendStream(dataTable2, Row.class).print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<ul>
<li><p>覆盖数据的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">root</span></span><br><span class="line"><span class="function"> |-- id: STRING</span></span><br><span class="line"><span class="function"> |-- ts: <span class="title">TIMESTAMP</span><span class="params">(<span class="number">3</span>)</span> *ROWTIME*</span></span><br><span class="line"><span class="function"> |-- temp: DOUBLE</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">sensor_1,2019-01-17T09:43:19,35.8</span></span><br><span class="line"><span class="function">sensor_6,2019-01-17T09:43:21,15.4</span></span><br><span class="line"><span class="function">sensor_7,2019-01-17T09:43:22,6.7</span></span><br><span class="line"><span class="function">sensor_10,2019-01-17T09:43:25,38.1</span></span><br><span class="line"><span class="function">sensor_1,2019-01-17T09:43:26,36.3</span></span><br><span class="line"><span class="function">sensor_1,2019-01-17T09:43:30,34.7</span></span><br><span class="line"><span class="function">sensor_1,2019-01-17T09:43:32,33.1</span></span><br><span class="line"><span class="function">sensor_6,2019-01-17T09:43:32,15.3</span></span><br><span class="line"><span class="function">sensor_7,2019-01-17T09:43:32,6.3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>追加新的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">root</span></span><br><span class="line"><span class="function"> |-- id: STRING</span></span><br><span class="line"><span class="function"> |-- temperature: DOUBLE</span></span><br><span class="line"><span class="function"> |-- timestamp: BIGINT</span></span><br><span class="line"><span class="function"> |-- rt: <span class="title">TIMESTAMP</span><span class="params">(<span class="number">3</span>)</span> *ROWTIME*</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">sensor_1,35.8,1547718199,2019-01-17T09:43:19</span></span><br><span class="line"><span class="function">sensor_6,15.4,1547718201,2019-01-17T09:43:21</span></span><br><span class="line"><span class="function">sensor_7,6.7,1547718202,2019-01-17T09:43:22</span></span><br><span class="line"><span class="function">sensor_10,38.1,1547718205,2019-01-17T09:43:25</span></span><br><span class="line"><span class="function">sensor_1,36.3,1547718206,2019-01-17T09:43:26</span></span><br><span class="line"><span class="function">sensor_1,34.7,1547718210,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">sensor_1,33.1,1547718212,2019-01-17T09:43:32</span></span><br><span class="line"><span class="function">sensor_6,15.3,1547718212,2019-01-17T09:43:32</span></span><br><span class="line"><span class="function">sensor_7,6.3,1547718212,2019-01-17T09:43:32</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方式二：定义 Table Schema 时指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">        .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">        .rowtime(</span><br><span class="line">                <span class="keyword">new</span> Rowtime()</span><br><span class="line">                        .timestampsFromField(<span class="string">&quot;timestamp&quot;</span>)<span class="comment">// 从字段中提取时间戳</span></span><br><span class="line">                        .watermarksPeriodicBounded(<span class="number">1000</span>)<span class="comment">// Watermark延迟1秒</span></span><br><span class="line">        )</span><br><span class="line">        .field(<span class="string">&quot;temperature&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：在创建表的 DDL 中定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String sinkDDL =</span><br><span class="line">        <span class="string">&quot;create table dataTable (&quot;</span> +</span><br><span class="line">                <span class="string">&quot; id varchar(20) not null, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; ts bigint, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; temperature double, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; rt AS TO_TIMESTAMP( FROM_UNIXTIME(ts) ), &quot;</span> +</span><br><span class="line">                <span class="string">&quot; watermark for rt as rt - interval &#x27;1&#x27; second&quot;</span> +</span><br><span class="line">                <span class="string">&quot;) with (&quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.type&#x27; = &#x27;filesystem&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;connector.path&#x27; = &#x27;/sensor.txt&#x27;, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; &#x27;format.type&#x27; = &#x27;csv&#x27;)&quot;</span>;</span><br><span class="line">tableEnv.sqlUpdate(sinkDDL);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><ul>
<li>时间语义，要配合窗口操作才能发挥作用。</li>
<li>在 Table API 和 SQL 中，主要有两种窗口：<ul>
<li>Group Windows (分组窗口)<ul>
<li>根据时间或行计数间隔，将行聚合到有限的组 (Group) 中，并对每个组的数据执行一次聚合函数。</li>
</ul>
</li>
<li>Over Windows<ul>
<li>针对每个输入行，计算相邻行范围内的聚合。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Group-Windows"><a href="#Group-Windows" class="headerlink" title="Group Windows"></a>Group Windows</h4><ul>
<li><p>Group Windows 是使用 <code>.window(w:GroupWindow)</code>子句定义的，并且必须由 as 为子句指定一个别名。</p>
</li>
<li><p>为了按窗口对表进行分组，窗口的别名必须在 group by 子句中，像常规的分组字段一样引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table table = input</span><br><span class="line">        .window([w: GroupWindow] as <span class="string">&quot;w&quot;</span>)<span class="comment">// 定义窗口，别名为w</span></span><br><span class="line">        .groupBy(<span class="string">&quot;w, a&quot;</span>)<span class="comment">// 按照字段a和窗口w分组</span></span><br><span class="line">        .select(<span class="string">&quot;a, b.sum&quot;</span>);<span class="comment">// 聚合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Table API 提供了一组具有特定语义的预定义 Window 类，这些类会被转换为底层 DataStream 或 DataSet 的窗口操作。</p>
</li>
</ul>
<h5 id="滚动窗口-Tumbling-windows"><a href="#滚动窗口-Tumbling-windows" class="headerlink" title="滚动窗口 (Tumbling windows)"></a>滚动窗口 (Tumbling windows)</h5><ul>
<li><p>滚动窗口要用 Tumble 类来定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tumbling Event-time Window</span></span><br><span class="line">.window(Tumble.over(<span class="string">&quot;10.minutes&quot;</span>).on(<span class="string">&quot;rowtime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))<span class="comment">// 10min的滚动窗口，事件时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Tumbling Processing-time Window</span></span><br><span class="line">.window(Tumble.over(<span class="string">&quot;10.minutes&quot;</span>).on(<span class="string">&quot;proctime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))<span class="comment">// 10min的滚动窗口，处理时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Tumbling Row-count Window</span></span><br><span class="line">.window(Tumble.over(<span class="string">&quot;10.rows&quot;</span>).on(<span class="string">&quot;proctime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))<span class="comment">// 计数窗口，10个数据一行，处理时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest6_TimeAndWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定事件时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 读入文件数据，得到DataStream</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转换成POJO，并设置Watermark为2s延迟</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream</span><br><span class="line">                .map(line -&gt; &#123;</span><br><span class="line">                    String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">                &#125;)</span><br><span class="line">                .assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> sensorReading.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将流转换成表</span></span><br><span class="line">        <span class="comment">// 方式一：指定数据的timestamp属性为事件时间，数据的timestamp属性会被覆盖重写</span></span><br><span class="line"><span class="comment">//        Table dataTable = tableEnv.fromDataStream(dataStream, &quot;id, timestamp.rowtime as ts, temperature as temp&quot;);</span></span><br><span class="line">        <span class="comment">// 方式二：追加一个新的字段</span></span><br><span class="line">        Table dataTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, temperature as temp, timestamp as ts, rt.rowtime&quot;</span>);</span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, dataTable);<span class="comment">// 注册表，在SQL中用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.窗口操作</span></span><br><span class="line">        <span class="comment">// 6-1.Group Window</span></span><br><span class="line">        <span class="comment">// Table API写法</span></span><br><span class="line">        Table resultTable = dataTable.window(Tumble.over(<span class="string">&quot;10.seconds&quot;</span>).on(<span class="string">&quot;rt&quot;</span>).as(<span class="string">&quot;tw&quot;</span>))</span><br><span class="line">                .groupBy(<span class="string">&quot;id, tw&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id, id.count, temp.avg, tw.end&quot;</span>);<span class="comment">// id, 当前id数据个数，温度平均值，开窗结束时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SQL写法</span></span><br><span class="line">        Table resultSqlTable = tableEnv.sqlQuery(<span class="string">&quot;select id, count(id) as cnt, avg(temp) as avgTemp, tumble_end(rt, interval &#x27;10&#x27; second) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;from sensor group by id, tumble(rt, interval &#x27;10&#x27; second)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.转换成流输出</span></span><br><span class="line">        tableEnv.toAppendStream(resultTable, Row.class).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        tableEnv.toAppendStream(resultSqlTable, Row.class).print(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">result&gt; sensor_1,1,35.8,2019-01-17T09:43:20</span></span><br><span class="line"><span class="function">result&gt; sensor_6,1,15.4,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1,35.8,2019-01-17T09:43:20</span></span><br><span class="line"><span class="function">result&gt; sensor_10,1,38.1,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,1,15.4,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1,36.3,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">result&gt; sensor_7,1,6.7,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">result&gt; sensor_7,1,6.3,2019-01-17T09:43:40</span></span><br><span class="line"><span class="function">result&gt; sensor_6,1,15.3,2019-01-17T09:43:40</span></span><br><span class="line"><span class="function">result&gt; sensor_1,2,33.900000000000006,2019-01-17T09:43:40</span></span><br><span class="line"><span class="function">sql&gt; sensor_10,1,38.1,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1,36.3,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,1,6.7,2019-01-17T09:43:30</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,1,6.3,2019-01-17T09:43:40</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,1,15.3,2019-01-17T09:43:40</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,2,33.900000000000006,2019-01-17T09:43:40</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="滑动窗口-Sliding-windows"><a href="#滑动窗口-Sliding-windows" class="headerlink" title="滑动窗口 (Sliding windows)"></a>滑动窗口 (Sliding windows)</h5><ul>
<li><p>滑动窗口要用 Slide 类来定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sliding Event-time Window</span></span><br><span class="line">.window(Slide.over(<span class="string">&quot;10.minutes&quot;</span>).every(<span class="string">&quot;5.minutes&quot;</span>).on(<span class="string">&quot;rowtime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))<span class="comment">// 10min的滑动窗口，滑动步长5min，事件时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Sliding Processing-time window</span></span><br><span class="line">.window(Slide.over(<span class="string">&quot;10.minutes&quot;</span>).every(<span class="string">&quot;5.minutes&quot;</span>).on(<span class="string">&quot;proctime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))<span class="comment">// 10min的滑动窗口，滑动步长5min，处理时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Sliding Row-count window</span></span><br><span class="line">.window(Slide.over(<span class="string">&quot;10.rows&quot;</span>).every(<span class="string">&quot;5.rows&quot;</span>).on(<span class="string">&quot;proctime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))<span class="comment">// 计数窗口，10个数据一行，5个数据一滑动，处理时间</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="会话窗口（Session-windows）"><a href="#会话窗口（Session-windows）" class="headerlink" title="会话窗口（Session windows）"></a>会话窗口（Session windows）</h5><ul>
<li><p>会话窗口要用 Session 类来定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Session Event-time Window</span></span><br><span class="line">.window(Session.withGap(<span class="string">&quot;10.minutes&quot;</span>).on(<span class="string">&quot;rowtime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))<span class="comment">// Session时长10min，事件时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Session Processing-time Window</span></span><br><span class="line">.window(Session.withGap(<span class="string">&quot;10.minutes&quot;</span>).on(<span class="string">&quot;proctime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))<span class="comment">// Session时长10min，处理时间</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="SQL-中的-Group-Windows"><a href="#SQL-中的-Group-Windows" class="headerlink" title="SQL 中的 Group Windows"></a>SQL 中的 Group Windows</h5><ul>
<li>Group Windows 定义在 SQL 查询的 Group By 子句中。</li>
<li><code>TUMBLE(time_attr, interval)</code><ul>
<li>定义一个滚动窗口，第一个参数是时间字段，第二个参数是窗口长度。</li>
</ul>
</li>
<li><code>HOP(time_attr, interval, interval)</code><ul>
<li>定义一个滑动窗口，第一个参数是时间字段，第二4 个参数是窗口滑动步长，第三个是窗口长度。</li>
</ul>
</li>
<li><code>SESSION(time_attr, interval)</code><ul>
<li>定义一个会话窗口，第一个参数是时间字段，第二个参数是窗口间隔。</li>
</ul>
</li>
</ul>
<h4 id="Over-Windows"><a href="#Over-Windows" class="headerlink" title="Over Windows"></a>Over Windows</h4><ul>
<li><p>Over Windows 聚合是标准 SQL 中已有的 (over 子句)，可以在查询的 SELECT 子句中定义。</p>
</li>
<li><p>Over Windows 聚合，会针对每个输入行，计算相邻行范围内的聚合。</p>
</li>
<li><p>Over Windows 使用 <code>.window(w:overwindows)</code> 子句定义，并在 <code>select()</code> 中通过别名来引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Table table = input</span><br><span class="line">        .window([w: OverWindow] as <span class="string">&quot;w&quot;</span>)<span class="comment">// 定义窗口，别名为w</span></span><br><span class="line">        .select(<span class="string">&quot;a, b.sum over w, c.min over w&quot;</span>);<span class="comment">// 聚合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Table API 提供了 Over 类，来配置 Over 窗口的属性。</p>
</li>
</ul>
<h5 id="无界-Over-Windows"><a href="#无界-Over-Windows" class="headerlink" title="无界 Over Windows"></a>无界 Over Windows</h5><ul>
<li><p>可以在事件时间或处理时间，以及指定为时间间隔、或行计数的范围内，定义 Over Windows。</p>
</li>
<li><p>无界的 Over Windows 是使用常量指定的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无界的事件时间Over Window</span></span><br><span class="line">.window(Over.partitionBy(<span class="string">&quot;a&quot;</span>).orderBy(<span class="string">&quot;rowtime&quot;</span>).preceding(UNBOUNDED_RANGE).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界的处理时间Over Window</span></span><br><span class="line">.window(Over.partitionBy(<span class="string">&quot;a&quot;</span>).orderBy(<span class="string">&quot;proctime&quot;</span>).preceding(UNBOUNDED_RANGE).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界的事件时间Row-count Over Window</span></span><br><span class="line">.window(Over.partitionBy(<span class="string">&quot;a&quot;</span>).orderBy(<span class="string">&quot;rowtime&quot;</span>).preceding(UNBOUNDED_ROW).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界的处理时间Row-count Over Window</span></span><br><span class="line">.window(Over.partitionBy(<span class="string">&quot;a&quot;</span>).orderBy(<span class="string">&quot;proctime&quot;</span>).preceding(UNBOUNDED_ROW).as(<span class="string">&quot;w&quot;</span>))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="有界-Over-Windows"><a href="#有界-Over-Windows" class="headerlink" title="有界 Over Windows"></a>有界 Over Windows</h5><ul>
<li><p>有界的 Over Windows 是用间隔的大小指定的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有界的事件时间Over Window</span></span><br><span class="line">.window(Over.partitionBy(<span class="string">&quot;a&quot;</span>).orderBy(<span class="string">&quot;rowtime&quot;</span>).preceding(<span class="string">&quot;1.minutes&quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有界的处理时间Over Window</span></span><br><span class="line">.window(Over.partitionBy(<span class="string">&quot;a&quot;</span>).orderBy(<span class="string">&quot;proctime&quot;</span>).preceding(<span class="string">&quot;1.minutes&quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有界的事件时间Row-count Over Window</span></span><br><span class="line">.window(Over.partitionBy(<span class="string">&quot;a&quot;</span>).orderBy(<span class="string">&quot;rowtime&quot;</span>).preceding(<span class="string">&quot;10.rows&quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有界的处理时间Row-count Over Window</span></span><br><span class="line">.window(Over.partitionBy(<span class="string">&quot;a&quot;</span>).orderBy(<span class="string">&quot;procime&quot;</span>).preceding(<span class="string">&quot;10.rows&quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableTest6_TimeAndWindow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定事件时间语义</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 读入文件数据，得到DataStream</span></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转换成POJO，并设置Watermark为2s延迟</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream</span><br><span class="line">                .map(line -&gt; &#123;</span><br><span class="line">                    String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">                &#125;)</span><br><span class="line">                .assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading sensorReading)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> sensorReading.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将流转换成表</span></span><br><span class="line">        <span class="comment">// 方式一：指定数据的timestamp属性为事件时间，数据的timestamp属性会被覆盖重写</span></span><br><span class="line"><span class="comment">//        Table dataTable = tableEnv.fromDataStream(dataStream, &quot;id, timestamp.rowtime as ts, temperature as temp&quot;);</span></span><br><span class="line">        <span class="comment">// 方式二：追加一个新的字段</span></span><br><span class="line">        Table dataTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, temperature as temp, timestamp as ts, rt.rowtime&quot;</span>);</span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, dataTable);<span class="comment">// 注册表，在SQL中用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.窗口操作</span></span><br><span class="line">        <span class="comment">// 6-2.Over Window</span></span><br><span class="line">        <span class="comment">// Table API写法</span></span><br><span class="line">        Table overResultTable = dataTable.window(Over.partitionBy(<span class="string">&quot;id&quot;</span>).orderBy(<span class="string">&quot;rt&quot;</span>).preceding(<span class="string">&quot;2.rows&quot;</span>).as(<span class="string">&quot;ow&quot;</span>))</span><br><span class="line">                .select(<span class="string">&quot;id, rt, id.count over ow, temp.avg over ow&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SQL写法</span></span><br><span class="line">        Table overSqlResultTable = tableEnv.sqlQuery(<span class="string">&quot;select id, rt, count(id) over ow, avg(temp) over ow &quot;</span> +</span><br><span class="line">                <span class="string">&quot; from sensor &quot;</span> +</span><br><span class="line">                <span class="string">&quot; window ow as (partition by id order by rt rows between 2 preceding and current row)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.转换成流输出</span></span><br><span class="line">        tableEnv.toAppendStream(overResultTable, Row.class).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        tableEnv.toAppendStream(overSqlResultTable, Row.class).print(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">result&gt; sensor_1,2019-01-17T09:43:19,1,35.8</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,2019-01-17T09:43:19,1,35.8</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,2019-01-17T09:43:21,1,15.4</span></span><br><span class="line"><span class="function">result&gt; sensor_6,2019-01-17T09:43:21,1,15.4</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,2019-01-17T09:43:22,1,6.7</span></span><br><span class="line"><span class="function">result&gt; sensor_7,2019-01-17T09:43:22,1,6.7</span></span><br><span class="line"><span class="function">sql&gt; sensor_10,2019-01-17T09:43:25,1,38.1</span></span><br><span class="line"><span class="function">result&gt; sensor_10,2019-01-17T09:43:25,1,38.1</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,2019-01-17T09:43:26,2,36.05</span></span><br><span class="line"><span class="function">result&gt; sensor_1,2019-01-17T09:43:26,2,36.05</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,2019-01-17T09:43:30,3,35.6</span></span><br><span class="line"><span class="function">result&gt; sensor_1,2019-01-17T09:43:30,3,35.6</span></span><br><span class="line"><span class="function">result&gt; sensor_7,2019-01-17T09:43:32,2,6.5</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,2019-01-17T09:43:32,2,6.5</span></span><br><span class="line"><span class="function">result&gt; sensor_1,2019-01-17T09:43:32,3,34.699999999999996</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,2019-01-17T09:43:32,3,34.699999999999996</span></span><br><span class="line"><span class="function">result&gt; sensor_6,2019-01-17T09:43:32,2,15.350000000000001</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,2019-01-17T09:43:32,2,15.350000000000001</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code </span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="SQL-中的-Over-Windows"><a href="#SQL-中的-Over-Windows" class="headerlink" title="SQL 中的 Over Windows"></a>SQL 中的 Over Windows</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">COUNT</span><span class="params">(amount)</span> <span class="title">OVER</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	PARTITION BY user</span></span></span><br><span class="line"><span class="function"><span class="params">	ORDER BY proctime</span></span></span><br><span class="line"><span class="function"><span class="params">	ROWS BETWEEN <span class="number">2</span> PRECEDING AND CURRENT ROW)</span></span></span><br><span class="line"><span class="function">FROM Orders</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用 Over 做窗口聚合时，所有聚合必须在同一窗口上定义，也就是说必须是相同的分区、排序和范围。</li>
<li>目前仅支持在当前行范围之前的窗口。</li>
<li>ORDER BY 必须在单一的时间属性上指定。</li>
</ul>
<h3 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 (Functions)"></a>函数 (Functions)</h3><ul>
<li><p>Flink Table API 和 SQL 为用户提供了一组用于数据转换的内置函数。</p>
</li>
<li><p>SQL 中支持的很多函数，Table API 和 SQL 都已经做了实现：</p>
<table>
<thead>
<tr>
<th></th>
<th>Table API</th>
<th>SQL</th>
</tr>
</thead>
<tbody><tr>
<td>比较函数</td>
<td><code>ANY1 === ANY2</code><br><code>ANY1 &gt; ANY2</code></td>
<td><code>value1 = value2</code><br><code>value1 &gt; value2</code></td>
</tr>
<tr>
<td>逻辑函数</td>
<td>`BOOLEAN1</td>
<td></td>
</tr>
<tr>
<td>算数函数</td>
<td><code>NUMERIC1 + NUMERIC2</code><br><code>NUMERIC1.power(NUMERIC2)</code></td>
<td><code>numeric1 + numeric2</code><br><code>POWER(numeric1, numeric2)</code></td>
</tr>
<tr>
<td>字符串函数</td>
<td><code>STRING1 + STRING2</code><br><code>STRING.upperCase()</code><br><code>STRING.charLength()</code></td>
<td>`string1</td>
</tr>
<tr>
<td>时间函数</td>
<td><code>STRING.toDate</code><br><code>STRING.toTimestamp</code><br><code>currentTime()</code><br><code>NUMERIC.days</code><br><code>NUMERIC.minutes</code></td>
<td><code>DATE string</code><br><code>TIMESTAMP string</code><br><code>CURRENT_TIME</code><br><code>INTERVAL string range</code></td>
</tr>
<tr>
<td>聚合函数</td>
<td><code>FIELD.count</code><br><code>FIELD.sum0</code></td>
<td><code>COUNT(*)</code><br><code>SUM(expression)</code><br><code>RANK()</code><br><code>ROW_NUMBER()</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="用户自定义函数-UDF"><a href="#用户自定义函数-UDF" class="headerlink" title="用户自定义函数 (UDF)"></a>用户自定义函数 (UDF)</h4><ul>
<li>用户定义函数 (User-defined Functions，UDF) 是一个重要的特性，它们显著地扩展了查询的表达能力。</li>
<li>在大多数情况下，用户定义的函数必须先注册，然后才能在查询中使用。</li>
<li>函数通过调用 <code>registerFunction()</code> 在 TableEnvironment 中注册。当用户定义的函数被注册时，它被插入到 TableEnvironment 的函数目录中，这样 Table API 或 SQL 解析器就可以识别并正确地解释它。</li>
</ul>
<h5 id="标量函数-Scalar-Functions"><a href="#标量函数-Scalar-Functions" class="headerlink" title="标量函数 (Scalar Functions)"></a>标量函数 (Scalar Functions)</h5><ul>
<li><p>用户定义的标量函数，可以将 0、1 或多个标量值，映射到新的标量值。</p>
</li>
<li><p>为了定义标量函数，必须在 <code>org.apache.flink.table.functions</code> 中扩展基类 Scalar Function，并实现 (一个或多个) 求值 (eval) 方法。</p>
</li>
<li><p>标量函数的行为由求值方法决定，求值方法必须公开声明并命名为 <code>eval()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCode</span> <span class="keyword">extends</span> <span class="title">ScalarFunction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> factor = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashCode</span><span class="params">(<span class="keyword">int</span> factor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factor = factor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eval</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.hashCode() * factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例：</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdfTest1_ScalarFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.转换成POJO</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.将流转换成表</span></span><br><span class="line">        Table sensorTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, timestamp as ts, temperature as temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.自定义标量函数，实现求id的hash值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-1.需要在环境中注册UDF</span></span><br><span class="line">        HashCode hashCode = <span class="keyword">new</span> HashCode(<span class="number">23</span>);<span class="comment">// 创建实例</span></span><br><span class="line">        tableEnv.registerFunction(<span class="string">&quot;hashCode&quot;</span>, hashCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-2.Table API写法</span></span><br><span class="line">        Table resultTable = sensorTable.select(<span class="string">&quot;id, ts, hashCode(id)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-3.SQL写法</span></span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, sensorTable);</span><br><span class="line">        Table resultSqlTable = tableEnv.sqlQuery(<span class="string">&quot;select id, ts, hashCode(id) from sensor&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.打印输出</span></span><br><span class="line">        tableEnv.toAppendStream(resultTable, Row.class).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        tableEnv.toAppendStream(resultSqlTable, Row.class).print(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义的ScalarFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCode</span> <span class="keyword">extends</span> <span class="title">ScalarFunction</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> factor = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashCode</span><span class="params">(<span class="keyword">int</span> factor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.factor = factor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须是public，方法名必须叫eval，其他按需自定义</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eval</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> str.hashCode() * factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718199,-1036124876</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718199,-1036124876</span></span><br><span class="line"><span class="function">result&gt; sensor_6,1547718201,-1036124761</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,1547718201,-1036124761</span></span><br><span class="line"><span class="function">result&gt; sensor_7,1547718202,-1036124738</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,1547718202,-1036124738</span></span><br><span class="line"><span class="function">result&gt; sensor_10,1547718205,-2055098980</span></span><br><span class="line"><span class="function">sql&gt; sensor_10,1547718205,-2055098980</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718206,-1036124876</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718206,-1036124876</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718210,-1036124876</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718210,-1036124876</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718212,-1036124876</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718212,-1036124876</span></span><br><span class="line"><span class="function">result&gt; sensor_6,1547718212,-1036124761</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,1547718212,-1036124761</span></span><br><span class="line"><span class="function">result&gt; sensor_7,1547718212,-1036124738</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,1547718212,-1036124738</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="表函数-Table-Functions"><a href="#表函数-Table-Functions" class="headerlink" title="表函数 (Table Functions)"></a>表函数 (Table Functions)</h5><ul>
<li><p>用户定义的表函数，也可以将 0、1 或多个标量值作为输入参数；与标量函数不同的是，它可以返回任意数量的行作为输出，而不是单个值。</p>
</li>
<li><p>为了定义一个表函数，必须扩展 <code>org.apache.flink.table.functions</code> 中的基类 TableFunction 并实现 (一个或多个) 求值方法。</p>
</li>
<li><p>表函数的行为由其求值方法决定，求值方法必须是 public 的，并命名为 <code>eval()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Split</span> <span class="keyword">extends</span> <span class="title">TableFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String separator = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Split</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.separator = separator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eval</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : str.split(separator)) &#123;</span><br><span class="line">            collect(<span class="keyword">new</span> Tuple2&lt;&gt;(s, s.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例：</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdfTest2_TableFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.转换成POJO</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.将流转换成表</span></span><br><span class="line">        Table sensorTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, timestamp as ts, temperature as temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.自定义表函数，实现将id拆分，并输出(word, length)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-1.需要在环境中注册UDF</span></span><br><span class="line">        Split split = <span class="keyword">new</span> Split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        tableEnv.registerFunction(<span class="string">&quot;split&quot;</span>, split);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-2.Table API写法</span></span><br><span class="line">        Table resultTable = sensorTable</span><br><span class="line">                .joinLateral(<span class="string">&quot;split(id) as (word, length)&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id, ts, word, length&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-3.SQL写法</span></span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, sensorTable);</span><br><span class="line">        Table resultSqlTable = tableEnv.sqlQuery(<span class="string">&quot;select id, ts, word, length &quot;</span> +</span><br><span class="line">                <span class="string">&quot; from sensor, lateral table(split(id)) as splitid(word, length)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.打印输出</span></span><br><span class="line">        tableEnv.toAppendStream(resultTable, Row.class).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        tableEnv.toAppendStream(resultSqlTable, Row.class).print(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义TableFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Split</span> <span class="keyword">extends</span> <span class="title">TableFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 定义属性，分隔符</span></span><br><span class="line">        <span class="keyword">private</span> String separator = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Split</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.separator = separator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须实现一个eval方法，没有返回值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eval</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : str.split(separator)) &#123;</span><br><span class="line">                collect(<span class="keyword">new</span> Tuple2&lt;&gt;(s, s.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;java</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718199,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718199,1,1</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718199,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718199,1,1</span></span><br><span class="line"><span class="function">result&gt; sensor_6,1547718201,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_6,1547718201,6,1</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,1547718201,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,1547718201,6,1</span></span><br><span class="line"><span class="function">result&gt; sensor_7,1547718202,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_7,1547718202,7,1</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,1547718202,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,1547718202,7,1</span></span><br><span class="line"><span class="function">result&gt; sensor_10,1547718205,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_10,1547718205,10,2</span></span><br><span class="line"><span class="function">sql&gt; sensor_10,1547718205,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_10,1547718205,10,2</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718206,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718206,1,1</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718206,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718206,1,1</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718210,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718210,1,1</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718210,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718210,1,1</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718212,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_1,1547718212,1,1</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718212,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_1,1547718212,1,1</span></span><br><span class="line"><span class="function">result&gt; sensor_6,1547718212,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_6,1547718212,6,1</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,1547718212,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_6,1547718212,6,1</span></span><br><span class="line"><span class="function">result&gt; sensor_7,1547718212,sensor,6</span></span><br><span class="line"><span class="function">result&gt; sensor_7,1547718212,7,1</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,1547718212,sensor,6</span></span><br><span class="line"><span class="function">sql&gt; sensor_7,1547718212,7,1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="聚合函数-Aggregate-Functions"><a href="#聚合函数-Aggregate-Functions" class="headerlink" title="聚合函数 (Aggregate Functions)"></a>聚合函数 (Aggregate Functions)</h5><ul>
<li><p>用户自定义的聚合函数 (User-Defined Aggregate Functions，UDAGGs)，可以把一个表中的数据，聚合成一个标量值。</p>
</li>
<li><p>用户自定义的聚合函数，是通过继承 AggregateFunction 抽象类实现的。</p>
</li>
<li><p>AggregationFunction 要求必须实现的方法：</p>
<p><img src="/2021/04/25/flink/image-20210822170147356.png" alt="image-20210822170147356"></p>
<ul>
<li><code>createAccumulator()</code>：创建一个空累加器。</li>
<li><code>accumulate()</code>：更新累加器。</li>
<li><code>getValue()</code>：获取最终结果。</li>
</ul>
</li>
<li><p>AggregateFunction 的工作原理如下：</p>
<ul>
<li>首先，它需要一个累加器 (Accumulator)，用来保存聚合中间结果的数据结构。通过调用 <code>createAccumulator()</code> 创建空累加器。</li>
<li>随后，对每个输入行调用函数的 <code>accumulate()</code> 来更新累加器。</li>
<li>处理完所有行后，将调用函数的 <code>getValue()</code> 来计算并返回最终结果。</li>
</ul>
</li>
<li><p>实例：</p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdfTest3_AggregateFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流处理环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.转换成POJO</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建表处理环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.将流转换成表</span></span><br><span class="line">        Table sensorTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id, timestamp as ts, temperature as temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.自定义聚合函数，求当前传感器的平均温度值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-1.需要在环境中注册UDF</span></span><br><span class="line">        AvgTemp avgTemp = <span class="keyword">new</span> AvgTemp();</span><br><span class="line">        tableEnv.registerFunction(<span class="string">&quot;avgTemp&quot;</span>, avgTemp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-2.Table API写法</span></span><br><span class="line">        Table resultTable = sensorTable</span><br><span class="line">                .groupBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .aggregate(<span class="string">&quot;avgTemp(temp) as avgtemp&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id, avgtemp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6-3.SQL写法</span></span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, sensorTable);</span><br><span class="line">        Table resultSqlTable = tableEnv.sqlQuery(<span class="string">&quot;select id, avgTemp(temp) &quot;</span> +</span><br><span class="line">                <span class="string">&quot; from sensor group by id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.打印输出</span></span><br><span class="line">        tableEnv.toRetractStream(resultTable, Row.class).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        tableEnv.toRetractStream(resultSqlTable, Row.class).print(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义的AggregateFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgTemp</span> <span class="keyword">extends</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Double</span>, <span class="title">Tuple2</span>&lt;<span class="title">Double</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">getValue</span><span class="params">(Tuple2&lt;Double, Integer&gt; accumulator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> accumulator.f0 / accumulator.f1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Double, Integer&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0.0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须实现一个accumulate方法，来数据之后更新状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(Tuple2&lt;Double, Integer&gt; accumulator, Double temp)</span> </span>&#123;</span><br><span class="line">            accumulator.f0 += temp;</span><br><span class="line">            accumulator.f1 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入参数：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sensor_1,1547718199,35.8</span><br><span class="line">sensor_6,1547718201,15.4</span><br><span class="line">sensor_7,1547718202,6.7</span><br><span class="line">sensor_10,1547718205,38.1</span><br><span class="line">sensor_1,1547718206,36.3</span><br><span class="line">sensor_1,1547718210,34.7</span><br><span class="line">sensor_1,1547718212,33.1</span><br><span class="line">sensor_6,1547718212,15.3</span><br><span class="line">sensor_7,1547718212,6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">WARN No appenders could be found <span class="keyword">for</span> <span class="title">logger</span> <span class="params">(org.apache.flink.api.java.typeutils.TypeExtractor)</span>.</span></span><br><span class="line"><span class="function">log4j:WARN Please initialize the log4j system properly.</span></span><br><span class="line"><span class="function">log4j:WARN See http:<span class="comment">//logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">35.8</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">35.8</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_6,<span class="number">15.4</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_6,<span class="number">15.4</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_7,<span class="number">6.7</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_7,<span class="number">6.7</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_10,<span class="number">38.1</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_10,<span class="number">38.1</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">35.8</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">35.8</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">36.05</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">36.05</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">36.05</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">35.6</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">36.05</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">35.6</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">34.975</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">35.6</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">false</span>,sensor_6,<span class="number">15.4</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">false</span>,sensor_1,<span class="number">35.6</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_6,<span class="number">15.350000000000001</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_1,<span class="number">34.975</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">false</span>,sensor_7,<span class="number">6.7</span>)</span></span></span><br><span class="line"><span class="function">sql&gt; <span class="params">(<span class="keyword">true</span>,sensor_7,<span class="number">6.5</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">false</span>,sensor_6,<span class="number">15.4</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_6,<span class="number">15.350000000000001</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">false</span>,sensor_7,<span class="number">6.7</span>)</span></span></span><br><span class="line"><span class="function">result&gt; <span class="params">(<span class="keyword">true</span>,sensor_7,<span class="number">6.5</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="表聚合函数-Table-Aggregate-Functions"><a href="#表聚合函数-Table-Aggregate-Functions" class="headerlink" title="表聚合函数 (Table Aggregate Functions)"></a>表聚合函数 (Table Aggregate Functions)</h5><ul>
<li><p>用户自定义的表聚合函数 (User-Defined Table Aggregate Functions，UDTAGGs)，可以把一个表中数据，聚合为具有多行和多列的结果表。</p>
</li>
<li><p>用户自定义的表聚合函数，是通过继承 TableAggregateFunction 抽象类实现的。</p>
</li>
<li><p>TableAggregateFunction 要求必须实现的方法：</p>
<p><img src="/2021/04/25/flink/image-20210822170940295.png" alt="image-20210822170940295"></p>
<ul>
<li><code>createAccumulator()</code>：创建一个空累加器。</li>
<li><code>accumulate()</code>：更新累加器。</li>
<li><code>emitValue()</code>：获取最终结果。</li>
</ul>
</li>
<li><p>TableAggregateFunction 的工作原理如下:</p>
<ul>
<li>首先，它同样需要一个累加器 (Accumulator)，用来保存聚合中间结果的数据结构。通过调用 <code>createAccumulator()</code> 创建空累加器。</li>
<li>随后，对每个输入行调用函数的 <code>accumulate()</code> 来更新累加器。</li>
<li>处理完所有行后，将调用函数的 <code>emitValue()</code> 来计算并返回最终结果。</li>
</ul>
</li>
</ul>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qy4y1q728">https://www.bilibili.com/video/BV1qy4y1q728</a></p>
<p><a target="_blank" rel="noopener" href="https://ashiamd.github.io/docsify-notes/#/study/BigData/Flink/%E5%B0%9A%E7%A1%85%E8%B0%B7Flink%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0?id=_1-flink%e7%9a%84%e7%89%b9%e7%82%b9">https://ashiamd.github.io/docsify-notes/#/study/BigData/Flink/%E5%B0%9A%E7%A1%85%E8%B0%B7Flink%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0?id=_1-flink%e7%9a%84%e7%89%b9%e7%82%b9</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/flink/" rel="tag"># flink</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/23/spring-webflux/" rel="prev" title="Spring 之 WebFlux">
      <i class="fa fa-chevron-left"></i> Spring 之 WebFlux
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/17/docker-base/" rel="next" title="Docker 入门">
      Docker 入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E6%B5%81%E5%A4%84%E7%90%86%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">Flink 流处理简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">传统数据处理架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86-%E7%AC%AC%E4%B8%80%E4%BB%A3"><span class="nav-number">1.2.</span> <span class="nav-text">有状态的流式处理 (第一代)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda-%E6%9E%B6%E6%9E%84-%E7%AC%AC%E4%BA%8C%E4%BB%A3"><span class="nav-number">1.3.</span> <span class="nav-text">lambda 架构 (第二代)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E5%8F%98"><span class="nav-number">1.4.</span> <span class="nav-text">流处理系统的演变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.</span> <span class="nav-text">Flink 的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-vs-Spark-Streaming"><span class="nav-number">1.6.</span> <span class="nav-text">Flink vs Spark Streaming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QuickStart"><span class="nav-number">2.</span> <span class="nav-text">QuickStart</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0-WordCount"><span class="nav-number">2.1.</span> <span class="nav-text">批处理实现 WordCount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0-WordCount"><span class="nav-number">2.2.</span> <span class="nav-text">流处理实现 WordCount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%BC%8F%E6%95%B0%E6%8D%AE%E6%BA%90%E6%B5%8B%E8%AF%95"><span class="nav-number">2.3.</span> <span class="nav-text">流式数据源测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E7%9A%84%E9%83%A8%E7%BD%B2"><span class="nav-number">3.</span> <span class="nav-text">Flink 的部署</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Standalone-%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">Standalone 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">3.1.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.1.2.</span> <span class="nav-text">提交任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Yarn-%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">Yarn 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Flink-on-Yarn"><span class="nav-number">3.2.1.</span> <span class="nav-text">Flink on Yarn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Session-Cluster"><span class="nav-number">3.2.2.</span> <span class="nav-text">Session-Cluster</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Per-Job-Cluster"><span class="nav-number">3.2.3.</span> <span class="nav-text">Per-Job-Cluster</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes-%E9%83%A8%E7%BD%B2"><span class="nav-number">3.3.</span> <span class="nav-text">Kubernetes 部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">Flink 的运行架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">Flink 运行时的组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%E5%99%A8-JobManager"><span class="nav-number">4.1.1.</span> <span class="nav-text">作业管理器 (JobManager)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8-TaskManager"><span class="nav-number">4.1.2.</span> <span class="nav-text">任务管理器 (TaskManager)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8-ResourceManager"><span class="nav-number">4.1.3.</span> <span class="nav-text">资源管理器 (ResourceManager)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E5%99%A8-Dispatcher"><span class="nav-number">4.1.4.</span> <span class="nav-text">分发器 (Dispatcher)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">任务提交流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">任务调度原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%BA%A6-Parallelism"><span class="nav-number">4.3.1.</span> <span class="nav-text">并行度 (Parallelism)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TaskManger-%E4%B8%8E-Slots"><span class="nav-number">4.3.2.</span> <span class="nav-text">TaskManger 与 Slots</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%AD%90%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">4.3.3.</span> <span class="nav-text">并行子任务的分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81-DataFlow"><span class="nav-number">4.3.4.</span> <span class="nav-text">程序与数据流 (DataFlow)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%9B%BE-ExecutionGrap"><span class="nav-number">4.3.5.</span> <span class="nav-text">执行图 (ExecutionGrap)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%BD%A2%E5%BC%8F"><span class="nav-number">4.3.6.</span> <span class="nav-text">数据传输形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%93%BE-Operator-Chain"><span class="nav-number">4.3.7.</span> <span class="nav-text">任务链 (Operator Chain)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E7%9A%84%E6%B5%81%E5%A4%84%E7%90%86-API"><span class="nav-number">5.</span> <span class="nav-text">Flink 的流处理 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Environment"><span class="nav-number">5.1.</span> <span class="nav-text">Environment</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getExecutionEnvironment"><span class="nav-number">5.1.1.</span> <span class="nav-text">getExecutionEnvironment()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createLocalEnvironment"><span class="nav-number">5.1.2.</span> <span class="nav-text">createLocalEnvironment()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createRemoteEnvironment"><span class="nav-number">5.1.3.</span> <span class="nav-text">createRemoteEnvironment()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Source"><span class="nav-number">5.2.</span> <span class="nav-text">Source</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E9%9B%86%E5%90%88%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">5.2.1.</span> <span class="nav-text">从集合读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">5.2.2.</span> <span class="nav-text">从文件读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E-Kafka-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">5.2.3.</span> <span class="nav-text">从 Kafka 消息队列读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Source"><span class="nav-number">5.2.4.</span> <span class="nav-text">自定义 Source</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transform"><span class="nav-number">5.3.</span> <span class="nav-text">Transform</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="nav-number">5.3.1.</span> <span class="nav-text">基本转换算子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E7%AE%97%E5%AD%90"><span class="nav-number">5.3.2.</span> <span class="nav-text">聚合操作算子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%B5%81%E8%BD%AC%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="nav-number">5.3.3.</span> <span class="nav-text">多流转换算子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E5%AD%90%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.3.4.</span> <span class="nav-text">算子转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.</span> <span class="nav-text">支持的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.1.</span> <span class="nav-text">基础数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%92%8C-%E5%92%8C-Scala-%E5%85%83%E7%BB%84-Tuples"><span class="nav-number">5.4.2.</span> <span class="nav-text">Java 和 和 Scala 元组 (Tuples)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scala-%E6%A0%B7%E4%BE%8B%E7%B1%BB-case-classes"><span class="nav-number">5.4.3.</span> <span class="nav-text">Scala 样例类 (case classes)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1-POJO"><span class="nav-number">5.4.4.</span> <span class="nav-text">Java 简单对象 (POJO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83-Arrays%EF%BC%8CLists%EF%BC%8CMaps%EF%BC%8CEnums%EF%BC%8C%E7%AD%89%E7%AD%89"><span class="nav-number">5.4.5.</span> <span class="nav-text">其它 (Arrays，Lists，Maps，Enums，等等)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-UDF-%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E6%9B%B4%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">5.5.</span> <span class="nav-text">实现 UDF 函数——更细粒度的控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB-Function-Classes"><span class="nav-number">5.5.1.</span> <span class="nav-text">函数类 (Function Classes)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.2.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%8C%E5%87%BD%E6%95%B0-Rich-Functions"><span class="nav-number">5.5.3.</span> <span class="nav-text">富函数 (Rich Functions)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%87%8D%E5%88%86%E5%8C%BA%E6%93%8D%E4%BD%9C"><span class="nav-number">5.6.</span> <span class="nav-text">数据重分区操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sink"><span class="nav-number">5.7.</span> <span class="nav-text">Sink</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka"><span class="nav-number">5.7.1.</span> <span class="nav-text">Kafka</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis"><span class="nav-number">5.7.2.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Elasticsearch"><span class="nav-number">5.7.3.</span> <span class="nav-text">Elasticsearch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDBC-%E8%87%AA%E5%AE%9A%E4%B9%89-Sink"><span class="nav-number">5.7.4.</span> <span class="nav-text">JDBC 自定义 Sink</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E7%9A%84-Window"><span class="nav-number">6.</span> <span class="nav-text">Flink 的 Window</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.</span> <span class="nav-text">Window 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">Window 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3-Time-Window"><span class="nav-number">6.2.1.</span> <span class="nav-text">时间窗口 (Time Window)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E7%AA%97%E5%8F%A3-Count-Window"><span class="nav-number">6.2.2.</span> <span class="nav-text">计数窗口 (Count Window)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-API"><span class="nav-number">6.3.</span> <span class="nav-text">Window API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">6.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AA%97%E5%8F%A3"><span class="nav-number">6.3.2.</span> <span class="nav-text">创建不同类型的窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-window-function"><span class="nav-number">6.3.3.</span> <span class="nav-text">窗口函数 (window function)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%8F%AF%E9%80%89-API"><span class="nav-number">6.4.</span> <span class="nav-text">其他可选 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window-API-%E6%80%BB%E8%A7%88"><span class="nav-number">6.5.</span> <span class="nav-text">Window API 总览</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E7%9A%84%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89%E5%92%8C-Wartermark"><span class="nav-number">7.</span> <span class="nav-text">Flink 的时间语义和 Wartermark</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89"><span class="nav-number">7.1.</span> <span class="nav-text">Flink 中的时间语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E7%A7%8D%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89%E6%9B%B4%E9%87%8D%E8%A6%81"><span class="nav-number">7.2.</span> <span class="nav-text">哪种时间语义更重要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AE%BE%E7%BD%AE-Event-Time"><span class="nav-number">7.3.</span> <span class="nav-text">在代码中设置 Event Time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Watermark"><span class="nav-number">7.4.</span> <span class="nav-text">Watermark</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Watermark-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">7.4.1.</span> <span class="nav-text">Watermark 的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watermark-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">7.4.2.</span> <span class="nav-text">Watermark 的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watermark-%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-number">7.4.3.</span> <span class="nav-text">Watermark 的传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watermark-%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">7.4.4.</span> <span class="nav-text">Watermark 的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AssignerWithPeriodicWatermarks"><span class="nav-number">7.4.4.1.</span> <span class="nav-text">AssignerWithPeriodicWatermarks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AssignerWithPunctuatedWatermarks"><span class="nav-number">7.4.4.2.</span> <span class="nav-text">AssignerWithPunctuatedWatermarks</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watermark-%E7%9A%84%E8%AE%BE%E5%AE%9A"><span class="nav-number">7.4.5.</span> <span class="nav-text">Watermark 的设定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Evnet-Time-%E5%9C%A8-Window-%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95%E8%AF%B4%E6%98%8E"><span class="nav-number">7.5.</span> <span class="nav-text">Evnet Time 在 Window 中的测试说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6%E4%B8%BA-1"><span class="nav-number">7.5.1.</span> <span class="nav-text">流的并行度为 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6%E4%B8%8D%E4%B8%BA-1"><span class="nav-number">7.5.2.</span> <span class="nav-text">流的并行度不为 1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">Flink 的状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">8.1.</span> <span class="nav-text">Flink 中的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E5%AD%90%E7%8A%B6%E6%80%81-Operator-State"><span class="nav-number">8.2.</span> <span class="nav-text">算子状态 (Operator State)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E5%AD%90%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.2.1.</span> <span class="nav-text">算子状态数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E5%AD%90%E7%8A%B6%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.2.2.</span> <span class="nav-text">算子状态的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE%E6%8E%A7%E7%8A%B6%E6%80%81-Keyed-State"><span class="nav-number">8.3.</span> <span class="nav-text">键控状态 (Keyed State)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%AE%E6%8E%A7%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.3.1.</span> <span class="nav-text">键控状态数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%AE%E6%8E%A7%E7%8A%B6%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.3.2.</span> <span class="nav-text">键控状态的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF-State-Backends"><span class="nav-number">8.4.</span> <span class="nav-text">状态后端 (State Backends)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF"><span class="nav-number">8.4.1.</span> <span class="nav-text">选择一个状态后端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">8.4.2.</span> <span class="nav-text">状态后端的使用配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E7%9A%84%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6"><span class="nav-number">9.</span> <span class="nav-text">Flink 的容错机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%A3%80%E6%9F%A5%E7%82%B9-Checkpoint"><span class="nav-number">9.1.</span> <span class="nav-text">一致性检查点 (Checkpoint)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%A3%80%E6%9F%A5%E7%82%B9%E6%81%A2%E5%A4%8D%E7%8A%B6%E6%80%81"><span class="nav-number">9.2.</span> <span class="nav-text">从检查点恢复状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95"><span class="nav-number">9.3.</span> <span class="nav-text">检查点的实现算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-%E6%A3%80%E6%9F%A5%E7%82%B9%E7%AE%97%E6%B3%95"><span class="nav-number">9.4.</span> <span class="nav-text">Flink 检查点算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9-Savepoints"><span class="nav-number">9.5.</span> <span class="nav-text">保存点 (Savepoints)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">9.6.</span> <span class="nav-text">检查点的使用配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">Flink 的状态一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">10.1.</span> <span class="nav-text">状态一致性的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="nav-number">10.2.</span> <span class="nav-text">状态一致性的级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exactly-once-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.3.</span> <span class="nav-text">exactly-once 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF-end-to-end-%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">10.4.</span> <span class="nav-text">端到端 (end-to-end) 状态一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF-exactly-once"><span class="nav-number">10.5.</span> <span class="nav-text">端到端 exactly-once</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%82%E7%AD%89%E5%86%99%E5%85%A5-Idempotent-Writes"><span class="nav-number">10.5.1.</span> <span class="nav-text">幂等写入 (Idempotent Writes)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%86%99%E5%85%A5-Transactional-Writes"><span class="nav-number">10.5.2.</span> <span class="nav-text">事务写入 (Transactional Writes)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97-Write-Ahead-Log%EF%BC%8CWAL"><span class="nav-number">10.5.2.1.</span> <span class="nav-text">预写日志 (Write-Ahead-Log，WAL)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4-Two-Phase-Commit%EF%BC%8C2PC"><span class="nav-number">10.5.2.2.</span> <span class="nav-text">两阶段提交 (Two-Phase-Commit，2PC)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2PC-%E5%AF%B9%E5%A4%96%E9%83%A8-Sink-%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">10.5.2.3.</span> <span class="nav-text">2PC 对外部 Sink 系统的要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C-Source-%E5%92%8C-Sink-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">10.6.</span> <span class="nav-text">不同 Source 和 Sink 的一致性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-Kafka-%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">10.7.</span> <span class="nav-text">Flink + Kafka 端到端状态一致性的保证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exactly-once-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%9B%BE%E8%A7%A3"><span class="nav-number">10.7.1.</span> <span class="nav-text">Exactly-once 两阶段提交图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exactly-once-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%AD%A5%E9%AA%A4"><span class="nav-number">10.7.2.</span> <span class="nav-text">Exactly-once 两阶段提交步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProcessFunction-API-%E5%BA%95%E5%B1%82-API"><span class="nav-number">11.</span> <span class="nav-text">ProcessFunction API (底层 API)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KeyedProcessFunction"><span class="nav-number">11.1.</span> <span class="nav-text">KeyedProcessFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%A7%E8%BE%93%E5%87%BA%E6%B5%81-SideOutput"><span class="nav-number">11.2.</span> <span class="nav-text">侧输出流 (SideOutput)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoProcessFunction"><span class="nav-number">11.3.</span> <span class="nav-text">CoProcessFunction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Table-API-%E4%B8%8E-SQL"><span class="nav-number">12.</span> <span class="nav-text">Table API 与 SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Table-API-%E5%92%8C-Flink-SQL-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">12.1.</span> <span class="nav-text">Table API 和 Flink SQL 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">12.2.</span> <span class="nav-text">程序实现的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B-TableEnvironment-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">12.3.</span> <span class="nav-text">不同类型 TableEnvironment 的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8-Table"><span class="nav-number">12.4.</span> <span class="nav-text">表 (Table)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">12.4.1.</span> <span class="nav-text">更新模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">12.4.2.</span> <span class="nav-text">从文件创建表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%A1%A8%E5%88%B0%E6%96%87%E4%BB%B6"><span class="nav-number">12.4.3.</span> <span class="nav-text">输出表到文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%8E%A5-Kafka"><span class="nav-number">12.4.4.</span> <span class="nav-text">对接 Kafka</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%8E%A5-ES"><span class="nav-number">12.4.5.</span> <span class="nav-text">对接 ES</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%8E%A5-MySQL"><span class="nav-number">12.4.6.</span> <span class="nav-text">对接 MySQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E8%A1%A8%E8%BD%AC%E6%8D%A2%E6%88%90-DataStream"><span class="nav-number">12.4.7.</span> <span class="nav-text">将表转换成 DataStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86-DataStream-%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8"><span class="nav-number">12.4.8.</span> <span class="nav-text">将 DataStream 转换成表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E8%A7%86%E5%9B%BE-Temporary-View"><span class="nav-number">12.4.9.</span> <span class="nav-text">创建临时视图 (Temporary View)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="nav-number">12.4.10.</span> <span class="nav-text">查看执行计划</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E5%92%8C%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.5.</span> <span class="nav-text">流处理和关系代数的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8-Dynamic-Tables"><span class="nav-number">12.6.</span> <span class="nav-text">动态表 (Dynamic Tables)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%B5%81%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8A%A8%E6%80%81%E8%A1%A8"><span class="nav-number">12.6.1.</span> <span class="nav-text">将流转换成动态表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E7%BB%AD%E6%9F%A5%E8%AF%A2"><span class="nav-number">12.6.2.</span> <span class="nav-text">持续查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%8A%A8%E6%80%81%E8%A1%A8%E8%BD%AC%E6%8D%A2%E6%88%90-DataStream"><span class="nav-number">12.6.3.</span> <span class="nav-text">将动态表转换成 DataStream</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%B9%E6%80%A7-Time-Attributes"><span class="nav-number">12.7.</span> <span class="nav-text">时间特性 (Time Attributes)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4-Processing-Time"><span class="nav-number">12.7.1.</span> <span class="nav-text">定义处理时间 (Processing Time)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4-Event-Time"><span class="nav-number">12.7.2.</span> <span class="nav-text">定义事件时间 (Event Time)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3"><span class="nav-number">12.8.</span> <span class="nav-text">窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Group-Windows"><span class="nav-number">12.8.1.</span> <span class="nav-text">Group Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3-Tumbling-windows"><span class="nav-number">12.8.1.1.</span> <span class="nav-text">滚动窗口 (Tumbling windows)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-Sliding-windows"><span class="nav-number">12.8.1.2.</span> <span class="nav-text">滑动窗口 (Sliding windows)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E7%AA%97%E5%8F%A3%EF%BC%88Session-windows%EF%BC%89"><span class="nav-number">12.8.1.3.</span> <span class="nav-text">会话窗口（Session windows）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL-%E4%B8%AD%E7%9A%84-Group-Windows"><span class="nav-number">12.8.1.4.</span> <span class="nav-text">SQL 中的 Group Windows</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Over-Windows"><span class="nav-number">12.8.2.</span> <span class="nav-text">Over Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E7%95%8C-Over-Windows"><span class="nav-number">12.8.2.1.</span> <span class="nav-text">无界 Over Windows</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%95%8C-Over-Windows"><span class="nav-number">12.8.2.2.</span> <span class="nav-text">有界 Over Windows</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL-%E4%B8%AD%E7%9A%84-Over-Windows"><span class="nav-number">12.8.2.3.</span> <span class="nav-text">SQL 中的 Over Windows</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-Functions"><span class="nav-number">12.9.</span> <span class="nav-text">函数 (Functions)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0-UDF"><span class="nav-number">12.9.1.</span> <span class="nav-text">用户自定义函数 (UDF)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E9%87%8F%E5%87%BD%E6%95%B0-Scalar-Functions"><span class="nav-number">12.9.1.1.</span> <span class="nav-text">标量函数 (Scalar Functions)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E5%87%BD%E6%95%B0-Table-Functions"><span class="nav-number">12.9.1.2.</span> <span class="nav-text">表函数 (Table Functions)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-Aggregate-Functions"><span class="nav-number">12.9.1.3.</span> <span class="nav-text">聚合函数 (Aggregate Functions)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-Table-Aggregate-Functions"><span class="nav-number">12.9.1.4.</span> <span class="nav-text">表聚合函数 (Table Aggregate Functions)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83"><span class="nav-number">13.</span> <span class="nav-text">本文参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XiSun"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">XiSun</p>
  <div class="site-description" itemprop="description">心如止水者，虽世间繁华之红尘纷扰，已然空无一物</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiSun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.8m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">27:20</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
