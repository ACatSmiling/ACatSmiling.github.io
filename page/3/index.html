<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
<meta property="og:type" content="website">
<meta property="og:title" content="XiSun的博客">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="XiSun的博客">
<meta property="og:description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XiSun">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>XiSun的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiSun的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learning is endless</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/shell/" class="post-title-link" itemprop="url">shell 脚本中的一些方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 17:16:35" itemprop="dateCreated datePublished" datetime="2020-12-22T17:16:35+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 16:13:35" itemprop="dateModified" datetime="2021-01-01T16:13:35+08:00">2021-01-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p>shell 截取字符串通常有两种方式：从指定位置开始截取和从指定字符 (子字符串) 开始截取。</p>
<h3 id="从指定位置开始截取"><a href="#从指定位置开始截取" class="headerlink" title="从指定位置开始截取"></a>从指定位置开始截取</h3><p>两个参数：起始位置，截取长度。</p>
<h4 id="从字符串左边开始计数"><a href="#从字符串左边开始计数" class="headerlink" title="从字符串左边开始计数"></a>从字符串左边开始计数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;string: start :length&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，string 是要截取的字符串，start 是起始位置 (从左边开始，从 0 开始计数)，length 是要截取的长度 (如果省略表示直到字符串的末尾)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;c.biancheng.net&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url: 2: 9&#125;</span></span><br><span class="line"></span><br><span class="line">biancheng</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;c.biancheng.net&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url: 2&#125;</span></span><br><span class="line"></span><br><span class="line">biancheng.net</span><br></pre></td></tr></table></figure>

<h4 id="从字符串右边开始计数"><a href="#从字符串右边开始计数" class="headerlink" title="从字符串右边开始计数"></a>从字符串右边开始计数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;string: 0-start :length&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>0-</code> 是固定的写法，专门用来表示从字符串右边开始计数。</p>
<blockquote>
<p>从左边开始计数时，起始数字是 0；从右边开始计数时，起始数字是 1。计数方向不同，起始数字也不同。</p>
<p>不管从哪边开始计数，截取方向都是从左到右。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;c.biancheng.net&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url: 0-13: 9&#125;</span></span><br><span class="line"></span><br><span class="line">biancheng</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;c.biancheng.net&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url: 0-13&#125;</span></span><br><span class="line"></span><br><span class="line">biancheng.net</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从右边数，b 是第 13 个字符。</p>
</blockquote>
<h3 id="从指定字符-子字符串-开始截取"><a href="#从指定字符-子字符串-开始截取" class="headerlink" title="从指定字符 (子字符串) 开始截取"></a>从指定字符 (子字符串) 开始截取</h3><p>这种截取方式无法指定字符串长度，只能从指定字符 (子字符串) 截取到字符串末尾。shell 可以截取指定字符 (子字符串) 右边的所有字符，也可以截取左边的所有字符。</p>
<h4 id="使用-截取指定字符-子字符串-右边字符"><a href="#使用-截取指定字符-子字符串-右边字符" class="headerlink" title="使用 # 截取指定字符 (子字符串)右边字符"></a>使用 # 截取指定字符 (子字符串)右边字符</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;string#*chars&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，string 表示要截取的字符，chars 是指定的字符 (子字符串)，<code>*</code> 是通配符的一种，表示任意长度的字符串。<code>*chars</code> 连起来使用的意思是：忽略左边的所有字符，直到遇见 chars (chars 不会被截取)。</p>
<blockquote>
<p>从左往右看。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;http://c.biancheng.net/index.html&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#*:&#125;</span></span><br><span class="line"></span><br><span class="line">//c.biancheng.net/index.html</span><br></pre></td></tr></table></figure>

<p>以下写法也可以得到同样的结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#*p:&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#*ttp:&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果不需要忽略 chars 左边的字符，那么也可以不写 <code>*</code>，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;http://c.biancheng.net/index.html&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#http://&#125;</span></span><br><span class="line"></span><br><span class="line">c.biancheng.net/index.html</span><br></pre></td></tr></table></figure>

<p>注意，以上写法遇到第一个匹配的字符 (子字符串) 就结束了。例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;http://c.biancheng.net/index.html&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#*/&#125;</span></span><br><span class="line"></span><br><span class="line">/c.biancheng.net/index.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p>url 字符串中有三个 <code>/</code>，输出结果表明，shell 遇到第一个 <code>/</code> 就匹配结束了。</p>
</blockquote>
<p>如果希望直到最后一个指定字符 (子字符串) 再匹配结束，那么可以使用 <code>##</code>，具体格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;string##*chars&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://c.biancheng.net/index.html&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#*/&#125;</span>    <span class="comment"># 结果为 /c.biancheng.net/index.html</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url##*/&#125;</span>   <span class="comment"># 结果为 index.html</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;---aa+++aa@@@&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str#*aa&#125;</span>   <span class="comment"># 结果为 +++aa@@@</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str##*aa&#125;</span>  <span class="comment"># 结果为 @@@</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-截取指定字符-子字符串-左边字符"><a href="#使用-截取指定字符-子字符串-左边字符" class="headerlink" title="使用 % 截取指定字符 (子字符串)左边字符"></a>使用 % 截取指定字符 (子字符串)左边字符</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;string%chars*&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意 <code>*</code> 的位置，因为要截取 chars 左边的字符，而忽略 chars 右边的字符，所以 <code>*</code> 应该位于 chars 的右侧。其他方面 <code>%</code> 和 <code>#</code> 的用法相同。</p>
<blockquote>
<p>从右往左看。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://c.biancheng.net/index.html&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url%/*&#125;</span>  <span class="comment"># 结果为 http://c.biancheng.net</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url%%/*&#125;</span>  <span class="comment"># 结果为 http:</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;---aa+++aa@@@&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str%aa*&#125;</span>  <span class="comment"># 结果为 ---aa+++</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str%%aa*&#125;</span>  <span class="comment"># 结果为 ---</span></span><br></pre></td></tr></table></figure>

<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>${string: start :length}</td>
<td>从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。</td>
</tr>
<tr>
<td>${string: start}</td>
<td>从 string 字符串的左边第 start 个字符开始截取，直到最后。</td>
</tr>
<tr>
<td>${string: 0-start :length}</td>
<td>从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。</td>
</tr>
<tr>
<td>${string: 0-start}</td>
<td>从 string 字符串的右边第 start 个字符开始截取，直到最后。</td>
</tr>
<tr>
<td>${string#*chars}</td>
<td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</td>
</tr>
<tr>
<td>${string##*chars}</td>
<td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</td>
</tr>
<tr>
<td>${string%*chars}</td>
<td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。</td>
</tr>
<tr>
<td>${string%%*chars}</td>
<td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。</td>
</tr>
</tbody></table>
<p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1120.html">http://c.biancheng.net/view/1120.html</a></p>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">name=<span class="string">&quot;Shell&quot;</span></span><br><span class="line">url=<span class="string">&quot;http://c.biancheng.net/shell/&quot;</span></span><br><span class="line"></span><br><span class="line">str1=<span class="variable">$name</span><span class="variable">$url</span>  <span class="comment"># 中间不能有空格</span></span><br><span class="line">str2=<span class="string">&quot;<span class="variable">$name</span> <span class="variable">$url</span>&quot;</span>  <span class="comment"># 如果被双引号包围，那么中间可以有空格</span></span><br><span class="line">str3=<span class="variable">$name</span><span class="string">&quot;: &quot;</span><span class="variable">$url</span>  <span class="comment"># 中间可以出现别的字符串</span></span><br><span class="line">str4=<span class="string">&quot;<span class="variable">$name</span>: <span class="variable">$url</span>&quot;</span>  <span class="comment"># 这样写也可以</span></span><br><span class="line">str5=<span class="string">&quot;<span class="variable">$&#123;name&#125;</span>Script: <span class="variable">$&#123;url&#125;</span>index.html&quot;</span>  <span class="comment"># 这个时候需要给变量名加上大括号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str4</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str5</span></span><br><span class="line"></span><br><span class="line">Shellhttp://c.biancheng.net/shell/</span><br><span class="line">Shell http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">Shell: http://c.biancheng.net/shell/</span><br><span class="line">ShellScript: http://c.biancheng.net/shell/index.html</span><br></pre></td></tr></table></figure>

<p>对于第 7 行代码，$name 和 $url 之间之所以不能出现空格，是因为当字符串不被任何一种引号包围时，遇到空格就认为字符串结束了，空格后边的内容会作为其他变量或者命令解析。</p>
<p>对于第 10 行代码，加 { } 是为了帮助解释器识别变量的边界。</p>
<h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><h3 id="以空格为分隔符"><a href="#以空格为分隔符" class="headerlink" title="以空格为分隔符"></a>以空格为分隔符</h3><p>比如有一个变量 “123 456 789”，要求以空格为分隔符把这个变量分隔，并把分隔后的字段分别赋值给变量，即 a=123；b=456；c=789。<br>共有3中方法：<br>方法一：先定义一个数组，然后把分隔出来的字段赋值给数组中的每一个元素<br>方法二：通过 eval+ 赋值的方式<br>方法三：通过多次 awk 把每个字段赋值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">&quot;123 456 789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一：通过数组的方式</span></span><br><span class="line"><span class="built_in">declare</span> -a arr</span><br><span class="line">index=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">echo</span> <span class="variable">$a</span> | awk <span class="string">&#x27;&#123;print $1,$3&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    arr[<span class="variable">$index</span>]=<span class="variable">$i</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;index+=1&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[0]&#125;</span> <span class="comment"># 结果为 123</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[1]&#125;</span> <span class="comment"># 结果为 789</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：通过eval+赋值的方式</span></span><br><span class="line">b=<span class="string">&quot;&quot;</span></span><br><span class="line">c=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">eval</span> $(<span class="built_in">echo</span> <span class="variable">$a</span> | awk <span class="string">&#x27;&#123; printf(&quot;b=%s;c=%s&quot;,$2,$1)&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span> <span class="comment"># 结果为 456</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$c</span> <span class="comment"># 结果为 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：通过多次awk赋值的方式</span></span><br><span class="line">m=<span class="string">&quot;&quot;</span></span><br><span class="line">n=<span class="string">&quot;&quot;</span></span><br><span class="line">m=`<span class="built_in">echo</span> <span class="variable">$a</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">n=`<span class="built_in">echo</span> <span class="variable">$a</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$m</span> <span class="comment"># 结果为 123</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$n</span> <span class="comment"># 结果为 456</span></span><br></pre></td></tr></table></figure>

<h3 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">string=<span class="string">&quot;hello,shell,haha&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一  </span></span><br><span class="line">array=(<span class="variable">$&#123;string//,/ &#125;</span>)  </span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">IFS=<span class="string">&quot;,&quot;</span></span><br><span class="line">OLD_IFS=<span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span><br><span class="line">IFS=<span class="string">&quot;<span class="variable">$OLD_IFS</span>&quot;</span></span><br><span class="line">array2=(<span class="variable">$string</span>)</span><br><span class="line"><span class="keyword">for</span> var2 <span class="keyword">in</span> <span class="variable">$&#123;array2[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$var2</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">shell</span><br><span class="line">haha</span><br><span class="line">hello</span><br><span class="line">shell</span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>反引号：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var=`<span class="built_in">command</span>`</span><br></pre></td></tr></table></figure>

<p><code>$()</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var=$(<span class="built_in">command</span>)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ A=`date`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$A</span></span><br><span class="line">Fri Dec 25 20:02:30 CST 2020 <span class="comment"># 变量A存放了date命令的执行结果</span></span><br><span class="line"></span><br><span class="line">$ B=$(date)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$B</span></span><br><span class="line">Fri Dec 25 20:03:12 CST 2020 <span class="comment"># 变量B存放了date命令的执行结果</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：= 号前后不要有空格。</p>
</blockquote>
<p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="https://book.51cto.com/art/201411/457601.htm">https://book.51cto.com/art/201411/457601.htm</a></p>
<h2 id="判断文件夹是否存在"><a href="#判断文件夹是否存在" class="headerlink" title="判断文件夹是否存在"></a>判断文件夹是否存在</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d testgrid  ];<span class="keyword">then</span></span><br><span class="line">  mkdir testgrid</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> dir exist</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>外部传参：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断传入的参数的个数是不是一个</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="variable">$#</span> -eq 1  ];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> param error!</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断目录是不是已经存在，如果不存在则创建，存在则输出&quot;dir exist&quot; </span></span><br><span class="line">dirname=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;the dir name is <span class="variable">$dirname</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$dirname</span>  ];<span class="keyword">then</span></span><br><span class="line">  mkdir <span class="variable">$dirname</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> dir exist</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>类 C 语言：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=1; i&lt;=100; i ++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>in 使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>seq 使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 100`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="发送微信消息"><a href="#发送微信消息" class="headerlink" title="发送微信消息"></a>发送微信消息</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/105781861">https://blog.csdn.net/whatday/article/details/105781861</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/15/linux-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/linux-command/" class="post-title-link" itemprop="url">linux 命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-15 17:31:47" itemprop="dateCreated datePublished" datetime="2020-12-15T17:31:47+08:00">2020-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 19:35:41" itemprop="dateModified" datetime="2021-01-01T19:35:41+08:00">2021-01-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>用于在指定目录下查找文件。默认列出当前目录及子目录下所有的文件和文件夹。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -<span class="built_in">print</span> ]   [ -<span class="built_in">exec</span>   -ok   <span class="built_in">command</span> ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p><strong>-print</strong>： find 命令将匹配到的文件输出到标准输出。</p>
<p><strong>-exec</strong>： find 命令对匹配的文件执行该参数所给出的 Shell 命令。</p>
<p><strong>-ok</strong>： 和 -exec 的作用相同，只是更安全，在执行每个命令之前，都会给出提示，让用户来确定是否执行。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-mount, -xdev</span><br><span class="line">		只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件。</span><br><span class="line"></span><br><span class="line">-amin n</span><br><span class="line">		在过去n分钟内被读取过。</span><br><span class="line"></span><br><span class="line">-anewer file</span><br><span class="line">		比文件file更晚被读取过的文件。</span><br><span class="line"></span><br><span class="line">-atime n</span><br><span class="line">		在过去n天内被读取过的文件。</span><br><span class="line">		</span><br><span class="line">-cmin n</span><br><span class="line">		在过去n分钟内被修改过。</span><br><span class="line">		</span><br><span class="line">-cnewer file</span><br><span class="line">		比文件file更新的文件。</span><br><span class="line">		</span><br><span class="line">-ctime n</span><br><span class="line">		在过去n天内被修改过的文件。</span><br><span class="line">		</span><br><span class="line">-empty</span><br><span class="line">		空的文件。</span><br><span class="line">		</span><br><span class="line">-gid n</span><br><span class="line">		gid是n。</span><br><span class="line">		</span><br><span class="line">-group name</span><br><span class="line">		group名称是name。</span><br><span class="line">		</span><br><span class="line">-path p | -ipath p</span><br><span class="line">		路径名称符合p的文件。ipath忽略大小写。</span><br><span class="line">		</span><br><span class="line">-name name | -iname name</span><br><span class="line">		文件名称符合name的文件。iname忽略大小写。</span><br><span class="line">		</span><br><span class="line">-size n</span><br><span class="line">		文件大小是n单位，b代表512位元组的区块，c表示字元数，k表示kilo bytes，w是二个位元组。</span><br><span class="line">		</span><br><span class="line">-<span class="built_in">type</span> d|f</span><br><span class="line">		文件类型是d|f的文件。</span><br><span class="line">		</span><br><span class="line">-pid n</span><br><span class="line">		process id是n的文件。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文件类型：d — 目录，f — 一般文件，c — 字型装置文件，b — 区块装置文件，p — 具名贮列，l — 符号连结，s — socket。</p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>查询当前路径下的所有目录|普通文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -<span class="built_in">type</span> d</span><br><span class="line">$ find ./ -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<ul>
<li>查询权限为 777 的普通文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -<span class="built_in">type</span> f -perm 777</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 .XML 文件，且权限不为 777</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -<span class="built_in">type</span> f -name <span class="string">&quot;*.XML&quot;</span> ! -perm 777</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 .XML 文件，并统计查询结果的条数</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name <span class="string">&quot;*.XML&quot;</span> | wc -l</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 .XML 文件，并复制查询结果到指定路径</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name <span class="string">&quot;*.XML&quot;</span> | xargs -i cp &#123;&#125; ../111</span><br><span class="line">$ find ./ -name <span class="string">&quot;*.XML&quot;</span> -<span class="built_in">exec</span> cp &#123;&#125; ../111 \;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此命令不同于 cp，<code>cp *.XML ../111</code> 命令复制的是当前路径下符合条件的所有文件，子路径的不会被复制。</p>
</blockquote>
<ul>
<li>查询 .XML 文件，并删除</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name <span class="string">&quot;*.XML&quot;</span> | xargs -i rm &#123;&#125;</span><br><span class="line">$ find ./ -name <span class="string">&quot;*.XML&quot;</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此命令不同于 rm，<code>rm *.XML</code> 命令删除的是当前路径下符合条件的所有文件，子路径的不会被删除。</p>
</blockquote>
<ul>
<li>查询 .XML 文件，并将查询结果以 “File: 文件名” 的形式打印出来</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name <span class="string">&quot;*.XML&quot;</span> | xargs -i <span class="built_in">printf</span> <span class="string">&quot;File: %s\n&quot;</span> &#123;&#125;</span><br><span class="line">$ find ./ -name <span class="string">&quot;*.XML&quot;</span> -<span class="built_in">exec</span> <span class="built_in">printf</span> <span class="string">&quot;File: %s\n&quot;</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<ul>
<li>将当前路径及子路径下所有 3 天前的 .XML 格式的文件复制一份到指定路径</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name <span class="string">&quot;*.XML&quot;</span> -mtime +3 -<span class="built_in">exec</span> cp &#123;&#125; ../111 \;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询多个文件后缀类型的文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -regextype posix-extended -regex <span class="string">&quot;.*\.(java|xml|XML)&quot;</span>	 <span class="comment"># 查找所有的.java、.xml和.XML文件</span></span><br><span class="line">$ find ./ -name <span class="string">&quot;*.java&quot;</span> -o -name <span class="string">&quot;*.xml&quot;</span> -o -name <span class="string">&quot;*.XML&quot;</span>		 <span class="comment"># -o选项，适用于查询少量文件后缀类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>组合查询，可以多次拼接查询条件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -name <span class="string">&quot;file1*&quot;</span> -a -name <span class="string">&quot;*.xml&quot;</span>	<span class="comment"># -a：与，查找以file1开头，且以.xml 结尾的文件</span></span><br><span class="line">$ find ./ -name <span class="string">&quot;file1*&quot;</span> -o -name <span class="string">&quot;*.xml&quot;</span>	<span class="comment"># -o：或，查找以file1开头，或以.xml 结尾的文件</span></span><br><span class="line">$ find ./ -name <span class="string">&quot;file1*&quot;</span> -not -name <span class="string">&quot;*.xml&quot;</span>	<span class="comment"># -not：非，查找以file1开头，且不以.xml 结尾的文件</span></span><br><span class="line">$ find ./ -name <span class="string">&quot;file1*&quot;</span> ! -name <span class="string">&quot;file2*&quot;</span>	<span class="comment"># !：同-not</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查询当前目录下文件类型为 d 的文件，不包含子目录</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ -maxdepth 1 -<span class="built_in">type</span> d</span><br></pre></td></tr></table></figure>

<ul>
<li>和正则表达式的结合使用</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find ./ –name <span class="string">&quot;[^abc]*&quot;</span>	<span class="comment"># 在当前路径中搜索不以a、b、c开头的所有文件</span></span><br><span class="line">$ find ./ -name <span class="string">&quot;[A-Z0-9]*&quot;</span>	<span class="comment"># 在当前路径中搜索以大写字母或数字开头的所有文件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>正则表达式符号含义：</p>
<p>*          代表任意字符 (可以没有字符)</p>
<p>?          代表任意单个字符</p>
<p>[]         代表括号内的任意字符，如 [abc] 可以匹配 a\b\c 某个字符</p>
<p>[a-z]    可以匹配 a-z 的某个字母</p>
<p>[A-Z]    可以匹配 A-Z 的某个字符</p>
<p>[0-9]    可以匹配 0-9 的某个数字</p>
<p>^          用在 [] 内的前缀表示不匹配 [] 中的字符</p>
<p>[^a-z]  表示不匹配a-z的某个字符</p>
</blockquote>
<p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b30a8aa4d1f1">https://www.jianshu.com/p/b30a8aa4d1f1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/cn/technical-resources/articles/linux-calish-find.html">https://www.oracle.com/cn/technical-resources/articles/linux-calish-find.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qmfsun/p/3811142.html">https://www.cnblogs.com/qmfsun/p/3811142.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ay-a/p/8017419.html">https://www.cnblogs.com/ay-a/p/8017419.html</a></p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>用于连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 </p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--<span class="built_in">help</span>] [--version] fileName</span><br></pre></td></tr></table></figure>

<h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-n | --number</span><br><span class="line">		由1开始对所有输出的行数编号。</span><br><span class="line"></span><br><span class="line">-b | --number-nonblank</span><br><span class="line">		和-n相似，只不过对于空白行不编号。</span><br><span class="line"></span><br><span class="line">-s | --squeeze-blank</span><br><span class="line">		当遇到有连续两行以上的空白行，就代换为一行的空白行。</span><br><span class="line"></span><br><span class="line">-v | --show-nonprinting</span><br><span class="line">		使用^和M-符号，除了LFD和TAB之外。</span><br><span class="line"></span><br><span class="line">-E | --show-ends</span><br><span class="line">		在每行结束处显示$。</span><br><span class="line">		</span><br><span class="line">-T | --show-tabs</span><br><span class="line">		将TAB字符显示为^I。</span><br><span class="line">		</span><br><span class="line">-A | --show-all</span><br><span class="line">		等价于<span class="string">&quot;-vET&quot;</span>。</span><br><span class="line">		</span><br><span class="line">-e</span><br><span class="line">		等价于<span class="string">&quot;-vE&quot;</span>。</span><br><span class="line">		</span><br><span class="line">-t</span><br><span class="line">		等价于<span class="string">&quot;-vT&quot;</span>。</span><br></pre></td></tr></table></figure>

<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul>
<li>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure>

<ul>
<li>清空 /etc/test.txt 文档内容</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /dev/null &gt; /etc/test.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>/dev/null</strong>：在类 Unix 系统中，/dev/null 称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据 (但报告写入操作成功)，读取它则会立即得到一个 EOF。</p>
<p>而使用 <code>cat $filename &gt; /dev/null</code> 则不会得到任何信息，因为我们将本来该通过标准输出显示的文件信息重定向到了 /dev/null 中。</p>
<p>使用 <code>cat $filename 1 &gt; /dev/null</code> 也会得到同样的效果，因为默认重定向的 1 就是标准输出。 如果你对 shell 脚本或者重定向比较熟悉的话，应该会联想到 2 ，也即标准错误输出。</p>
<p>如果我们不想看到错误输出呢？我们可以禁止标准错误 <code>cat $badname 2 &gt; /dev/null</code>。</p>
</blockquote>
<ul>
<li>合并多个文件内容</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat b1.sql b2.sql b3.sql &gt; b_all.sql</span><br><span class="line">$ cat *.sql &gt; merge.sql</span><br></pre></td></tr></table></figure>

<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zmx19951103/article/details/78575265">https://blog.csdn.net/zmx19951103/article/details/78575265</a></p>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luo200618/article/details/52510638">https://blog.csdn.net/luo200618/article/details/52510638</a></p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qmfsun/p/6626361.html">https://www.cnblogs.com/qmfsun/p/6626361.html</a></p>
<h2 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dde911234761">https://www.jianshu.com/p/dde911234761</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/105781861">https://blog.csdn.net/whatday/article/details/105781861</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26502245/article/details/100191694">https://blog.csdn.net/qq_26502245/article/details/100191694</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011641885/article/details/45559031">https://blog.csdn.net/u011641885/article/details/45559031</a></p>
<h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p>用于去掉文件名的目录和后缀。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	basename NAME [SUFFIX]</span><br><span class="line">or:	basename OPTION... NAME...</span><br></pre></td></tr></table></figure>

<p>去掉 NAME 中的目录部分和后缀 SUFFIX，如果输出结果没有，则输出 SUFFIX。</p>
<h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-a | --multiple</span><br><span class="line">			support multiple arguments and treat each as a NAME</span><br><span class="line">			</span><br><span class="line">-s | --suffix=SUFFIX</span><br><span class="line">			remove a trailing SUFFIX; implies -a</span><br><span class="line">			</span><br><span class="line">-z | --zero</span><br><span class="line">			end each output line with NUL, not newline(默认情况下，每条输出行以换行符结尾)</span><br><span class="line">			</span><br><span class="line">--<span class="built_in">help</span></span><br><span class="line">			display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">			</span><br><span class="line">--version</span><br><span class="line">			output version information and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><ul>
<li>去除目录</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$basename</span> /usr/bin/sort</span><br><span class="line">sort</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ basename /usr/include/stdio.h    </span><br><span class="line">stdio.h</span><br></pre></td></tr></table></figure>

<ul>
<li>去除目录和后缀</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ basename /usr/include/stdio.h .h</span><br><span class="line">stdio</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ basename -s .h /usr/include/stdio.h</span><br><span class="line">stdio</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ basename /usr/include/stdio.h stdio.h </span><br><span class="line">stdio.h</span><br></pre></td></tr></table></figure>

<ul>
<li>去除多个目录</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ basename -a any1/str1 any2/str2 any3/str3</span><br><span class="line">str1</span><br><span class="line">str2</span><br><span class="line">str3</span><br></pre></td></tr></table></figure>

<h2 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h2><p>用于去除文件名中的非目录部分，删除最后一个 “\“ 后面的路径，显示父目录。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname [OPTION] NAME...</span><br></pre></td></tr></table></figure>

<p>如果 NAME 中不包含 /，则输出 .，即当前目录。</p>
<h3 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-z | --zero</span><br><span class="line">		end each output line with NUL, not newline</span><br><span class="line">		</span><br><span class="line">--<span class="built_in">help</span></span><br><span class="line">		display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">		</span><br><span class="line">--version</span><br><span class="line">		output version information and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ dirname /usr/bin/</span><br><span class="line">/usr</span><br><span class="line"></span><br><span class="line">$ dirname /usr/bin</span><br><span class="line">/usr</span><br><span class="line"></span><br><span class="line">$ dirname /etc/</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">$ dirname /etc/httpd/conf/httpd.conf</span><br><span class="line">/etc/httpd/conf</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dirname dir1/str dir2/str</span><br><span class="line">dir1</span><br><span class="line">dir2</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dirname stdio.h</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p>
<p>xargs 可以将管道或标准输入 (stdin) 数据转换成命令行参数，也能够从文件的输出中读取数据。</p>
<p>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</p>
<p>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</p>
<p>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p>
<p>之所以能用到这个命令，关键是由于很多命令不支持管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /sbin -perm +700 | ls -l       <span class="comment">#这个命令是错误的</span></span><br><span class="line">find /sbin -perm +700 | xargs ls -l   <span class="comment">#这样才是正确的</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>xargs 一般是和管道一起使用。</p>
</blockquote>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some <span class="built_in">command</span> | xargs -item <span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<h3 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-a file</span><br><span class="line">	从文件中读入作为sdtin</span><br><span class="line">		</span><br><span class="line">-e flag</span><br><span class="line">	注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</span><br><span class="line">		</span><br><span class="line">-p</span><br><span class="line">	当每次执行一个argument的时候询问一次用户。</span><br><span class="line">	</span><br><span class="line">-n num</span><br><span class="line">	后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</span><br><span class="line"></span><br><span class="line">-t</span><br><span class="line">	表示先打印命令，然后再执行。</span><br><span class="line"></span><br><span class="line">-i</span><br><span class="line">	或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给&#123;&#125;，可以用&#123;&#125;代替。</span><br><span class="line"></span><br><span class="line">-r</span><br><span class="line">	no-run-if-empty，当xargs的输入为空的时候则停止xargs，不用再去执行了。</span><br><span class="line"></span><br><span class="line">-s</span><br><span class="line">	num命令行的最大字符数，指的是xargs后面那个命令的最大命令行字符数。</span><br><span class="line"></span><br><span class="line">-L num</span><br><span class="line">	从标准输入一次读取num行送给<span class="built_in">command</span>命令。</span><br><span class="line"></span><br><span class="line">-l</span><br><span class="line">	同 -L。</span><br><span class="line"></span><br><span class="line">-d delim</span><br><span class="line">	分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</span><br><span class="line"></span><br><span class="line">-x</span><br><span class="line">	<span class="built_in">exit</span>的意思，主要是配合-s使用。</span><br><span class="line"></span><br><span class="line">-P</span><br><span class="line">	修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</span><br></pre></td></tr></table></figure>

<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><ul>
<li>读取输入数据重新格式化后输出</li>
</ul>
<p>定义一个测试文件，内有多行文本数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">a b c d e f g</span><br><span class="line">h i j k l m n</span><br><span class="line">o p q</span><br><span class="line">r s t</span><br><span class="line">u v w x y z</span><br></pre></td></tr></table></figure>

<p>单行输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt | xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>

<p>-n 选项自定义多行输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt | xargs -n3</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line">m n o</span><br><span class="line">p q r</span><br><span class="line">s t u</span><br><span class="line">v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure>

<p>-d 选项自定义一个定界符：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;nameXnameXnameXname&quot;</span> | xargs -dX</span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure>

<p>结合 -n 选项使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;nameXnameXnameXname&quot;</span> | xargs -dX -n2</span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure>

<ul>
<li>读取 stdin，将格式化后的参数传递给命令</li>
</ul>
<p>假设一个命令为 sk.sh 和一个保存参数的文件 arg.txt：</p>
<p>sk.sh 命令内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出所有参数。</span></span><br><span class="line"><span class="built_in">echo</span> $*</span><br></pre></td></tr></table></figure>

<p>arg.txt 文件内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat arg.txt</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<p>xargs 的一个选项 -I，使用 -I 指定一个替换字符串 {}，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat arg.txt | xargs -I &#123;&#125; ./sk.sh -p &#123;&#125; -l</span><br><span class="line">-p aaa -l</span><br><span class="line">-p bbb -l</span><br><span class="line">-p ccc -l</span><br></pre></td></tr></table></figure>

<p>复制所有图片文件到 /data/images 目录下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images</span><br></pre></td></tr></table></figure>

<ul>
<li>结合 find 使用</li>
</ul>
<p>用 rm 删除太多的文件时候，可能得到一个错误信息：**/bin/rm Argument list too long.**， 用 xargs 去避免这个问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span> -print0 | xargs -0 rm -f</span><br></pre></td></tr></table></figure>

<blockquote>
<p>xargs -0 将 \0 作为定界符。</p>
</blockquote>
<p>统计一个源代码目录中所有 php 文件的行数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.php&quot;</span> -print0 | xargs -0 wc -l</span><br></pre></td></tr></table></figure>

<p>查找所有的 jpg 文件，并且压缩它们：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.jpg&quot;</span> -<span class="built_in">print</span> | xargs tar -zcvf images.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>xargs 其他应用</li>
</ul>
<p>假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs 下载所有链接：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat url-list.txt | xargs wget -c</span><br></pre></td></tr></table></figure>

<p>参考：？？？</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangqiguo/p/6464234.html">https://www.cnblogs.com/wangqiguo/p/6464234.html</a></p>
<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>linux 内置的 cron 进程能实现定时任务需求。</p>
<p>crontab 命令是 cron table 的简写，它是 cron 的配置文件，也可以叫它作业列表。我们可以在以下文件夹内找到相关配置文件：</p>
<ul>
<li>**/var/spool/cron/**：该目录下存放的是每个用户包括 root 的 crontab 任务，每个任务以创建者的名字命名。</li>
<li><strong>/etc/crontab</strong>：该文件负责调度各种管理和维护任务。</li>
<li>**/etc/cron.d/**：该目录用来存放任何要执行的crontab文件或脚本。</li>
<li>另外，还可以把脚本放在 <strong>/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly</strong> 目录中，让它<strong>每小时/天/星期/月</strong>执行一次。</li>
</ul>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>

<h3 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-u user</span><br><span class="line">	用来设定某个用户的crontab服务，省略此参数表示操作当前用户的crontab。</span><br><span class="line"></span><br><span class="line">file</span><br><span class="line">	file是命令文件的名字，表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入(键盘)上键入的命令，并将它们载入crontab。</span><br><span class="line"></span><br><span class="line">-e</span><br><span class="line">	编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line"></span><br><span class="line">-l</span><br><span class="line">	显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line"></span><br><span class="line">-r</span><br><span class="line">	从/var/spool/cron目录中删除某个用户的crontab文件。如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line"></span><br><span class="line">-i</span><br><span class="line">	在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>

<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>设置定时任务时，输入 <code>crontab -e</code> 命令，进入当前用户的工作表编辑，是常见的 vim 界面。每行是一条命令。</p>
<p><strong>crontab 的命令格式：</strong></p>
<p><img src="/2020/12/15/linux-command/45b1947d455a43e71d169dba7ca042fea49b6968c1697f3433a1a92e12c5786c.png" alt="Thumbnail"></p>
<p><strong>crontab 的命令构成：</strong></p>
<p><code>时间 + 命令</code>，其时间有<strong>分、时、日、月、周</strong>五种，时间的操作符有：</p>
<ul>
<li><span style="color:red;">*****</span>：取值范围内的所有数字</li>
<li><span style="color:red;"><strong>/</strong></span>：每过多少个数字，间隔频率，例如：用在小时段的”*/2”表示每隔两小时</li>
<li><span style="color:red;"><strong>-</strong></span>：从X到Z，例如：”2-6”表示”2,3,4,5,6”</li>
<li><span style="color:red;"><strong>,</strong></span>：散列数字，例如：”1,2,5,7”</li>
</ul>
<p><strong>crontab 的命令实例：</strong></p>
<ul>
<li>每 2 小时执行一次：<code>0 */2 * * * command</code></li>
</ul>
<blockquote>
<p>上述命令的含义：能被2整除的整点的0分，执行命令，即 0、2、4、6、…、20、22、24。</p>
</blockquote>
<p><strong>crontab 的日志查看：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f /var/<span class="built_in">log</span>/cron.log</span><br><span class="line">$ tail -f /var/spool/mail/[username]</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li><strong>环境变量问题</strong></li>
</ol>
<p>有时我们创建了一个 crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在 crontab 文件中没有配置环境变量引起的。</p>
<p>在 crontab 文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前 shell 环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在 crontab 文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。</p>
<p>不要假定 cron 知道所需要的特殊环境，它其实并不知道。所以你要保证在 shell 脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下 3 点：</p>
<ul>
<li><p>脚本中涉及文件路径时写全局路径；</p>
</li>
<li><p>脚本执行要用到 java 或其他环境变量时，通过 source 命令引入环境变量，如：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat start_cbp.sh</span><br><span class="line">!/bin/sh</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">export</span> RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/jboss-4.0.5/bin/run.sh -c mev &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>或者通过在 crontab 中直接引入环境变量解决问题。如：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>及时清理系统用户的邮件日志</strong></li>
</ol>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在 crontab 文件中设置如下形式，忽略日志输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */3 * * * /usr/<span class="built_in">local</span>/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>“&gt;/dev/null 2&gt;&amp;1” 表示先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了 /dev/null，因此标准错误也会重定向到 /dev/null，这样日志输出问题就解决了。</p>
<ol start="3">
<li><strong>其他注意事项</strong></li>
</ol>
<p>新创建的 cron job，不会马上执行，至少要过 2 分钟才执行。如果重启 cron 则马上执行。</p>
<p>当 crontab 失效时，可以尝试 <code>/etc/init.d/crond restart</code> 解决问题。或者查看日志看某个 job 有没有执行/报错 <code>tail -f /var/log/cron</code>。</p>
<p>**千万别乱运行 <code>crontab -r</code>**。它从 crontab 目录 (/var/spool/cron) 中删除用户的 crontab 文件，删除了该文件，则用户的所有 crontab 都没了。</p>
<p>在 crontab 中 % 是有特殊含义的，表示换行的意思。如果要用的话必须进行转义 %，如经常用的 date ‘+%Y%m%d’ 在 crontab 里是不会执行的，应该换成 date ‘+%Y%m%d’。</p>
<p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021815907">https://segmentfault.com/a/1190000021815907</a></p>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>用于为文件或目录改名、或将文件或目录移入其它位置。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	mv [OPTION]... [-T] SOURCE DEST</span><br><span class="line">or: mv [OPTION]... SOURCE... DIRECTORY</span><br><span class="line">or: mv [OPTION]... -t DIRECTORY SOURCE...</span><br></pre></td></tr></table></figure>

<h3 id="参数说明-6"><a href="#参数说明-6" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-b</span><br><span class="line">	当目标文件或目录sh存在时，在执行覆盖前，会为其创建一个备份。</span><br><span class="line"></span><br><span class="line">-i</span><br><span class="line">	如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入y表示直接覆盖，输入n表示取消该操作。</span><br><span class="line"></span><br><span class="line">-f</span><br><span class="line">	如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</span><br><span class="line"></span><br><span class="line">-n</span><br><span class="line">	不要覆盖任何已存在的文件或目录。</span><br><span class="line"></span><br><span class="line">-u</span><br><span class="line">	当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</span><br></pre></td></tr></table></figure>

<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><ul>
<li>将源文件名 source_file 改为目标文件名 dest_file</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv source_file(文件) dest_file(文件)</span><br></pre></td></tr></table></figure>

<ul>
<li>将文件 source_file 移动到目标目录 dest_directory 中</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv source_file(文件) dest_directory(目录)</span><br></pre></td></tr></table></figure>

<ul>
<li>将源目录 source_directory 移动到 目标目录 dest_directory中</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv source_directory(目录) dest_directory(目录)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若目录名 dest_directory 已存在，则 source_directory 移动到目录名 dest_directory 中；</p>
<p>若目录名 dest_directory 不存在，则 source_directory 改名为目录名 dest_directory。</p>
</blockquote>
<h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><p>用于实现文件或批量文件重命名。在不同的 linux 版本，命令的语法格式可能不同。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename [ -h|-m|-V ] [ -v ] [ -n ] [ -f ] [ -e|-E *perlexpr*]*|*perlexpr* [ *files* ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>linux 版本：</p>
<p>Linux version 4.4.0-116-generic (buildd@lgw01-amd64-021) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9) ) #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018</p>
</blockquote>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename [options] expression replacement file...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>linux 版本：</p>
<p>Linux version 3.10.0-1062.el7.x86_64 (<a href="mailto:&#109;&#x6f;&#x63;&#107;&#x62;&#x75;&#105;&#108;&#100;&#64;&#107;&#x62;&#x75;&#105;&#108;&#100;&#x65;&#x72;&#46;&#x62;&#x73;&#x79;&#x73;&#46;&#99;&#x65;&#x6e;&#x74;&#111;&#x73;&#46;&#111;&#x72;&#103;">&#109;&#x6f;&#x63;&#107;&#x62;&#x75;&#105;&#108;&#100;&#64;&#107;&#x62;&#x75;&#105;&#108;&#100;&#x65;&#x72;&#46;&#x62;&#x73;&#x79;&#x73;&#46;&#99;&#x65;&#x6e;&#x74;&#111;&#x73;&#46;&#111;&#x72;&#103;</a>) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Wed Aug 7 18:08:02 UTC 2019</p>
</blockquote>
<h3 id="参数说明-7"><a href="#参数说明-7" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-v, -verbose</span><br><span class="line">        Verbose: <span class="built_in">print</span> names of files successfully renamed.</span><br><span class="line">-n, -nono</span><br><span class="line">        No action: <span class="built_in">print</span> names of files to be renamed, but don<span class="string">&#x27;t rename.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-f, -force</span></span><br><span class="line"><span class="string">        Over write: allow existing files to be over-written.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-h, -help</span></span><br><span class="line"><span class="string">        Help: print SYNOPSIS and OPTIONS.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-m, -man</span></span><br><span class="line"><span class="string">        Manual: print manual page.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-V, -version</span></span><br><span class="line"><span class="string">        Version: show version number.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-e      Expression: code to act on files name.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        May be repeated to build up code (like &quot;perl -e&quot;). If no -e, the</span></span><br><span class="line"><span class="string">        first argument is used as code.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-E      Statement: code to act on files name, as -e but terminated by</span></span><br><span class="line"><span class="string">        &#x27;</span>;<span class="string">&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-v, --verbose  explain what is being <span class="keyword">done</span></span><br><span class="line">-s, --symlink  act on symlink target</span><br><span class="line"></span><br><span class="line">-h, --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">-V, --version  output version information and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><ul>
<li>替换文件名中特定字段</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rename -v <span class="string">&quot;s/20/patent-application/&quot;</span> *.tar.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lin @ lin in ~/share/storage_server_3/Download/test [14:52:08] </span></span><br><span class="line">$ ll</span><br><span class="line">total 76G</span><br><span class="line">-rw-rw-r-- 1 lin lin 4.3G Dec  4 16:54 2005.tar.gz</span><br><span class="line">-rw-rw-r-- 1 lin lin 4.3G Dec  5 21:50 2006.tar.gz</span><br><span class="line">-rw-rw-r-- 1 lin lin 4.4G Dec  5 21:52 2007.tar.gz</span><br><span class="line">-rw-rw-r-- 1 lin lin 4.7G Dec  5 21:53 2008.tar.gz</span><br><span class="line">-rw-rw-r-- 1 lin lin 5.0G Dec  7 22:10 2009.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># lin @ lin in ~/share/storage_server_3/Download/test [14:52:08] </span></span><br><span class="line">$ rename -v <span class="string">&quot;s/20/patent-application/&quot;</span> *.tar.gz</span><br><span class="line">2005.tar.gz renamed as patent-application05.tar.gz</span><br><span class="line">2006.tar.gz renamed as patent-application06.tar.gz</span><br><span class="line">2007.tar.gz renamed as patent-application07.tar.gz</span><br><span class="line">2008.tar.gz renamed as patent-application08.tar.gz</span><br><span class="line">2009.tar.gz renamed as patent-application09.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># lin @ lin in ~/share/storage_server_3/Download/test [14:53:55] </span></span><br><span class="line">$ ll</span><br><span class="line">total 76G</span><br><span class="line">-rw-rw-r-- 1 lin lin 4.3G Dec  4 16:54 patent-application05.tar.gz</span><br><span class="line">-rw-rw-r-- 1 lin lin 4.3G Dec  5 21:50 patent-application06.tar.gz</span><br><span class="line">-rw-rw-r-- 1 lin lin 4.4G Dec  5 21:52 patent-application07.tar.gz</span><br><span class="line">-rw-rw-r-- 1 lin lin 4.7G Dec  5 21:53 patent-application08.tar.gz</span><br><span class="line">-rw-rw-r-- 1 lin lin 5.0G Dec  7 22:10 patent-application09.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rename 20 patent-application-20 *.tar.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(base) [hadoop@client version-1.0]$ ll</span><br><span class="line">total 79555796</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 4527645498 Dec  4 16:54 2005.tar.gz</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 4550889304 Dec  5 21:50 2006.tar.gz</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 4712276001 Dec  5 21:52 2007.tar.gz</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 4986740725 Dec  5 21:53 2008.tar.gz</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 5311490484 Dec  7 22:10 2009.tar.gz</span><br><span class="line">(base) [hadoop@client version-1.0]$ rename 20 patent-application-20 *.tar.gz</span><br><span class="line">(base) [hadoop@client version-1.0]$ ll</span><br><span class="line">total 79555796</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop       1372 Dec 16 09:15 hash_calculate.txt</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 4527645498 Dec  4 16:54 patent-application-2005.tar.gz</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 4550889304 Dec  5 21:50 patent-application-2006.tar.gz</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 4712276001 Dec  5 21:52 patent-application-2007.tar.gz</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 4986740725 Dec  5 21:53 patent-application-2008.tar.gz</span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 5311490484 Dec  7 22:10 patent-application-2009.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="http://einverne.github.io/post/2018/01/rename-files-batch.html">http://einverne.github.io/post/2018/01/rename-files-batch.html</a></p>
<h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h2><p>用于解压缩 .zip 文件。</p>
<h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;]</span><br><span class="line">or: unzip [-Z]</span><br></pre></td></tr></table></figure>

<h3 id="参数说明-8"><a href="#参数说明-8" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">-c</span><br><span class="line">	将解压缩的结果显示到屏幕上，并对字符做适当的转换。</span><br><span class="line"></span><br><span class="line">-f</span><br><span class="line">	更新现有的文件。</span><br><span class="line"></span><br><span class="line">-l</span><br><span class="line">	显示压缩文件内所包含的文件。</span><br><span class="line"></span><br><span class="line">-p</span><br><span class="line">	与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。</span><br><span class="line"></span><br><span class="line">-t</span><br><span class="line">	检查压缩文件是否正确。</span><br><span class="line"></span><br><span class="line">-u</span><br><span class="line">	与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。</span><br><span class="line"></span><br><span class="line">-v</span><br><span class="line">	查看压缩文件目录信息，但是不解压该文件。</span><br><span class="line"></span><br><span class="line">-z</span><br><span class="line">	仅显示压缩文件的备注文字。</span><br><span class="line"></span><br><span class="line">-a</span><br><span class="line">	对文本文件进行必要的字符转换。</span><br><span class="line"></span><br><span class="line">-b</span><br><span class="line">	不要对文本文件进行字符转换。</span><br><span class="line"></span><br><span class="line">-C</span><br><span class="line">	压缩文件中的文件名称区分大小写。</span><br><span class="line"></span><br><span class="line">-j</span><br><span class="line">	不处理压缩文件中原有的目录路径。</span><br><span class="line"></span><br><span class="line">-L</span><br><span class="line">	将压缩文件中的全部文件名改为小写。</span><br><span class="line"></span><br><span class="line">-M</span><br><span class="line">	将输出结果送到more程序处理。</span><br><span class="line"></span><br><span class="line">-n</span><br><span class="line">	解压缩时不要覆盖原有的文件。</span><br><span class="line"></span><br><span class="line">-o</span><br><span class="line">	不必先询问用户，unzip执行后覆盖原有文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-q</span><br><span class="line">	执行时不显示任何信息。</span><br><span class="line"></span><br><span class="line">-s</span><br><span class="line">	将文件名中的空白字符转换为底线字符。</span><br><span class="line"></span><br><span class="line">-V</span><br><span class="line">	保留VMS的文件版本信息。</span><br><span class="line"></span><br><span class="line">-X</span><br><span class="line">	解压缩时同时回存文件原来的UID/GID。</span><br><span class="line"></span><br><span class="line">-P &lt;密码&gt;</span><br><span class="line">	使用zip的密码选项。</span><br><span class="line"></span><br><span class="line">[.zip文件]</span><br><span class="line">	指定.zip压缩文件。</span><br><span class="line"></span><br><span class="line">[文件]</span><br><span class="line">	指定要处理.zip压缩文件中的哪些文件。</span><br><span class="line"></span><br><span class="line">-d &lt;目录&gt;</span><br><span class="line">	指定文件解压缩后所要存储的目录。</span><br><span class="line"></span><br><span class="line">-x &lt;文件&gt;</span><br><span class="line">	指定不要处理.zip压缩文件中的哪些文件。</span><br><span class="line"></span><br><span class="line">-Z</span><br><span class="line">    <span class="string">&#x27;unzip -Z&#x27;</span>等于执行zipinfo指令。</span><br></pre></td></tr></table></figure>

<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><ul>
<li>查看压缩文件目录信息，但不解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -v I20090212-SUPP.ZIP </span><br><span class="line">Archive:  I20090212-SUPP.ZIP</span><br><span class="line"> Length   Method    Size  Cmpr    Date    Time   CRC-32   Name</span><br><span class="line">--------  ------  ------- ---- ---------- ----- --------  ----</span><br><span class="line">       0  Stored        0   0% 2009-01-31 04:56 00000000  project/pdds/ICEApplication/I20090212-SUPP/</span><br><span class="line">       0  Stored        0   0% 2009-01-31 04:56 00000000  project/pdds/ICEApplication/I20090212-SUPP/DTDS/</span><br><span class="line">   88199  Stored    88199   0% 2007-01-22 00:07 d5e3060f  project/pdds/ICEApplication/I20090212-SUPP/DTDS/DTDS.zip</span><br><span class="line">       0  Stored        0   0% 2009-01-31 04:56 00000000  project/pdds/ICEApplication/I20090212-SUPP/UTIL0041/</span><br><span class="line">   15664  Stored    15664   0% 2009-01-28 22:45 3dfa6c1c  project/pdds/ICEApplication/I20090212-SUPP/UTIL0041/US20090041797A1-20090212-SUPP.ZIP</span><br><span class="line">       0  Stored        0   0% 2009-01-31 04:56 00000000  project/pdds/ICEApplication/I20090212-SUPP/UTIL0044/</span><br><span class="line">  901714  Stored   901714   0% 2009-01-28 22:45 75ce3ca6  project/pdds/ICEApplication/I20090212-SUPP/UTIL0044/US20090044288A1-20090212-SUPP.ZIP</span><br><span class="line"> 1911858  Stored  1911858   0% 2009-01-28 22:45 cbc1d0bd  project/pdds/ICEApplication/I20090212-SUPP/UTIL0044/US20090044297A1-20090212-SUPP.ZIP</span><br><span class="line">--------          -------  ---                            -------</span><br><span class="line"> 2917435          2917435   0%                            8 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>解压 .zip 文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ unzip I20090212-SUPP.ZIP </span><br><span class="line">Archive:  I20090212-SUPP.ZIP</span><br><span class="line">   creating: project/pdds/ICEApplication/I20090212-SUPP/</span><br><span class="line">   creating: project/pdds/ICEApplication/I20090212-SUPP/DTDS/</span><br><span class="line"> extracting: project/pdds/ICEApplication/I20090212-SUPP/DTDS/DTDS.zip  </span><br><span class="line">   creating: project/pdds/ICEApplication/I20090212-SUPP/UTIL0041/</span><br><span class="line"> extracting: project/pdds/ICEApplication/I20090212-SUPP/UTIL0041/US20090041797A1-20090212-SUPP.ZIP  </span><br><span class="line">   creating: project/pdds/ICEApplication/I20090212-SUPP/UTIL0044/</span><br><span class="line"> extracting: project/pdds/ICEApplication/I20090212-SUPP/UTIL0044/US20090044288A1-20090212-SUPP.ZIP  </span><br><span class="line"> extracting: project/pdds/ICEApplication/I20090212-SUPP/UTIL0044/US20090044297A1-20090212-SUPP.ZIP </span><br></pre></td></tr></table></figure>

<ul>
<li>解压 .zip 文件，但不显示信息</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -q I20090212-SUPP.ZIP</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果压缩文件 .zip 是大于 2G 的，那 unzip 就无法使用，此时可以使用 7zip 解压。</p>
</blockquote>
<p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/lk5aMEAP51/">https://www.bbsmax.com/A/lk5aMEAP51/</a></p>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>用于压缩文件，压缩后的文件后缀名为 .zip。</p>
<h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$] [-b &lt;工作目录&gt;] [-ll] [-n &lt;字尾字符串&gt;] [-t &lt;日期时间&gt;] [-&lt;压缩效率&gt;] [压缩文件] [文件...] [-i &lt;范本样式&gt;] [-x &lt;范本样式&gt;]</span><br></pre></td></tr></table></figure>

<h3 id="参数说明-9"><a href="#参数说明-9" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">-A</span><br><span class="line">	调整可执行的自动解压缩文件。</span><br><span class="line">	</span><br><span class="line">-c</span><br><span class="line">	替每个被压缩的文件加上注释。</span><br><span class="line"></span><br><span class="line">-d</span><br><span class="line">	从压缩文件内删除指定的文件。</span><br><span class="line"></span><br><span class="line">-D</span><br><span class="line">	压缩文件内不建立目录名称。</span><br><span class="line"></span><br><span class="line">-f</span><br><span class="line">	更新现有的文件。</span><br><span class="line"></span><br><span class="line">-F</span><br><span class="line">	尝试修复已损坏的压缩文件。</span><br><span class="line"></span><br><span class="line">-g</span><br><span class="line">	将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。</span><br><span class="line"></span><br><span class="line">-h</span><br><span class="line">	在线帮助。</span><br><span class="line"></span><br><span class="line">-j</span><br><span class="line">	只保存文件名称及其内容，而不存放任何目录名称。</span><br><span class="line"></span><br><span class="line">-J</span><br><span class="line">	删除压缩文件前面不必要的数据。</span><br><span class="line">	</span><br><span class="line">-k</span><br><span class="line">	使用MS-DOS兼容格式的文件名称。</span><br><span class="line">	</span><br><span class="line">-l</span><br><span class="line">	压缩文件时，把LF字符置换成LF+CR字符。</span><br><span class="line"></span><br><span class="line">-L</span><br><span class="line">	显示版权信息。</span><br><span class="line"></span><br><span class="line">-m</span><br><span class="line">	将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</span><br><span class="line"></span><br><span class="line">-o</span><br><span class="line">	以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。</span><br><span class="line"></span><br><span class="line">-q</span><br><span class="line">	不显示指令执行过程。</span><br><span class="line"></span><br><span class="line">-r</span><br><span class="line">	递归处理，将指定目录下的所有文件和子目录一并处理。</span><br><span class="line"></span><br><span class="line">-S</span><br><span class="line">	包含系统和隐藏文件。</span><br><span class="line"></span><br><span class="line">-T</span><br><span class="line">	检查备份文件内的每个文件是否正确无误。</span><br><span class="line"></span><br><span class="line">-u</span><br><span class="line">	与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。</span><br><span class="line"></span><br><span class="line">-v</span><br><span class="line">	显示指令执行过程或显示版本信息。</span><br><span class="line"></span><br><span class="line">-V</span><br><span class="line">	保存VMS操作系统的文件属性。</span><br><span class="line"></span><br><span class="line">-w</span><br><span class="line">	在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。</span><br><span class="line"></span><br><span class="line">-X</span><br><span class="line">	不保存额外的文件属性。</span><br><span class="line"></span><br><span class="line">-y</span><br><span class="line">	直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。</span><br><span class="line"></span><br><span class="line">-z</span><br><span class="line">	替压缩文件加上注释。</span><br><span class="line"></span><br><span class="line">-$</span><br><span class="line">	保存第一个被压缩文件所在磁盘的卷册名称。</span><br><span class="line">	</span><br><span class="line">-b &lt;工作目录&gt;</span><br><span class="line">	指定暂时存放文件的目录。</span><br><span class="line">	</span><br><span class="line">-ll</span><br><span class="line">	压缩文件时，把LF+CR字符置换成LF字符。</span><br><span class="line"></span><br><span class="line">-n &lt;字尾字符串&gt;</span><br><span class="line">	不压缩具有特定字尾字符串的文件。</span><br><span class="line"></span><br><span class="line">-t &lt;日期时间&gt;</span><br><span class="line">	把压缩文件的日期设成指定的日期。</span><br><span class="line"></span><br><span class="line">-&lt;压缩效率&gt;</span><br><span class="line">	压缩效率是一个介于1-9的数值。</span><br><span class="line"></span><br><span class="line">-i &lt;范本样式&gt;</span><br><span class="line">	只压缩符合条件的文件。</span><br><span class="line"></span><br><span class="line">-x &lt;范本样式&gt;</span><br><span class="line">	压缩时排除符合条件的文件。</span><br></pre></td></tr></table></figure>

<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><ul>
<li>将 /home/html/ 目录下所有文件和文件夹打包为当前目录下的 html.zip</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -q -r html.zip /home/html</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当前在 /home/html 目录下，可以执行以下命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -q -r html.zip *</span><br></pre></td></tr></table></figure>

<ul>
<li>从压缩文件 cp.zip 中删除文件 a.c</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -dv cp.zip a.c</span><br></pre></td></tr></table></figure>

<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>用于打包、解包文件。</p>
<blockquote>
<p>tar 本身不具有压缩功能，可以通过参数调用其他压缩工具实现压缩功能。 </p>
</blockquote>
<h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ] [-b &lt;区块数目&gt;] [-C &lt;目的目录&gt;] [-f &lt;备份文件&gt;] [-F &lt;Script文件&gt;] [-K &lt;文件&gt;] [-L &lt;媒体容量&gt;] [-N &lt;日期时间&gt;] [-T &lt;范本文件&gt;] [-V &lt;卷册名称&gt;] [-X &lt;范本文件&gt;] [-&lt;设备编号&gt;&lt;存储密度&gt;] [--after-date=&lt;日期时间&gt;] [--atime-preserve] [--backuup=&lt;备份方式&gt;] [--checkpoint] [--concatenate] [--confirmation] [--delete] [--exclude=&lt;范本样式&gt;] [--force-local] [--group=&lt;群组名称&gt;] [--<span class="built_in">help</span>] [--ignore-failed-read] [--new-volume-script=&lt;Script文件&gt;] [--newer-mtime] [--no-recursion] [--null] [--numeric-owner] [--owner=&lt;用户名称&gt;] [--posix] [--erve] [--preserve-order] [--preserve-permissions] [--record-size=&lt;区块数目&gt;] [--recursive-unlink] [--remove-files] [--rsh-command=&lt;执行指令&gt;] [--same-owner] [--suffix=&lt;备份字尾字符串&gt;] [--totals] [--use-compress-program=&lt;执行指令&gt;] [--version] [--volno-file=&lt;编号文件&gt;] [文件或目录...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>语法结构：<code>tar [必要参数] [可选参数] [文件]</code></p>
</blockquote>
<h3 id="参数说明-10"><a href="#参数说明-10" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">-A | --catenate</span><br><span class="line">		新增文件到已存在的备份文件。</span><br><span class="line">		</span><br><span class="line">-B | --read-full-records</span><br><span class="line">		读取数据时重设区块大小。</span><br><span class="line">		</span><br><span class="line">-c | --create</span><br><span class="line">		建立新的备份文件。</span><br><span class="line">		</span><br><span class="line">-d | --diff | --compare</span><br><span class="line">		对比备份文件内和文件系统上的文件的差异。</span><br><span class="line">		</span><br><span class="line">-g | --listed-incremental</span><br><span class="line">		处理GNU格式的大量备份。</span><br><span class="line">		</span><br><span class="line">-G | --incremental</span><br><span class="line">		处理旧的GNU格式的大量备份。</span><br><span class="line">		</span><br><span class="line">-h | --dereference</span><br><span class="line">		不建立符号连接，直接复制该连接所指向的原始文件。</span><br><span class="line">		</span><br><span class="line">-i | --ignore-zeros</span><br><span class="line">		忽略备份文件中的0 Byte区块，也就是EOF。</span><br><span class="line">		</span><br><span class="line">-k | --keep-old-files</span><br><span class="line">		解开备份文件时，不覆盖已有的文件。</span><br><span class="line">		</span><br><span class="line">-l | --one-file-system</span><br><span class="line">		复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</span><br><span class="line">		</span><br><span class="line">-m | --modification-time</span><br><span class="line">		还原文件时，不变更文件的更改时间。</span><br><span class="line">		</span><br><span class="line">-M | --multi-volume</span><br><span class="line">		在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</span><br><span class="line">		</span><br><span class="line">-o | --old-archive | --portability</span><br><span class="line">		将资料写入备份文件时使用V7格式。</span><br><span class="line">		</span><br><span class="line">-O | --stdout</span><br><span class="line">		把从备份文件里还原的文件输出到标准输出设备。</span><br><span class="line">		</span><br><span class="line">-p | --same-permissions</span><br><span class="line">		用原来的文件权限还原文件。</span><br><span class="line">		</span><br><span class="line">-P | --absolute-names</span><br><span class="line">		文件名使用绝对名称，不移除文件名称前的<span class="string">&quot;/&quot;</span>号。</span><br><span class="line">		</span><br><span class="line">-r | --append</span><br><span class="line">		新增文件到已存在的备份文件的结尾部分。</span><br><span class="line">		</span><br><span class="line">-R | --block-number</span><br><span class="line">		列出每个信息在备份文件中的区块编号。</span><br><span class="line">		</span><br><span class="line">-s | --same-order</span><br><span class="line">		还原文件的顺序和备份文件内的存放顺序相同。</span><br><span class="line">		</span><br><span class="line">-S | --sparse</span><br><span class="line">		倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</span><br><span class="line">		</span><br><span class="line">-t | --list</span><br><span class="line">		列出备份文件的内容。</span><br><span class="line">		</span><br><span class="line">-u | --update</span><br><span class="line">		仅置换较备份文件内的文件更新的文件。</span><br><span class="line">		</span><br><span class="line">-U | --unlink-first</span><br><span class="line">		解开压缩文件还原文件之前，先解除文件的连接。</span><br><span class="line">		</span><br><span class="line">-v | --verbose</span><br><span class="line">		显示指令执行过程。</span><br><span class="line">		</span><br><span class="line">-w | --interactive</span><br><span class="line">		遭遇问题时先询问用户。</span><br><span class="line">		</span><br><span class="line">-W | --verify</span><br><span class="line">		写入备份文件后，确认文件正确无误。</span><br><span class="line">		</span><br><span class="line">-x | --extract | --get</span><br><span class="line">		从备份文件中还原文件。</span><br><span class="line">		</span><br><span class="line">-z | --gzip | --ungzip</span><br><span class="line">		通过gzip指令处理备份文件。</span><br><span class="line">		</span><br><span class="line">-Z | --compress | --uncompress</span><br><span class="line">		通过compress指令处理备份文件。</span><br><span class="line"></span><br><span class="line">-b &lt;区块数目&gt; | --blocking-factor=&lt;区块数目&gt;</span><br><span class="line">		设置每笔记录的区块数目，每个区块大小为12Bytes。</span><br><span class="line"></span><br><span class="line">-C &lt;目的目录&gt; | --directory=&lt;目的目录&gt;</span><br><span class="line">		切换到指定的目录。</span><br><span class="line"></span><br><span class="line">-f &lt;备份文件&gt; | --file=&lt;备份文件&gt;</span><br><span class="line">		指定备份文件。多个命令时需要放在最后面。</span><br><span class="line">		</span><br><span class="line">-F &lt;Script文件&gt; | --info-script=&lt;Script文件&gt;</span><br><span class="line">		每次更换磁带时，就执行指定的Script文件。</span><br><span class="line"></span><br><span class="line">-K &lt;文件&gt; | --starting-file=&lt;文件&gt;</span><br><span class="line">		从指定的文件开始还原。</span><br><span class="line"></span><br><span class="line">-L &lt;媒体容量&gt; | -tape-length=&lt;媒体容量&gt;</span><br><span class="line">		设置存放每体的容量，单位以1024Bytes计算。</span><br><span class="line"></span><br><span class="line">-N &lt;日期格式&gt; | --newer=&lt;日期时间&gt;</span><br><span class="line">		只将较指定日期更新的文件保存到备份文件里。</span><br><span class="line"></span><br><span class="line">-T &lt;范本文件&gt; | --files-from=&lt;范本文件&gt;</span><br><span class="line">		指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</span><br><span class="line"></span><br><span class="line">-V&lt;卷册名称&gt; | --label=&lt;卷册名称&gt;</span><br><span class="line">		建立使用指定的卷册名称的备份文件。</span><br><span class="line"></span><br><span class="line">-X &lt;范本文件&gt; | --exclude-from=&lt;范本文件&gt;</span><br><span class="line">		指定范本文件，其内含有一个或多个范本样式，让tar排除符合设置条件的文件。</span><br><span class="line"></span><br><span class="line">-&lt;设备编号&gt;&lt;存储密度&gt;</span><br><span class="line">		设置备份用的外围设备编号及存放数据的密度。</span><br><span class="line">		</span><br><span class="line">--after-date=&lt;日期时间&gt;</span><br><span class="line">		此参数的效果和指定<span class="string">&quot;-N&quot;</span>参数相同。</span><br><span class="line"></span><br><span class="line">--atime-preserve</span><br><span class="line">		不变更文件的存取时间。</span><br><span class="line"></span><br><span class="line">--backup=&lt;备份方式&gt; | --backup</span><br><span class="line">		移除文件前先进行备份。</span><br><span class="line"></span><br><span class="line">--checkpoint</span><br><span class="line">		读取备份文件时列出目录名称。</span><br><span class="line"></span><br><span class="line">--concatenate</span><br><span class="line">		此参数的效果和指定<span class="string">&quot;-A&quot;</span>参数相同。</span><br><span class="line"></span><br><span class="line">--confirmation</span><br><span class="line">		此参数的效果和指定<span class="string">&quot;-w&quot;</span>参数相同。</span><br><span class="line"></span><br><span class="line">--delete</span><br><span class="line">		从备份文件中删除指定的文件。</span><br><span class="line"></span><br><span class="line">--exclude=&lt;范本样式&gt;</span><br><span class="line">		排除符合范本样式的文件。</span><br><span class="line"></span><br><span class="line">--group=&lt;群组名称&gt;</span><br><span class="line">		把加入设备文件中的文件的所属群组设成指定的群组。</span><br><span class="line"></span><br><span class="line">--<span class="built_in">help</span></span><br><span class="line">		在线帮助。</span><br><span class="line"></span><br><span class="line">--ignore-failed-read</span><br><span class="line">		忽略数据读取错误，不中断程序的执行。</span><br><span class="line"></span><br><span class="line">--new-volume-script=&lt;Script文件&gt;</span><br><span class="line">		此参数的效果和指定<span class="string">&quot;-F&quot;</span>参数相同。</span><br><span class="line"></span><br><span class="line">--newer-mtime</span><br><span class="line">		只保存更改过的文件。</span><br><span class="line"></span><br><span class="line">--no-recursion</span><br><span class="line">		不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</span><br><span class="line"></span><br><span class="line">--null</span><br><span class="line">		从null设备读取文件名称。</span><br><span class="line"></span><br><span class="line">--numeric-owner</span><br><span class="line">		以用户识别码及群组识别码取代用户名称和群组名称。</span><br><span class="line"></span><br><span class="line">--owner=&lt;用户名称&gt;</span><br><span class="line">		把加入备份文件中的文件的拥有者设成指定的用户。</span><br><span class="line"></span><br><span class="line">--posix</span><br><span class="line">		将数据写入备份文件时使用POSIX格式。</span><br><span class="line"></span><br><span class="line">--preserve</span><br><span class="line">		此参数的效果和指定<span class="string">&quot;-ps&quot;</span>参数相同。</span><br><span class="line"></span><br><span class="line">--preserve-order</span><br><span class="line">		此参数的效果和指定<span class="string">&quot;-A&quot;</span>参数相同。</span><br><span class="line"></span><br><span class="line">--preserve-permissions</span><br><span class="line">		此参数的效果和指定<span class="string">&quot;-p&quot;</span>参数相同。</span><br><span class="line"></span><br><span class="line">--record-size=&lt;区块数目&gt;</span><br><span class="line">		此参数的效果和指定<span class="string">&quot;-b&quot;</span>参数相同。</span><br><span class="line"></span><br><span class="line">--recursive-unlink</span><br><span class="line">		解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</span><br><span class="line"></span><br><span class="line">--remove-files</span><br><span class="line">		文件加入备份文件后，就将其删除。</span><br><span class="line"></span><br><span class="line">--rsh-command=&lt;执行指令&gt;</span><br><span class="line">		设置要在远端主机上执行的指令，以取代rsh指令。</span><br><span class="line"></span><br><span class="line">--same-owner</span><br><span class="line">		尝试以相同的文件拥有者还原文件。</span><br><span class="line"></span><br><span class="line">--suffix=&lt;备份字尾字符串&gt;</span><br><span class="line">		移除文件前先行备份。</span><br><span class="line"></span><br><span class="line">--totals</span><br><span class="line">		备份文件建立后，列出文件大小。</span><br><span class="line"></span><br><span class="line">--use-compress-program=&lt;执行指令&gt;</span><br><span class="line">		通过指定的指令处理备份文件。</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line">		显示版本信息。</span><br><span class="line"></span><br><span class="line">--volno-file=&lt;编号文件&gt;</span><br><span class="line">		使用指定文件内的编号取代预设的卷册编号。</span><br></pre></td></tr></table></figure>

<h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><ul>
<li>打包，不压缩</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf test.tar <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/1</span><br><span class="line"><span class="built_in">test</span>/2</span><br><span class="line"><span class="built_in">test</span>/5</span><br><span class="line"><span class="built_in">test</span>/4</span><br></pre></td></tr></table></figure>

<ul>
<li>解包</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf test.tar </span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/1</span><br><span class="line"><span class="built_in">test</span>/2</span><br><span class="line"><span class="built_in">test</span>/5</span><br><span class="line"><span class="built_in">test</span>/4</span><br></pre></td></tr></table></figure>

<ul>
<li>打包，并以 <strong>gzip</strong> 压缩</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcvf test.tar.gz <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/1</span><br><span class="line"><span class="built_in">test</span>/2</span><br><span class="line"><span class="built_in">test</span>/5</span><br><span class="line"><span class="built_in">test</span>/4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar 包。</p>
</blockquote>
<ul>
<li>解压 .tar.gz</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf test.tar.gz </span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/1</span><br><span class="line"><span class="built_in">test</span>/2</span><br><span class="line"><span class="built_in">test</span>/5</span><br><span class="line"><span class="built_in">test</span>/4</span><br></pre></td></tr></table></figure>

<ul>
<li>打包，以 <strong>bzip2</strong> 压缩</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcvf test.tar.bz2 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/1</span><br><span class="line"><span class="built_in">test</span>/2</span><br><span class="line"><span class="built_in">test</span>/5</span><br><span class="line"><span class="built_in">test</span>/4</span><br></pre></td></tr></table></figure>

<ul>
<li>解压 .tar.bz2</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf test.tar.bz2 </span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/1</span><br><span class="line"><span class="built_in">test</span>/2</span><br><span class="line"><span class="built_in">test</span>/5</span><br><span class="line"><span class="built_in">test</span>/4</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 .tar.gz 或 .tar.bz2 压缩包内的文件，但不解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ tar -ztvf test.tar.gz </span><br><span class="line">drwxrwxr-x lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/3</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/1</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/2</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/5</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/4</span><br><span class="line"></span><br><span class="line">$ tar -ztvf test.tar.bz2 </span><br><span class="line">drwxrwxr-x lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/3</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/1</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/2</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/5</span><br><span class="line">-rw-rw-r-- lin/lin           0 2020-12-21 11:38 <span class="built_in">test</span>/4</span><br></pre></td></tr></table></figure>

<ul>
<li>解压 .tar.gz 压缩包内的部分文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf test.tar.gz <span class="built_in">test</span>/2 <span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/2</span><br></pre></td></tr></table></figure>

<ul>
<li>解压 .tar.gz 到指定目录</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf test.tar.gz -C ../Download </span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/3</span><br><span class="line"><span class="built_in">test</span>/1</span><br><span class="line"><span class="built_in">test</span>/2</span><br><span class="line"><span class="built_in">test</span>/5</span><br><span class="line"><span class="built_in">test</span>/4</span><br></pre></td></tr></table></figure>

<ul>
<li>使用绝对路径打包压缩和解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩</span></span><br><span class="line">$ tar -zcPf /home/lin/share/storage_server_3/patent/grant-patent/patent_version-1.0/patent-grant-2019.tar.gz /home/lin/share/storage_server_3/patent/grant-patent/patent_version-1.0/2019</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">$ tar -zxPf patent-grant-2019.tar.gz</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>tar 对文件打包时，一般不建议使用绝对路径。</strong></p>
<p>如果使用绝对路径，需要加 -P 参数。如果不添加，会发出警告：<code>tar: Removing leading &#39;/&#39; from member names</code>。</p>
<p>对于使用绝对路径打包压缩的文件，解压时 tar 会在当前目录下创建压缩时的绝对路径所对应的目录，在上面例子中，即为在当前目录下创建一个子目录 <code>home/lin/share/storage_server_3/patent/grant-patent/patent_version-1.0</code>。</p>
<p>如果在解压时使用 -P 参数，需要保证系统存在压缩时的绝对路径。</p>
</blockquote>
<ul>
<li>使用 <strong>pigz</strong> 并发压缩和解压</li>
</ul>
<p>安装 pigz：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install pigz</span><br></pre></td></tr></table></figure>

<p>打包：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar --use-compress-program=pigz -cvpf package.tgz ./package</span><br></pre></td></tr></table></figure>

<p>解包：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar --use-compress-program=pigz -xvpf package.tgz -C ./package</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pigz 是支持并行的 gzip，默认用当前逻辑 cpu 个数来并发压缩，无法检测个数的话，则并发 8 个线程。</p>
</blockquote>
<p>另一种方式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">$ tar -cvpf - <span class="variable">$Dir</span> | pigz -9 -p 6 <span class="variable">$target</span>-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ tar -cvpf - /usr/bin | pigz -9 -p 6 bin.tgz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-9：代表压缩率<br>-p ：代表 cpu 数量</p>
</blockquote>
<h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><p>用于检测特定指令执行时所需消耗的时间及系统资源 (内存和 I/O) 等资讯。</p>
<h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time [options] COMMAND [arguments]</span><br></pre></td></tr></table></figure>

<h3 id="参数说明-11"><a href="#参数说明-11" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-o | --output=FILE</span><br><span class="line">			设定结果输出档。这个选项会将time的输出写入所指定的档案中。如果档案已经存在，系统将覆写其内容。</span><br><span class="line">		</span><br><span class="line">-a | --append</span><br><span class="line">			配合-o使用，会将结果写到档案的末端，而不会覆盖掉原来的内容。</span><br><span class="line">			</span><br><span class="line">-f FORMAT | --format=FORMAT</span><br><span class="line">			以FORMAT字串设定显示方式。当这个选项没有被设定的时候，会用系统预设的格式。不过你可以用环境变数time来设定这个格式，如此一来就不必每次登入系统都要设定一次。</span><br></pre></td></tr></table></figure>

<h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><ul>
<li>date 命令的运行时间</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time date</span><br><span class="line">Tue Dec 22 12:01:50 CST 2020</span><br><span class="line">date  0.00s user 0.01s system 8% cpu 0.092 total</span><br></pre></td></tr></table></figure>

<ul>
<li>查找文件并复制的运行时间</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time find /home/lin/share/storage_server_3/patent/application/unzip_version-1.0/2019 -iname <span class="string">&quot;*.xml&quot;</span> | xargs -P 6 -i cp &#123;&#125; /home/lin/share/storage_server_3/patent/application-patent/patent_version-1.0/2019 </span><br><span class="line">find  -iname <span class="string">&quot;*.xml&quot;</span>  24.00s user 114.39s system 1% cpu 2:08:02.95 total</span><br><span class="line">xargs -P 6 -i cp &#123;&#125;   4.35s user 28.35s system 0% cpu 2:08:02.99 total</span><br></pre></td></tr></table></figure>

<p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/linux/time.html">http://c.biancheng.net/linux/time.html</a></p>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><h3 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h3><h3 id="参数说明-12"><a href="#参数说明-12" class="headerlink" title="参数说明"></a>参数说明</h3><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><ul>
<li>创建多级目录</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p Project/a/src</span><br></pre></td></tr></table></figure>

<ul>
<li>创建多层次、多维度的目录树</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p Project/&#123;a,b,c,d&#125;/src</span><br></pre></td></tr></table></figure>

<h2 id="sh-c"><a href="#sh-c" class="headerlink" title="sh -c"></a>sh -c</h2><p>sh -c 命令，可以让 bash 将一个字串作为完整的命令来执行。</p>
<p>比如，向 test.asc 文件中随便写入点内容，可以：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;信息&quot;</span> &gt; test.asc</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;信息&quot;</span> &gt;&gt; test.asc</span><br></pre></td></tr></table></figure>

<p>下面，如果将 test.asc 权限设置为只有 root 用户才有权限进行写操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown root.root test.asc</span><br></pre></td></tr></table></figure>

<p>然后，我们使用 sudo 并配合 echo 命令再次向修改权限之后的 test.asc 文件中写入信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">echo</span> <span class="string">&quot;又一行信息&quot;</span> &gt;&gt; test.asc</span><br><span class="line">-bash: test.asc: Permission denied</span><br></pre></td></tr></table></figure>

<p>这时，可以看到 bash 拒绝这么做，说是权限不够。这是因为重定向符号 &gt; 和 &gt;&gt; 也是 bash 的命令。我们使用 sudo 只是让 echo 命令具有了 root 权限，但是没有让 &gt; 和 &gt;&gt; 命令也具有 root 权限，所以 bash 会认为这两个命令都没有向 test.asc 文件写入信息的权限。解决这一问题的途径有两种。</p>
<p>第一种是利用 sh -c 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sh -c <span class="string">&#x27;echo &quot;又一行信息&quot; &gt;&gt; test.asc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另一种方法是利用管道和 tee 命令，该命令可以从标准输入中读入信息并将其写入标准输出或文件中，具体用法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;第三条信息&quot;</span> | sudo tee -a test.asc</span><br></pre></td></tr></table></figure>

<p>注意，tee 命令的 -a 选项的作用等同于 &gt;&gt; 命令，如果去除该选项，那么 tee 命令的作用就等同于 &gt; 命令。 </p>
<h2 id="1-gt-dev-null-2-gt-amp-1"><a href="#1-gt-dev-null-2-gt-amp-1" class="headerlink" title="1&gt;/dev/null 2&gt;&amp;1"></a>1&gt;/dev/null 2&gt;&amp;1</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ithomer/article/details/9288353">https://blog.csdn.net/ithomer/article/details/9288353</a></p>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e9e0ce23a152">https://www.jianshu.com/p/e9e0ce23a152</a></p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><h2 id="md5sum"><a href="#md5sum" class="headerlink" title="md5sum"></a>md5sum</h2><h2 id="sha1sum"><a href="#sha1sum" class="headerlink" title="sha1sum"></a>sha1sum</h2><p>用来为给定的文件或文件夹计算单个哈希，以校验文件或文件夹的完整性。</p>
<p>给文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sha1sum patent-grant-2005.tar.gz </span><br><span class="line">77b6416501d34b904bd25f9aa32ca60d3e14659a  patent-grant-2005.tar.gz</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://www.itranslater.com/qa/details/2326085750774825984">https://www.itranslater.com/qa/details/2326085750774825984</a></p>
<h2 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a>parallel</h2><p><a target="_blank" rel="noopener" href="https://linux.cn/article-9718-1.html">https://linux.cn/article-9718-1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.myfreax.com/gnu-parallel/">https://www.myfreax.com/gnu-parallel/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.hi-linux.com/posts/32794.html">https://www.hi-linux.com/posts/32794.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c5a2369fa613">https://www.jianshu.com/p/c5a2369fa613</a></p>
<p><a target="_blank" rel="noopener" href="https://www.aqee.net/post/use-multiple-cpu-cores-with-your-linux-commands.html">https://www.aqee.net/post/use-multiple-cpu-cores-with-your-linux-commands.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/orangefly0214/article/details/103701600">https://blog.csdn.net/orangefly0214/article/details/103701600</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/14/java-io-close/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/14/java-io-close/" class="post-title-link" itemprop="url">java 关闭 IO 流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-14 21:54:17" itemprop="dateCreated datePublished" datetime="2020-12-14T21:54:17+08:00">2020-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-08 10:16:33" itemprop="dateModified" datetime="2021-01-08T10:16:33+08:00">2021-01-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在操作 java 流对象后要将流关闭，但实际编写代码时，可能会出现一些误区，导致不能正确关闭流。</p>
<h2 id="在-try-中关流，而没在-finally-中关流"><a href="#在-try-中关流，而没在-finally-中关流" class="headerlink" title="在 try 中关流，而没在 finally 中关流"></a>在 try 中关流，而没在 finally 中关流</h2><p>错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="comment">// ...操作流代码</span></span><br><span class="line">	out.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OutputStream out = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="comment">// ...操作流代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">			out.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在一个-try-中关闭多个流"><a href="#在一个-try-中关闭多个流" class="headerlink" title="在一个 try 中关闭多个流"></a>在一个 try 中关闭多个流</h2><p>错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">OutputStream out2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	out2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="comment">// ...操作流代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">			out.close();<span class="comment">// 如果此处出现异常，则out2流没有被关闭</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (out2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">			out2.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">OutputStream out2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	out2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="comment">// ...操作流代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">			out.close();<span class="comment">// 如果此处出现异常，则out2流也会被关闭</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (out2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">			out2.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在循环中创建流，在循环外关闭，导致关闭的是最后一个流"><a href="#在循环中创建流，在循环外关闭，导致关闭的是最后一个流" class="headerlink" title="在循环中创建流，在循环外关闭，导致关闭的是最后一个流"></a>在循环中创建流，在循环外关闭，导致关闭的是最后一个流</h2><p>错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="comment">// ...操作流代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">			out.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		<span class="comment">// ...操作流代码</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">				out.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在-java-7-中，关闭流的方式得到很大的简化"><a href="#在-java-7-中，关闭流的方式得到很大的简化" class="headerlink" title="在 java 7 中，关闭流的方式得到很大的简化"></a>在 java 7 中，关闭流的方式得到很大的简化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">	<span class="comment">// ...操作流代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要实现的自动关闭接口 (Closeable) 的类都可以在 try 结构体上定义，java 会自动帮我们关闭，即使在发生异常的情况下也会。</p>
<p>可以在 try 结构体上定义多个，用分号隔开即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">     OutputStream out2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">	<span class="comment">// ...操作流代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Android SDK 20 版本对应 java 7，低于 20 版本无法使用 <code>try-catch-resources</code> 自动关流。</p>
</blockquote>
<h2 id="内存流的关闭"><a href="#内存流的关闭" class="headerlink" title="内存流的关闭"></a>内存流的关闭</h2><p>内存流可以不用关闭。</p>
<p>ByteArrayOutputStream 和 ByteArrayInputStream 其实是伪装成流的字节数组 (把它们当成字节数据来看就好了)，他们不会锁定任何文件句柄和端口，如果不再被使用，字节数组会被垃圾回收掉，所以不需要关闭。</p>
<h2 id="装饰流的关闭"><a href="#装饰流的关闭" class="headerlink" title="装饰流的关闭"></a>装饰流的关闭</h2><p>装饰流是指通过装饰模式实现的 java 流，又称为包装流，装饰流只是为原生流附加额外的功能或效果，java 中的缓冲流、桥接流也是属于装饰流。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\tang\\Desktop\\test.txt&quot;</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String string = br.readLine();</span><br><span class="line">System.out.println(string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要关闭最后的br即可</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    br.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰流关闭时会调用原生流关闭。</p>
<p>BufferedReader.java 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的in就是原生流</span></span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            in = <span class="keyword">null</span>;</span><br><span class="line">            cb = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputStreamReader.java 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的sd就是原生流的解码器(StreamDecoder)，解码器的close会调用原生流的close</span></span><br><span class="line">    sd.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，有这样层层关闭的机制，我们就只需要关闭最外层的流就行了。</p>
<h2 id="关闭流的顺序问题"><a href="#关闭流的顺序问题" class="headerlink" title="关闭流的顺序问题"></a>关闭流的顺序问题</h2><p>两个不相干的流的关闭顺序没有任何影响，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的out1和out2谁先关谁后关都一样，没有任何影响</span></span><br><span class="line">out1 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">out2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果两个流有依赖关系，那么可以像上面说的，只关闭最外层的即可。</p>
<p>如果不嫌麻烦，非得一个个关闭，那么需要先关闭最里层，从里往外一层层进行关闭。</p>
<p>为什么不能从外层往里层逐步关闭？原因上面讲装饰流已经讲的很清楚了，关闭外层时，内层的流其实已经同时关闭了，你再去关内层的流，就会报错。</p>
<p>至于网上说的先声明先关闭，就是这个道理，先声明的是内层，最先申明的是最内层，最后声明的是最外层。</p>
<h2 id="一定要关闭流的原因"><a href="#一定要关闭流的原因" class="headerlink" title="一定要关闭流的原因"></a>一定要关闭流的原因</h2><p>一个流绑定了一个文件句柄 (或网络端口)，如果流不关闭，该文件 (或端口) 将始终处于被锁定 (不能读取、写入、删除和重命名) 状态，占用大量系统资源却没有释放。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012643122/article/details/38540721">https://blog.csdn.net/u012643122/article/details/38540721</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/27/java-io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/27/java-io/" class="post-title-link" itemprop="url">java 的 IO 流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-27 11:33:09" itemprop="dateCreated datePublished" datetime="2020-11-27T11:33:09+08:00">2020-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-08 12:03:54" itemprop="dateModified" datetime="2021-01-08T12:03:54+08:00">2021-01-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>44k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>每次在使用 IO 流之前，应该做到明确分析如下四点：</p>
<ul>
<li>明确要操作的数据是数据源还是数据目的，也就是要读还是要写；</li>
</ul>
<blockquote>
<p>数据源：<strong>InputStream、Reader</strong></p>
<p>数据目的：<strong>OutputStream、Writer</strong></p>
</blockquote>
<ul>
<li>明确要操作的设备上的数据是字节还是文本；</li>
</ul>
<blockquote>
<p>数据源：字节 —— <strong>InputStream</strong>，字符 —— <strong>Reader</strong></p>
<p>数据目的：L字节 —— <strong>OutputStream</strong>，字符 —— <strong>Writer</strong></p>
</blockquote>
<ul>
<li>明确数据所在的具体设备；</li>
</ul>
<blockquote>
<p>数据源设备：硬盘 —— 文件 File 开头；内存 —— 数组，字符串；屏幕 —— System.in；网络 —— Scoket</p>
<p>数据目的设备：硬盘 —— 文件 File 开头；内存 —— 数组，字符串；屏幕 —— System.out；网络—— Scoket</p>
</blockquote>
<ul>
<li>明确是否需要额外功能，比如是否需要转换流、高效流等。</li>
</ul>
<blockquote>
<p>需要转换：转换流 —— <strong>InputStreamReader 、OutputStreamWriter</strong></p>
<p>需要高效：缓冲流 —— <strong>Bufferedxxx</strong></p>
<p>多个源：序列流 —— <strong>SequenceInputStream</strong></p>
<p>对象序列化：<strong>ObjectInputStream、ObjectOutputStream</strong></p>
<p>保证数据的输出形式：打印流 —— <strong>PrintStream 、Printwriter</strong></p>
<p>操作基本数据，保证字节原样性：<strong>DataOutputStream、DataInputStream</strong></p>
</blockquote>
<p>到这，先看看 IO 流的分类：</p>
<p><img src="/2020/11/27/java-io/16e24b55ba517f0a" alt="在这里插入图片描述"></p>
<h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>说到 IO 流，也就是输入输出流，从文件出发到文件结束，至始至终都离不开文件，所以 IO 流还得从文件 File 类讲起。</p>
<h3 id="File-概述"><a href="#File-概述" class="headerlink" title="File  概述"></a>File  概述</h3><p><code>java.io.File</code> 类是专门对文件进行操作的类，只能对文件本身进行操作，不能对文件内容进行操作。 <code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<p>怎么理解上面两句话？其实很简单！</p>
<p>第一句就是说 File 跟流无关，File 类不能对文件进行读和写也就是输入和输出！第二句就是说 File 主要表示类似 <code>D:\\文件目录1</code> 与 <code>D:\\文件目录1\\文件.txt</code>，前者是文件夹 (Directory)，后者则是文件 (file)，而 File 类就是操作这两者的类。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在 java 中，一切皆是对象，File 类也不例外，不论是哪个对象都应该从该对象的构造方法说起：</p>
<p><img src="/2020/11/27/java-io/16e24b518cfbd082" alt="img"></p>
<p>我们主要来学习一下比较常用的三个：</p>
<ol>
<li> <code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File 实例。</li>
<li> <code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File 实例。</li>
<li> <code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File 实例。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过文件路径名 </span></span><br><span class="line">String path1 = <span class="string">&quot;D:\\123.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(path1); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过文件路径名</span></span><br><span class="line">String path2 = <span class="string">&quot;D:\\1\\2.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path2);     -------------相当于d:\\<span class="number">1</span>\\<span class="number">2.</span>txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;F:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);  --------相当于f:\\aaa\\bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;F:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child); --------相当于f:\\aaa\\bbb.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>一个 File 对象代表硬盘中实际存在的一个文件或者目录。</p>
</li>
<li><p>File 类构造方法不会检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。</p>
</li>
</ol>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>File 的常用方法主要分为获取功能、获取绝对路径和相对路径功能、判断功能、创建删除功能。</p>
<h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ol>
<li> <code>public String getAbsolutePath()</code> ：返回此 File 的绝对路径名字符串。</li>
<li> <code>public String getPath()</code> ：将此 File 转换为路径名字符串。</li>
<li> <code>public String getName()</code>  ：返回由此 File 表示的文件或目录的名称。</li>
<li> <code>public long length()</code>  ：返回由此 File 表示的文件的长度。</li>
</ol>
<p>以上方法测试，代码如下【注意测试以自己的电脑文件夹为准】：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;f:/test/a.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span> + f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span> + f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span> + f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span> + f.length() + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;f:/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span> + f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span> + f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span> + f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span> + f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径: f:\test\a.txt</span><br><span class="line">文件构造路径: f:\test\a.txt</span><br><span class="line">文件名称: a.txt</span><br><span class="line">文件长度: <span class="number">7</span>字节</span><br><span class="line">    </span><br><span class="line">目录绝对路径: f:\test</span><br><span class="line">目录构造路径: f:\test</span><br><span class="line">目录名称: test</span><br><span class="line">目录长度: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>length()</code> 方法，表示文件的长度。但是如果 File 对象表示目录，则返回值未指定。</p>
</blockquote>
<h4 id="获取绝对路径和相对路径功能的方法"><a href="#获取绝对路径和相对路径功能的方法" class="headerlink" title="获取绝对路径和相对路径功能的方法"></a>获取绝对路径和相对路径功能的方法</h4><p><strong>绝对路径</strong>：一个完整的路径，以盘符开头，例如 <code>f:/aaa.txt</code>。 </p>
<p><strong>相对路径</strong>：一个简化的路径，不以盘符开头，例如 <code>/aaa.tx</code>。</p>
<blockquote>
<ol>
<li><strong>路径不区分大小写。</strong></li>
<li>路径中的文件名称分隔符 windows 使用反斜杠，反斜杠是转义字符，两个反斜杠代表一个普通的反斜杠。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// d盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\bbb.java</span><br><span class="line">d:\java\bbb.java</span><br></pre></td></tr></table></figure>

<h4 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h4><ol>
<li> <code>public boolean exists()</code> ：此 File 表示的文件或目录是否实际存在。</li>
<li> <code>public boolean isDirectory()</code> ：此 File 表示的是否为目录。 </li>
<li> <code>public boolean isFile()</code> ：此 File 表示的是否为文件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在: &quot;</span> + f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在: &quot;</span> + f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?: &quot;</span> + f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?: &quot;</span> + f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在: <span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在: <span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?: <span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h4 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h4><ol>
<li> <code>public boolean createNewFile()</code> ：文件不存在，创建一个新的空文件并返回 true，文件存在，不创建文件并返回 false。</li>
<li> <code>public boolean delete()</code> ：删除由此 File 表示的文件或目录。</li>
<li> <code>public boolean mkdir()</code> ：创建由此 File 表示的目录。</li>
<li> <code>public boolean mkdirs()</code> ：创建由此 File 表示的目录，包括任何必需但不存在的父目录。</li>
</ol>
<p>其中，<code>mkdir()</code> 和 <code>mkdirs()</code> 方法类似，但 <code>mkdir()</code>，只能创建一级目录，<code>mkdirs()</code> 可以创建多级目录，比如 <code>/a/b/c</code>，所以开发中一般用 <code>mkdirs()</code> 方法。</p>
<blockquote>
<p><code>delete()</code> 方法，如果此 File 表示目录，则目录必须为空才能删除。</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在: &quot;</span> + f.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建: &quot;</span> + f.createNewFile());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建: &quot;</span> + f.createNewFile());<span class="comment">// 已经创建过了所以再使用createNewFile返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在: &quot;</span> + f.exists());<span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2 = <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在: &quot;</span> + f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建: &quot;</span> + f2.mkdir());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在: &quot;</span> + f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3 = <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h4><ol>
<li> <code>public String[] list()</code> ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</li>
<li> <code>public File[] listFiles()</code> ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。</li>
</ol>
<p>其中，<code>listFiles()</code> 在获取指定目录下的文件或者文件夹时必须满足下面两个条件：</p>
<ul>
<li><p><strong>指定的目录必须存在；</strong></p>
</li>
<li><p><strong>指定的必须是目录，否则容易引发返回数组为 null，出现 NullPointerException 异常。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;G:\\光标&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 获取当前目录下的文件以及文件夹的名称</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/27/java-io/16e24b518d0b6007" alt="在这里插入图片描述"></p>
<h4 id="递归遍历文件夹下所有文件以及子文件"><a href="#递归遍历文件夹下所有文件以及子文件" class="headerlink" title="递归遍历文件夹下所有文件以及子文件"></a>递归遍历文件夹下所有文件以及子文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归遍历文件夹下所有的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionDirectory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\java专属IO测试&quot;</span>);</span><br><span class="line">        Recursion(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Recursion</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断传入的是否是目录</span></span><br><span class="line">        <span class="keyword">if</span> (!file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 不是目录直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经确保了传入的file是目录</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">// 遍历files</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="comment">// 如果该目录下文件还是个文件夹就再进行递归遍历其子目录</span></span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                Recursion(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果该目录下文件是个文件，则打印对应的名字</span></span><br><span class="line">                System.out.println(f.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初探-IO-流"><a href="#初探-IO-流" class="headerlink" title="初探 IO 流"></a>初探 IO 流</h2><h3 id="什么是-IO"><a href="#什么是-IO" class="headerlink" title="什么是 IO"></a>什么是 IO</h3><p>数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入 input 和输出 output，即流向内存是输入流，流出内存的输出流。</p>
<p>java 中 I/O 操作主要是指使用 <code>java.io</code> 包下的内容，进行输入、输出操作。<strong>输入也叫做读取数据，输出也叫做作写出数据</strong>。</p>
<h3 id="IO-的分类"><a href="#IO-的分类" class="headerlink" title="IO 的分类"></a>IO 的分类</h3><ol>
<li>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</li>
</ol>
<ul>
<li><strong>输入流</strong> ：把数据从<strong>其他设备</strong>上读取到<strong>内存</strong>中的流。</li>
<li><strong>输出流</strong> ：把数据从<strong>内存</strong>中写出到<strong>其他设备</strong>上的流。</li>
</ul>
<ol start="2">
<li>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</li>
</ol>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<p>分类之后对应的超类 (超类也就是父类的意思)：</p>
<table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字节流</strong></td>
<td>字节输入流： <strong>InputStream</strong></td>
<td>字节输出流： <strong>OutputStream</strong></td>
</tr>
<tr>
<td><strong>字符流</strong></td>
<td>字符输入流： <strong>Reader</strong></td>
<td>字符输出流： <strong>Writer</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>这四个类的子类的名称基本都是以其父类名作为子类名的后缀。</strong>如：InputStream 的子类 FileInputStream，Reader 的子类 FileReader。</p>
</blockquote>
<p><img src="/2020/11/27/java-io/16e24b518d03dfc0" alt="在这里插入图片描述"></p>
<h3 id="关于-IO-的分流向说明"><a href="#关于-IO-的分流向说明" class="headerlink" title="关于 IO 的分流向说明"></a>关于 IO 的分流向说明</h3><p><img src="/2020/11/27/java-io/16e24b518d3549a2" alt="img"></p>
<p><img src="/2020/11/27/java-io/16e24b518d2e797b" alt="img"></p>
<h2 id="字节流-InputStream-与-OutputStream"><a href="#字节流-InputStream-与-OutputStream" class="headerlink" title="字节流 InputStream 与 OutputStream"></a>字节流 InputStream 与 OutputStream</h2><p>InputStream 与 OutputStream的继承关系：</p>
<p><img src="/2020/11/27/java-io/16e24b5194c7004e" alt="在这里插入图片描述"></p>
<h3 id="文件的世界里一切皆为字节"><a href="#文件的世界里一切皆为字节" class="headerlink" title="文件的世界里一切皆为字节"></a>文件的世界里一切皆为字节</h3><p>我们必须明确一点的是，<strong>一切文件数据 (文本、图片、视频等) 在存储时，都是以二进制数字的形式保存，都是一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。</strong>在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h3 id="字节输入流-InputStream"><a href="#字节输入流-InputStream" class="headerlink" title="字节输入流 InputStream"></a>字节输入流 InputStream</h3><p><code>java.io.InputStream</code> 抽象类是表示<strong>字节输入流</strong>的所有类的<strong>超类</strong> (父类)，可以读取字节信息到内存中，它定义了字节输入流的基本共性功能方法。</p>
<p><strong>字节输入流的基本共性功能方法：</strong></p>
<ol>
<li> <code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。</li>
<li> <code>public abstract int read()</code>： 从输入流读取数据的下一个字节。</li>
<li> <code>public int read(byte[] b)</code>： 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回 -1。</li>
</ol>
<h4 id="FileInputStream-类"><a href="#FileInputStream-类" class="headerlink" title="FileInputStream 类"></a>FileInputStream 类</h4><p><code>java.io.FileInputStream</code> 类是文件输入流，从文件中读取字节。</p>
<h5 id="FileInputStream-的构造方法"><a href="#FileInputStream-的构造方法" class="headerlink" title="FileInputStream 的构造方法"></a>FileInputStream 的构造方法</h5><ol>
<li> <code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。</li>
<li> <code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。</li>
</ol>
<p>推荐使用第二种构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件，会抛出 <code>FileNotFoundException</code> 。</p>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos2 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FileInputStream-读取字节数据"><a href="#FileInputStream-读取字节数据" class="headerlink" title="FileInputStream 读取字节数据"></a>FileInputStream 读取字节数据</h5><p><strong>1. 读取单个字节</strong>：<code>read() </code>方法，每次可以读取一个字节的数据，返回为 int 类型，读取到文件末尾，返回 -1。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，read.txt文件中内容为：abcde</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        <span class="comment">// 读取到末尾，返回-1</span></span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>流操作完毕后，必须释放系统资源，调用 <code>close()</code> 方法，千万记得。</p>
</blockquote>
<p>循环改进读取方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，read.txt文件中内容为：abcde</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取 b 的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回 -1。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，read.txt文件中内容为：abcde</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次读取后，把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>由于 read.txt 文件中内容为 <code>abcde</code>，而错误数据 <code>d</code>，是由于最后一次读取时，只读取一个字节 <code>e</code>，数组中，上次读取的数据没有被完全<strong>替换</strong>【注意是替换，看下图】，所以要通过 <code>len</code> ，获取有效的字节。</p>
<p><img src="/2020/11/27/java-io/16e24b5193e018a1" alt="在这里插入图片描述"></p>
<p>改进代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，read.txt文件中内容为：abcde</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，作为每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次读取后，把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>在开发中一般推荐使用数组读取文件，整体优化代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>

<h3 id="字节输出流-OutputStream"><a href="#字节输出流-OutputStream" class="headerlink" title="字节输出流 OutputStream"></a>字节输出流 OutputStream</h3><p><code>java.io.OutputStream</code> 抽象类是表示<strong>字节输出流</strong>的所有类的<strong>超类</strong> (父类)，将指定的字节信息写出到目的地，它定义了字节输出流的基本共性功能方法。</p>
<p><strong>字节输出流的基本共性功能方法：</strong></p>
<ol>
<li> <code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li>
<li> <code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li>
<li> <code>public void write(byte[] b)</code>：将 b.length 个字节从指定的字节数组写入此输出流。</li>
<li> <code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流，<strong>也就是说从 off 个字节数开始读取一直到 len 个字节结束</strong> 。</li>
<li> <code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ol>
<blockquote>
<p>以上五个方法是字节输出流都具有的方法，由父类 OutputStream 定义提供，子类都会共享以上方法。</p>
</blockquote>
<h4 id="FileOutputStream-类"><a href="#FileOutputStream-类" class="headerlink" title="FileOutputStream 类"></a>FileOutputStream 类</h4><p><code>java.io.FileOutputStream</code> 类是文件输出流，向文件中写入字节。</p>
<h5 id="FileOutputStream-的构造方法"><a href="#FileOutputStream-的构造方法" class="headerlink" title="FileOutputStream 的构造方法"></a>FileOutputStream 的构造方法</h5><ol>
<li> <code>public FileOutputStream(File file)</code>：根据 File 对象为参数创建对象。</li>
<li> <code>public FileOutputStream(String name)</code>： 根据名称字符串为参数创建对象。</li>
</ol>
<p>推荐使用第二种构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上面这句代码来讲，类似这样创建字节输出流对象都做了<strong>三件事情</strong>： </p>
<ol>
<li>调用系统功能去创建文件，输出流对象会自动创建；</li>
<li>创建 outputStream 对象；</li>
<li>把 outputStream 对象指向这个文件。</li>
</ol>
<blockquote>
<p>创建输出流对象的时候，系统会自动去对应位置创建对应文件，而创建输入流对象的时候，文件不存在会报 <code>FileNotFoundException</code> 异常，也就是系统找不到指定的文件异常。</p>
</blockquote>
<p>当创建一个流对象时，必须直接或者间接传入一个文件路径。比如现在我们创建一个 <code>FileOutputStream</code> 流对象，在该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\自动创建的文件夹\\a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FileOutputStream-写出字节数据"><a href="#FileOutputStream-写出字节数据" class="headerlink" title="FileOutputStream 写出字节数据"></a>FileOutputStream 写出字节数据</h5><p>使用 FileOutputStream 写出字节数据主要通过 <code>write()</code> 方法，而<code>write()</code> 方法分如下三种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  <span class="comment">// 从off索引开始，len个字节</span></span></span><br></pre></td></tr></table></figure>

<p><strong>1. 写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        fos.write(<span class="number">97</span>);<span class="comment">// 写出第1个字节</span></span><br><span class="line">        fos.write(<span class="number">98</span>);<span class="comment">// 写出第2个字节</span></span><br><span class="line">        fos.write(<span class="number">99</span>);<span class="comment">// 写出第3个字节</span></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出。</p>
</blockquote>
<p><strong>2. 写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="string">&quot;麻麻我想吃烤山药&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">// 写出字节数组数据</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">麻麻我想吃烤山药</span><br></pre></td></tr></table></figure>

<p><strong>3. 写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code>，每次写出从 off 索引开始，len 个字节。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">// 写出从索引2开始，2个字节。索引2是c，2个字节，也就是cd。</span></span><br><span class="line">        fos.write(b, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<h5 id="FileOutputStream-实现数据追加续写、换行"><a href="#FileOutputStream-实现数据追加续写、换行" class="headerlink" title="FileOutputStream 实现数据追加续写、换行"></a>FileOutputStream 实现数据追加续写、换行</h5><p>经过以上的代码测试，每次程序运行时创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续追加新数据呢？并且实现换行呢？其实很简单，这个时候我们又要再学习 <code>FileOutputStream</code> 的另外两个构造方法了，如下：</p>
<ol>
<li> <code>public FileOutputStream(File file, boolean append)</code></li>
<li> <code>public FileOutputStream(String name, boolean append)</code></li>
</ol>
<p>这两个构造方法，第二个参数中都需要传入一个 boolean 类型的值，true  表示追加数据，false 表示不追加也就是清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，至于 windows 系统换行符是 <code>\r\n</code> ，下面将会详细讲到。</p>
<p>实现数据追加续写代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">        fos.write(b);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>

<p>Windows系统里，换行符号是<code>\r\n</code> ,具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>&#125;;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> word : words) &#123;</span><br><span class="line">            <span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(word);</span><br><span class="line">            <span class="comment">// 写出一个换行，换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回车符 <code>\r</code> 和换行符 <code>\n</code>：</p>
<ul>
<li>回车符：回到一行的开头 (return)。</li>
<li>换行符：下一行 (newline)。</li>
</ul>
<p>不同系统中的换行：</p>
<ul>
<li>Windows系统里，每行结尾是 <code>回车 + 换行</code> ，即 <code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即 <code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即 <code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
<h3 id="FileInputStream-和-FileOutputStream-完成图片复制"><a href="#FileInputStream-和-FileOutputStream-完成图片复制" class="headerlink" title="FileInputStream 和 FileOutputStream 完成图片复制"></a>FileInputStream 和 FileOutputStream 完成图片复制</h3><p>复制图片原理：</p>
<p><img src="/2020/11/27/java-io/16e24b51938be9da" alt="在这里插入图片描述"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.指定数据源fis和目的地fos</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:/test.png&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/test_copy.jpg&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.读和写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制文本、图片、mp3、视频等的方式一样。</p>
</blockquote>
<h2 id="字符流-Reader-和-Writer"><a href="#字符流-Reader-和-Writer" class="headerlink" title="字符流 Reader 和 Writer"></a>字符流 Reader 和 Writer</h2><p>Reader 和 Writer 的继承关系：</p>
<p><img src="/2020/11/27/java-io/16e24b519317184b" alt="在这里插入图片描述"></p>
<h3 id="字符流的由来"><a href="#字符流的由来" class="headerlink" title="字符流的由来"></a>字符流的由来</h3><p>因为数据编码的不同，因而有了对字符进行高效操作的流对象，字符流本质其实就是基于字节流读取时，去查了指定的码表，而字节流直接读取数据会有乱码的问题 (读中文会乱码)。举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// FileInputStream为操作文件的字符输入流，read.txt内容为：测试用例</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">æµè¯ç¨ä¾</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字节流读取中文字符时，可能不会显示完整的字符，那是因为一个中文字符占用多个字节存储。</p>
</blockquote>
<p>如果不想乱码，可以用下面的方式，但比较繁琐：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// FileInputStream为操作文件的字符输入流，read.txt内容为：测试用例</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，解码的是 <code>String</code>，查看 <code>new String()</code> 的源码，<code>String</code> 构造方法有解码功能，并且默认编码是 <code>utf-8</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>[] decode(<span class="keyword">byte</span>[] ba, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    String csn = Charset.defaultCharset().name();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// use charset name decode() variant which provides caching.</span></span><br><span class="line">        <span class="keyword">return</span> decode(csn, ba, off, len);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException x) &#123;</span><br><span class="line">        warnUnsupportedCharset(csn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decode(<span class="string">&quot;ISO-8859-1&quot;</span>, ba, off, len);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException x) &#123;</span><br><span class="line">        <span class="comment">// If this code is hit during VM initialization, MessageUtils is</span></span><br><span class="line">        <span class="comment">// the only way we will be able to get any kind of error message.</span></span><br><span class="line">        MessageUtils.err(<span class="string">&quot;ISO-8859-1 charset not available: &quot;</span></span><br><span class="line">                         + x.toString());</span><br><span class="line">        <span class="comment">// If we can not find ISO-8859-1 (a required encoding) then things</span></span><br><span class="line">        <span class="comment">// are seriously wrong with the installation.</span></span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title">defaultCharset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultCharset == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Charset.class) &#123;</span><br><span class="line">            String csn = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> GetPropertyAction(<span class="string">&quot;file.encoding&quot;</span>));</span><br><span class="line">            Charset cs = lookup(csn);</span><br><span class="line">            <span class="keyword">if</span> (cs != <span class="keyword">null</span>)</span><br><span class="line">                defaultCharset = cs;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                defaultCharset = forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultCharset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，尽管字节流也能解决乱码问题，但是比较麻烦，于是 java 就有了字符流，以字符为单位读写数据，字符流专门用于处理文本文件。如果处理纯文本的数据，优先考虑字符流，其他情况就只能用字节流了 (图片、视频、等等只文本例外)。</p>
<blockquote>
<p>从另一角度来说：字符流 = 字节流 + 编码表。</p>
</blockquote>
<h3 id="字符输入流-Reader"><a href="#字符输入流-Reader" class="headerlink" title="字符输入流 Reader"></a>字符输入流 Reader</h3><p><code>java.io.Reader </code> 抽象类是<strong>字符输入流</strong>的所有类的<strong>超类</strong> (父类)，可以读取字符信息到内存中，它定义了字符输入流的基本共性功能方法。</p>
<p><strong>字符输入流的共性方法：</strong></p>
<ol>
<li> <code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。</li>
<li> <code>public int read()</code>： 从输入流读取一个字符。</li>
<li> <code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中。</li>
</ol>
<h4 id="FileReader-类"><a href="#FileReader-类" class="headerlink" title="FileReader 类"></a>FileReader 类</h4><p><code>java.io.FileReader</code> 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h5 id="FileReader-的构造方法"><a href="#FileReader-的构造方法" class="headerlink" title="FileReader 的构造方法"></a>FileReader 的构造方法</h5><ol>
<li> <code>public FileReader(File file)</code>： 创建一个新的 FileReader，给定要读取的 <strong>File 对象</strong>。</li>
<li> <code>public FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的<strong>字符串名称</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr2 = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FileReader-读取字符数据"><a href="#FileReader-读取字符数据" class="headerlink" title="FileReader 读取字符数据"></a>FileReader 读取字符数据</h5><p><strong>读取字符</strong>：<code>read() </code>方法，每次可以读取一个字符的数据，返回为 int 类型，读取到文件末尾，返回 -1，循环读取。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符输出流-Writer"><a href="#字符输出流-Writer" class="headerlink" title="字符输出流 Writer"></a>字符输出流 Writer</h3><p><code>java.io.Writer</code> 抽象类是<strong>字符输出流</strong>的所有类的<strong>超类</strong> (父类)，将指定的字符信息写出到目的地，它同样定义了字符输出流的基本共性功能方法。</p>
<p><strong>字符输出流的基本共性功能方法：</strong></p>
<ol>
<li> <code>void write(int c)</code>：写入单个字符。</li>
<li> <code>void write(char[] cbuf)</code>：写入字符数组。</li>
<li> <code>abstract void write(char[] cbuf, int off, int len)</code>：写入字符数组的某一部分，off 数组的开始索引，len 写的字符个数。</li>
<li> <code>void write(String str)</code>：写入字符串。</li>
<li> <code>void write(String str, int off, int len)</code>：写入字符串的某一部分，off 字符串的开始索引，len 写的字符个数。</li>
<li> <code>void flush()</code>：刷新该流的缓冲。</li>
<li> <code>void close()</code> ：关闭此流，但要先刷新它。</li>
</ol>
<h4 id="FileWriter-类"><a href="#FileWriter-类" class="headerlink" title="FileWriter 类"></a>FileWriter 类</h4><p><code>java.io.FileWriter</code> 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h5 id="FileWriter-的构造方法"><a href="#FileWriter-的构造方法" class="headerlink" title="FileWriter 的构造方法"></a>FileWriter 的构造方法</h5><ol>
<li> <code>public FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的 File 对象。</li>
<li> <code>public FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种：使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种：使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw2 = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FileWriter-写出字符数据"><a href="#FileWriter-写出字符数据" class="headerlink" title="FileWriter 写出字符数据"></a>FileWriter 写出字符数据</h5><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">        fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关闭资源时，与 FileOutputStream 不同，必须执行 <code>close()</code> 方法，如果不关闭，数据只是保存到缓冲区，并未保存到文件。</p>
</blockquote>
<h5 id="关闭-close-方法和刷新-flush-方法"><a href="#关闭-close-方法和刷新-flush-方法" class="headerlink" title="关闭 close() 方法和刷新 flush() 方法"></a>关闭 <code>close()</code> 方法和刷新 <code>flush()</code> 方法</h5><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要 <code>flush()</code> 方法了。</p>
<p><code>flush()</code>：刷新缓冲区，流对象可以继续使用。</p>
<p><code>close()</code>：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlushDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 源   也就是输入流【读取流】 读取read.txt文件，必须要存在read.txt文件，否则报FileNotFoundException异常</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 目的地  也就是输出流，系统会自动创建write.txt，因为它是输出流！</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/write.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里没有使用close关闭流，开发中不能这样做，但是可以更好的体会flush的作用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码执行完后，因为没有关闭流，write.txt 文件中依旧会是空的。在上面代码中再添加下面三句代码，write.txt 文件就能复制到源文件的数据了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fr.close();</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>

<p><code>flush()</code> 方法是清空的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再写到文件中，那么当你数据读完时，如果这时调用 <code>close()</code> 方法关闭读写流，就可能造成数据丢失，为什么呢？因为，读入数据完成时不代表写入数据完成，一部分数据可能会留在缓存区中，这个时候使用 <code>flush()</code> 方法就格外重要了。</p>
<p><code>close()</code> 方法使用代码示意如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即便是 <code>flush()</code> 方法写出了数据，操作的最后还是要调用 <code>close()</code> 方法，释放系统资源。</p>
</blockquote>
<h5 id="FileWriter-的追加和换行"><a href="#FileWriter-的追加和换行" class="headerlink" title="FileWriter 的追加和换行"></a>FileWriter 的追加和换行</h5><p><strong>追加和换行</strong>：操作类似于 FileOutputStream 操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，true代表可以追加数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/fw.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出换行</span></span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;用例&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">在fw.txt内容的后面，追加：</span><br><span class="line">测试</span><br><span class="line">用例</span><br></pre></td></tr></table></figure>

<h4 id="FileReader-和-FileWriter-完成文本文件复制"><a href="#FileReader-和-FileWriter-完成文本文件复制" class="headerlink" title="FileReader 和 FileWriter 完成文本文件复制"></a>FileReader 和 FileWriter 完成文本文件复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建输入流对象，若文件不存在会抛出java.io.FileNotFoundException</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/copyread.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*创建输出流做的工作：</span></span><br><span class="line"><span class="comment">         *  1.调用系统资源创建了一个文件</span></span><br><span class="line"><span class="comment">         *  2.创建输出流对象</span></span><br><span class="line"><span class="comment">         *  3.把输出流对象指向文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文本文件复制，一次读一个字符</span></span><br><span class="line">        copyMethod1(fr, fw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文本文件复制，一次读一个字符数组</span></span><br><span class="line">        copyMethod2(fr, fw);</span><br><span class="line"></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.close();</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMethod1</span><span class="params">(FileReader fr, FileWriter fw)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch = fr.read()) != -<span class="number">1</span>) &#123;<span class="comment">// 读数据</span></span><br><span class="line">            fw.write(ch);<span class="comment">// 写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMethod2</span><span class="params">(FileReader fr, FileWriter fw)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(chs)) != -<span class="number">1</span>) &#123;<span class="comment">// 读数据</span></span><br><span class="line">            fw.write(chs, <span class="number">0</span>, len);<span class="comment">// 写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时，使用字符流，其他情况使用字节流。</p>
</blockquote>
<h2 id="IO-异常的处理"><a href="#IO-异常的处理" class="headerlink" title="IO 异常的处理"></a>IO 异常的处理</h2><p>我们在学习的过程中可能习惯把异常抛出，而实际开发中并不能这样处理，建议使用 <code>try...catch...finally</code> 代码块，处理异常部分，代码格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;测试用例&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>缓冲流，也叫高效流，是对4个 <code>FileXxx</code> 流的 “增强流”。</p>
<p><strong>缓冲流的基本原理：</strong></p>
<ol>
<li> 使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。</li>
<li> 通过缓冲区的 <code>read()</code> 方法从缓冲区获取具体的字符数据，这样就提高了效率。</li>
<li> 如果用 <code>read()</code> 方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了 <code>readLine()</code> 功能。</li>
</ol>
<p>也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统 IO 次数，从而提高读写的效率。</p>
<p>缓冲流书写格式为 <code>BufferedXxx</code>，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code></li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<h3 id="字节缓冲流-BufferedInputStream-和-BufferedOutputStream"><a href="#字节缓冲流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="字节缓冲流 BufferedInputStream 和 BufferedOutputStream"></a>字节缓冲流 BufferedInputStream 和 BufferedOutputStream</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为 <strong>InputStream</strong>。</li>
<li> <code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为 <strong>OutputStream</strong>。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/write.txt&quot;</span>);) &#123;</span><br><span class="line">            <span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高效的字节缓冲流"><a href="#高效的字节缓冲流" class="headerlink" title="高效的字节缓冲流"></a>高效的字节缓冲流</h4><p>缓冲流读写方法与基本的流是一致的，我们通过复制 370 多 MB 的大文件，测试它的效率。</p>
<p>基本流，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/write.txt&quot;</span>);) &#123;</span><br><span class="line">            <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲流，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/write.txt&quot;</span>);) &#123;</span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，缓冲流能明显提高效率。</p>
<p><strong>上述代码还能通过定义数组，来进一步优化</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/write.txt&quot;</span>);) &#123;</span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流优化后的复制时间:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流-BufferedReader-和-BufferedWriter"><a href="#字符缓冲流-BufferedReader-和-BufferedWriter" class="headerlink" title="字符缓冲流 BufferedReader 和 BufferedWriter"></a>字符缓冲流 BufferedReader 和 BufferedWriter</h3><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为 <strong>Reader</strong>。</li>
<li> <code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为 <strong>Writer</strong>。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/writer.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">            BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            <span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">            BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高效的字符缓冲流"><a href="#高效的字符缓冲流" class="headerlink" title="高效的字符缓冲流"></a>高效的字符缓冲流</h4><p>此处与字节缓冲流类似，优化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/writer.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">char</span>[] bytes = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bfr.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bfw.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流优化后的复制时间:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符缓冲流的特有方法"><a href="#字符缓冲流的特有方法" class="headerlink" title="字符缓冲流的特有方法"></a>字符缓冲流的特有方法</h4><p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的<strong>特有方法</strong>：</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>：<strong>读一行数据</strong>，读取到最后返回 null。</li>
<li>BufferedWriter：<code>public void newLine()</code>:：<strong>换行</strong>，由系统属性定义符号。</li>
</ul>
<p><code>readLine()</code> 方法示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLineDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            <span class="comment">// 定义字符串，保存读取的一行文字</span></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 循环读取，读取到最后返回null</span></span><br><span class="line">            <span class="keyword">while</span> ((line = bfr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">                System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            bfr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newLine()</code> 方法示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewLineDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/write.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">            bfw.write(<span class="string">&quot;测&quot;</span>);</span><br><span class="line">            <span class="comment">// 换行</span></span><br><span class="line">            bfw.newLine();</span><br><span class="line">            bfw.write(<span class="string">&quot;试&quot;</span>);</span><br><span class="line">            bfw.newLine();</span><br><span class="line">            bfw.write(<span class="string">&quot;用&quot;</span>);</span><br><span class="line">            bfw.newLine();</span><br><span class="line">            bfw.write(<span class="string">&quot;例&quot;</span>);</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            bfw.flush();</span><br><span class="line">            bfw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">测</span><br><span class="line">试</span><br><span class="line">用</span><br><span class="line">例</span><br></pre></td></tr></table></figure>

<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>众所周知，计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。注意，<strong>编码规则和解码规则要对应，否则会导致乱码。</strong>比如说，按照 A 规则存储，同样按照 A 规则解析，那么就能显示正确的文本符号。反之，按照 A 规则存储，再按照 B 规则解析，就会导致乱码现象。</p>
<p><img src="/2020/11/27/java-io/16e24b51b50af9f5" alt="在这里插入图片描述"></p>
<p>简单一点说就是：</p>
<ul>
<li><p>编码：字符 (能看懂的) → 字节 (看不懂的)。</p>
</li>
<li><p>解码：字节 (看不懂的) → 字符 (能看懂的)。</p>
</li>
</ul>
<p>用代码解释则为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName): 通过指定的字符集解码字节数组</span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName): 使用指定的字符集合把字符串编码为字节数组</span><br><span class="line"></span><br><span class="line">编码: 把看得懂的变成看不懂的</span><br><span class="line">String -- <span class="keyword">byte</span>[]</span><br><span class="line"></span><br><span class="line">解码: 把看不懂的变成看得懂的</span><br><span class="line"><span class="keyword">byte</span>[] -- String</span><br></pre></td></tr></table></figure>

<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p><strong>字符集</strong> <code>Charset</code>：也叫<strong>编码表</strong>。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有 <code>ASCII</code> 字符集、<code>GBK</code> 字符集、<code>Unicode</code> 字符集等。</p>
<p><img src="/2020/11/27/java-io/16e24b51b5b2204d" alt="在这里插入图片描述"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li>ASCII 字符集<ul>
<li>ASCII (American Standard Code for Information Interchange，美国信息交换标准代码) 是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符 (回车键、退格、换行键等) 和可显示字符 (英文大小写字符、阿拉伯数字和西文符号)。</li>
<li>基本的 ASCII 字符集，使用 7 位（bits）表示一个字符，共 128 字符。ASCII 的扩展字符集使用 8 位（bits）表示一个字符，共 256 字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li>ISO-8859-1 字符集<ul>
<li>拉丁码表，别名 Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1 使用单字节编码，兼容 ASCII 编码。</li>
</ul>
</li>
<li>GBxxx 字符集<ul>
<li>GB 就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于 127 的字符的意义与原来相同。但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含 7000 多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的 “全角” 字符，而原来在 127 号以下的那些就叫 “半角” 字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在 GB2312 标准基础上的扩展规范，使用了双字节编码方案，共收录了 21003 个汉字，完全兼容 GB2312 标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li>Unicode 字符集<ul>
<li>Unicode 编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用 4 个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16 和 UTF-32。最为常用的 UTF-8 编码。</li>
<li>UTF-8 编码，可以用来表示 Unicode 标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组 (IETF) 要求所有互联网协议都必须支持 UTF-8 编码。所以，我们开发 Web 应用，也要使用 UTF-8 编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128 个 US-ASCII 字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。</li>
<li>大部分常用字 (含中文)，使用三个字节编码。</li>
<li>其他极少使用的 Unicode 辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="编码问题导致乱码"><a href="#编码问题导致乱码" class="headerlink" title="编码问题导致乱码"></a>编码问题导致乱码</h3><p>在 java 开发工具 IDEA 中，使用 FileReader 读取项目中的文本文件。由于 IDEA 的设置，都是默认的 UTF-8 编码，所以没有任何问题。但是，当读取 Windows 系统中创建的文本文件时，由于 Windows 系统的默认是 GBK 编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:\\test.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> read;</span><br><span class="line">            <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) read);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">��������</span><br></pre></td></tr></table></figure>

<p>那么如何读取 GBK 编码的文件呢？ 这个时候就得讲讲转换流了！</p>
<blockquote>
<p>从另一角度来讲：<strong>字符流 = 字节流 + 编码表</strong>。</p>
</blockquote>
<h3 id="InputStreamReader-类-—-字节流到字符流的桥梁"><a href="#InputStreamReader-类-—-字节流到字符流的桥梁" class="headerlink" title="InputStreamReader 类 — 字节流到字符流的桥梁"></a>InputStreamReader 类 — 字节流到字符流的桥梁</h3><p>转换流 <code>java.io.InputStreamReader</code>，是 Reader 的子类，从字面意思可以看出它是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>InputStreamReader(InputStream in)</code>：创建一个使用默认字符集的字符流。</li>
<li> <code>InputStreamReader(InputStream in, String charsetName)</code>：创建一个指定字符集的字符流。</li>
</ol>
<h4 id="使用转换流解决编码问题-—-读文件"><a href="#使用转换流解决编码问题-—-读文件" class="headerlink" title="使用转换流解决编码问题 — 读文件"></a>使用转换流解决编码问题 — 读文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 文件为gbk编码</span></span><br><span class="line">        String fileName = <span class="string">&quot;E:/test.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建流对象，默认UTF8编码</span></span><br><span class="line">            InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">            <span class="comment">// 创建流对象，指定GBK编码</span></span><br><span class="line">            InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(fileName), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义变量，保存字符</span></span><br><span class="line">            <span class="keyword">int</span> read;</span><br><span class="line">            <span class="comment">// 使用默认编码字符流读取，乱码</span></span><br><span class="line">            <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) read);</span><br><span class="line">            &#125;</span><br><span class="line">            isr.close();</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;\r\n******************\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用指定编码字符流读取，正常解析</span></span><br><span class="line">            <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) read);</span><br><span class="line">            &#125;</span><br><span class="line">            isr2.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">��������</span><br><span class="line">******************</span><br><span class="line">测试用例</span><br></pre></td></tr></table></figure>

<h3 id="OutputStreamWriter-类-—-字符流到字节流的桥梁"><a href="#OutputStreamWriter-类-—-字符流到字节流的桥梁" class="headerlink" title="OutputStreamWriter 类 — 字符流到字节流的桥梁"></a>OutputStreamWriter 类 — 字符流到字节流的桥梁</h3><p>转换流 <code>java.io.OutputStreamWriter</code> ，是 Writer 的子类，字面看容易混淆会误以为是转为字符流，其实不然，OutputStreamWriter 为从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>OutputStreamWriter(OutputStream in)</code>：创建一个使用默认字符集的字符流。</li>
<li> <code>OutputStreamWriter(OutputStream in, String charsetName)</code>：创建一个指定字符集的字符流。</li>
</ol>
<h4 id="使用转换流解决编码问题-—-写文件"><a href="#使用转换流解决编码问题-—-写文件" class="headerlink" title="使用转换流解决编码问题 — 写文件"></a>使用转换流解决编码问题 — 写文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">            OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:/test.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            osw.write(<span class="string">&quot;测试&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">            osw.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">            OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:/test2.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            osw2.write(<span class="string">&quot;用例&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">            osw2.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/27/java-io/16e24b51b8f8fd36" alt="在这里插入图片描述"></p>
<p>为了达到<strong>最高效率</strong>，可以考虑在 BufferedReader 内包装 InputStreamReader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))；</span><br></pre></td></tr></table></figure>

<h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><h3 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h3><p>java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该 <code>对象的数据</code>、<code>对象的类型</code> 和 <code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code> 和 <code>对象中存储的属性</code> 等信息，都可以用来在内存中创建对象。如图所示：</p>
<p><img src="/2020/11/27/java-io/16e24b51bb752dbd" alt="在这里插入图片描述"></p>
<h3 id="ObjectOutputStream-类"><a href="#ObjectOutputStream-类" class="headerlink" title="ObjectOutputStream 类"></a>ObjectOutputStream 类</h3><p><code>java.io.ObjectOutputStream</code> 类，将 java 对象的原始数据类型写出到文件，实现对象的持久存储。</p>
<h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定 OutputStream 的 ObjectOutputStream。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aa.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>

<h4 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h4><p><strong>一个对象要想序列化，必须满足两个条件：</strong></p>
<ul>
<li><p>该类必须实现 <code>java.io.Serializable</code> 接口，Serializable 是一个标记接口，不实现此接口的类不能实现任何状态序列化或反序列化，否则会抛出 <code>NotSerializableException</code>。</p>
</li>
<li><p>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用 <code>transient</code> 关键字修饰。</p>
</li>
</ul>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员，不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写出对象方法：</strong></p>
<ul>
<li> <code>public final void writeObject(Object obj)</code>： 将指定的对象写出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        employee.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">        employee.age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建序列化流对象</span></span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/employee.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 写出对象</span></span><br><span class="line">            out.writeObject(employee);</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            out.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<p>employee.txt 文件内容：</p>
<p><img src="/2020/11/27/java-io/image-20201214143657619.png" alt="image-20201214143657619"></p>
<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p><code>java.io.ObjectInputStream</code> 类，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象。</p>
<h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public ObjectInputStream(InputStream in)</code>： 创建一个指定 InputStream 的 ObjectInputStream。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;aa.txt&quot;</span>);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br></pre></td></tr></table></figure>

<h4 id="反序列化操作"><a href="#反序列化操作" class="headerlink" title="反序列化操作"></a>反序列化操作</h4><p>如果能找到一个对象的 class 文件，我们可以进行反序列化操作，调用 ObjectInputStream <strong>读取对象的方法</strong>：</p>
<ul>
<li><code>public final Object readObject()</code>：读取一个对象。</li>
</ul>
<p>以前面序列化得到的 employee.txt 文件为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建反序列化流</span></span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/employee.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 读取一个对象</span></span><br><span class="line">            employee = (Employee) in.readObject();</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常，直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + employee.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + employee.address);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + employee.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Name: zhangsan</span><br><span class="line">Address: beiqinglu</span><br><span class="line">Age: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>JVM 可以反序列化对象，但前提是必须能够找到 class 文件的类。如果找不到该类的 class 文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</p>
<p>另外，当 JVM 反序列化对象时，如果找到的 class 文件，在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个 <code>InvalidClassException</code> 异常。发生这个异常的原因如下：</p>
<ol>
<li> 该类的序列版本号与从流中读取的类描述符的版本号不匹配；</li>
<li> 该类包含未知数据类型；</li>
<li> 该类没有可访问的无参数构造方法。</li>
</ol>
<h3 id="序列版本号-serialVersionUID"><a href="#序列版本号-serialVersionUID" class="headerlink" title="序列版本号 serialVersionUID"></a>序列版本号 <code>serialVersionUID</code></h3><p>需要知道的是，只有实现了 Serializable 或 Externalizable 接口的类的对象才能被序列化。Externalizable 接口继承自 Serializable 接口，实现 Externalizable 接口的类完全由自身来控制序列化的行为，而仅实现 Serializable 接口的类可以采用默认的序列化方式 。</p>
<p>凡是实现 Serializable 接口的类都有一个表示序列化版本标识符的静态变量：<code>private static final long serialVersionUID;</code>，该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<p>类的 serialVersionUID 的默认值完全依赖于 java 编译器的实现，对于同一个类，用不同的 java 编译器编译，有可能会导致不同的 serialVersionUID。</p>
<p>当然，也可以人为显式地定义 serialVersionUID，这种方式有两种用途： </p>
<ol>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的 serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的 serialVersionUID。 </li>
<li>当你序列化了一个类实例后，后续可能更改一个字段或添加一个字段。如果不设置 serialVersionUID，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常；如果你添加了 serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值 (对象为 null，基本类型为相应的初始默认值)，字段被删除将不设置。 </li>
</ol>
<p>比如，对之前的 Employee 类添加新字段，同时希望能够继续反序列化未添加字段前得到的 employee.txt 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.添加序列版本号，并保持和不添加新属性之前相同的serialVersionUID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5303622816239242438L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员，不会被序列化</span></span><br><span class="line">    <span class="comment">// 2.添加新的属性，重新反序列化之前序列化得到的文件，此时该属性赋为int类型的默认值0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> eid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，再次执行 DeserializeDemo 的方法，输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: zhangsan</span><br><span class="line">Address: beiqinglu</span><br><span class="line">Age: <span class="number">0</span></span><br><span class="line">Eid：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><h3 id="什么是打印流"><a href="#什么是打印流" class="headerlink" title="什么是打印流"></a>什么是打印流</h3><p>平时我们在控制台打印输出，是调用 print 方法和 println 方法完成的，实际上，这两个方法都来自于 <code>java.io.PrintStream</code> 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<p><strong>打印流分类：</strong></p>
<ul>
<li>字节打印流 PrintStream</li>
<li>字符打印流 PrintWriter</li>
</ul>
<p><strong>打印流特点：</strong></p>
<ul>
<li>只操作目的地，不操作数据源。</li>
<li>可以操作任意类型的数据。</li>
<li>如果启用了自动刷新，在调用 <code>println()</code> 方法的时候，能够换行并刷新。</li>
<li>可以直接操作文件。</li>
</ul>
<blockquote>
<p>一般情况下，如果一个流的构造方法能够同时接收 File 和 String 类型的参数，都是可以直接操作文件的！</p>
</blockquote>
<p>PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类，两者处于对等的位置上，所以它们的 API 是非常相似的。二者区别无非一个是字节打印流，一个是字符打印流。</p>
<h3 id="字节输出打印流-PrintStream-复制文本文件"><a href="#字节输出打印流-PrintStream-复制文本文件" class="headerlink" title="字节输出打印流 PrintStream 复制文本文件"></a>字节输出打印流 PrintStream 复制文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>));</span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;xisun-database/printcopy.txt&quot;</span>);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ps.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            ps.close();</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符输出打印流-PrintWriter-复制文本文件"><a href="#字符输出打印流-PrintWriter-复制文本文件" class="headerlink" title="字符输出打印流 PrintWriter 复制文本文件"></a>字符输出打印流 PrintWriter 复制文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>));</span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;xisun-database/printcopy.txt&quot;</span>);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pw.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            pw.close();</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Properties-属性类"><a href="#Properties-属性类" class="headerlink" title="Properties 属性类"></a>Properties 属性类</h2><h3 id="Properties-概述"><a href="#Properties-概述" class="headerlink" title="Properties 概述"></a>Properties 概述</h3><p><code>java.util.Properties</code> 继承于 Hashtable，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多 java 类使用，比如获取系统属性时，<code>System.getProperties()</code> 方法就是返回一个 Properties 对象。</p>
<h3 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h3><h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public Properties()</code>：创建一个空的属性列表。</li>
</ol>
<h4 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h4><ol>
<li> <code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li>
<li> <code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li>
<li> <code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过键，获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集，获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot; -- &quot;</span> + properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;location=D:\a.txt, filename=a.txt, length=<span class="number">209385038</span>&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">location -- D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span>    </span><br></pre></td></tr></table></figure>

<h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><ol>
<li> <code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</li>
<li> <code>public void load(Reader reader)</code>：从字符输入流中读取键值对。</li>
<li> <code> public void store(Writer writer,String comments)</code></li>
<li> <code>public void store(OutputStream out,String comments)</code></li>
</ol>
<p>可以看出，参数中使用了字节输入流时，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。</p>
<p>例如，现在文本数据格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename=Properties.txt</span><br><span class="line">length=<span class="number">123</span></span><br><span class="line">location=C:/Properties.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/Properties.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 创建属性集对象</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">            properties.load(fis);</span><br><span class="line">            <span class="comment">// 遍历集合并打印</span></span><br><span class="line">            Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">            <span class="keyword">for</span> (String key : strings) &#123;</span><br><span class="line">                System.out.println(key + <span class="string">&quot; -- &quot;</span> + properties.getProperty(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">location -- C:/Properties.txt</span><br><span class="line">filename -- Properties.txt</span><br><span class="line">length -- <span class="number">123</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="字节流-FileInputStream-和-FileOutputStream-用法"><a href="#字节流-FileInputStream-和-FileOutputStream-用法" class="headerlink" title="字节流 FileInputStream 和 FileOutputStream 用法"></a>字节流 FileInputStream 和 FileOutputStream 用法</h3><p>读文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:/read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PictureCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:/input.png&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:/copy-input.png&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流-FileReader-和-FileWriter-的用法"><a href="#字符流-FileReader-和-FileWriter-的用法" class="headerlink" title="字符流 FileReader 和 FileWriter 的用法"></a>字符流 FileReader 和 FileWriter 的用法</h3><p>复制文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fw.write(chars, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节缓冲流-BufferedInputStream-和-BufferedOutputStream-的用法"><a href="#字节缓冲流-BufferedInputStream-和-BufferedOutputStream-的用法" class="headerlink" title="字节缓冲流 BufferedInputStream 和 BufferedOutputStream 的用法"></a>字节缓冲流 BufferedInputStream 和 BufferedOutputStream 的用法</h3><p>复制文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:/copy-read.txt&quot;</span>);</span><br><span class="line">             BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">             BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>性能优于 FileInputStream 和 FileOutputStream。</p>
</blockquote>
<h3 id="字符缓冲流-BufferedReader-和-BufferedWriter-的用法"><a href="#字符缓冲流-BufferedReader-和-BufferedWriter-的用法" class="headerlink" title="字符缓冲流 BufferedReader 和 BufferedWriter 的用法"></a>字符缓冲流 BufferedReader 和 BufferedWriter 的用法</h3><p>复制文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>);</span><br><span class="line">             BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">             BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bfr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bfw.write(chars, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特有方法——按行读取和写入：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>);</span><br><span class="line">             BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">             BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw)) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bfr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bfw.write(line);</span><br><span class="line">                bfw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>性能优于 FileReader 和 FileWriter。</p>
<p>FileWriter 每次调用 <code>write()</code> 方法，都会直接写入磁盘，不但效率低，性能也差。而 BufferedWriter 每次调用 <code>write()</code> 方法，会先写入缓冲区，直到缓冲区满了才写入磁盘。查看 BufferedWriter 源码可知 <code>defaultCharBufferSize = 8192;</code>，即缓冲区大小默认是 8 K，可以在构造方法时，指定缓冲区的大小，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr, <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw, <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>)；</span><br></pre></td></tr></table></figure>

<p>对于文本文件，推荐使用 BufferedReader 和 BufferedWriter 两个字符缓冲流对象处理。</p>
<p>使用字符流复制文件时，建议采用逐字符复制和逐行复制两种方式。</p>
</blockquote>
<h3 id="关于-flush-方法的特别说明"><a href="#关于-flush-方法的特别说明" class="headerlink" title="关于 flush() 方法的特别说明"></a>关于 <code>flush()</code> 方法的特别说明</h3><p>使用缓冲流时，默认情况要等缓冲区满了才会写入磁盘，或者调用 <code>close()</code> 方法关闭文件时也会写入磁盘，如果希望立即将缓冲区中的数据写入磁盘，则需要调用 <code>flush()</code> 方法。</p>
<p>另外，创建的流对象均应放在 try 结构体上，这样 java 会自动关闭流对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bfr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bfw.write(line);</span><br><span class="line">                bfw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            bfw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法，缓冲流对象没有放在 try 结构体上，如果不调用 <code>flush()</code> 方法，可能会造成数据丢失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>);</span><br><span class="line">             BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">             BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw)) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bfr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bfw.write(line);</span><br><span class="line">                bfw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法，缓冲流对象放在 try 结构体上，不需要调用 <code>flush()</code> 方法，java 会自动关闭流，在关闭之前，会将缓冲区中的数据写入磁盘。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903985078337550#heading-55">https://juejin.cn/post/6844903985078337550#heading-55</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/kafka-consumer-commitandpartition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/kafka-consumer-commitandpartition/" class="post-title-link" itemprop="url">KafkaConsumer 源码之 consumer 的 offset commit 机制和 partition 分配机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 15:17:06" itemprop="dateCreated datePublished" datetime="2020-11-24T15:17:06+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-05 15:32:30" itemprop="dateModified" datetime="2021-01-05T15:32:30+08:00">2021-01-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>紧接着上篇文章，这篇文章讲述 consumer 提供的 offset commit 机制和 partition 分配机制，具体如何使用是需要用户结合具体的场景进行选择，本文讲述一下其底层实现。</p>
<h2 id="自动-offset-commit-机制"><a href="#自动-offset-commit-机制" class="headerlink" title="自动 offset commit 机制"></a>自动 offset commit 机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动提交，默认true</span></span><br><span class="line">props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">// 设置自动每1s提交一次，默认为5s</span></span><br><span class="line">props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过上面设置，启动自动提交 offset 以及设置自动提交间隔时间。</p>
<h2 id="手动-offset-commit-机制"><a href="#手动-offset-commit-机制" class="headerlink" title="手动 offset commit 机制"></a>手动 offset commit 机制</h2><p>先看下两种不同的手动 offset commit 机制，一种是同步 commit，一种是异步 commit，既然其作用都是 offset commit，应该不难猜到它们底层使用接口都是一样的，其调用流程如下图所示：</p>
<p><img src="/2020/11/24/kafka-consumer-commitandpartition/image-20201124154403249.png" alt="image-20201124154403249"></p>
<h3 id="同步-commit"><a href="#同步-commit" class="headerlink" title="同步 commit"></a>同步 commit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对poll()中返回的所有topics和partition列表进行commit</span></span><br><span class="line"><span class="comment">// 这个方法只能将offset提交Kafka中，Kafka将会在每次rebalance之后的第一次拉取或启动时使用同步commit</span></span><br><span class="line"><span class="comment">// 这是同步commit，它将会阻塞进程，直到commit成功或者遇到一些错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitSync</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只对指定的topic-partition列表进行commit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitSync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其实，从上图中，就已经可以看出，同步 commit 的实现方式，<code>client.poll ()</code> 方法会阻塞直到这个 request 完成或超时才会返回。</p>
<h3 id="异步-commit"><a href="#异步-commit" class="headerlink" title="异步 commit"></a>异步 commit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">(OffsetCommitCallback callback)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback callback)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于异步的 commit，最后调用的都是 <code>doCommitOffsetsAsync ()</code> 方法，其具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommitOffsetsAsync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, <span class="keyword">final</span> OffsetCommitCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送offset-commit请求</span></span><br><span class="line">    RequestFuture&lt;Void&gt; future = sendOffsetCommitRequest(offsets);</span><br><span class="line">    <span class="keyword">final</span> OffsetCommitCallback cb = callback == <span class="keyword">null</span> ? defaultOffsetCommitCallback : callback;</span><br><span class="line">    future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Void value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (interceptors != <span class="keyword">null</span>)</span><br><span class="line">                interceptors.onCommit(offsets);</span><br><span class="line">            <span class="comment">// 添加成功的请求，以唤醒相应的回调函数</span></span><br><span class="line">            completedOffsetCommits.add(<span class="keyword">new</span> OffsetCommitCompletion(cb, offsets, <span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">            Exception commitException = e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RetriableException) &#123;</span><br><span class="line">                commitException = <span class="keyword">new</span> RetriableCommitFailedException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加失败的请求，以唤醒相应的回调函数</span></span><br><span class="line">            completedOffsetCommits.add(<span class="keyword">new</span> OffsetCommitCompletion(cb, offsets, commitException));</span><br><span class="line">            <span class="keyword">if</span> (commitException <span class="keyword">instanceof</span> FencedInstanceIdException) &#123;</span><br><span class="line">                asyncCommitFenced.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在异步 commit 中，可以添加相应的回调函数，如果 request 处理成功或处理失败，ConsumerCoordinator 会通过 <code>invokeCompletedOffsetCommitCallbacks ()</code> 方法唤醒相应的回调函数。</p>
<blockquote>
<p>上面简单的介绍了同步 commit 和异步 commit，更详细的分析参考：<a target="_blank" rel="noopener" href="http://generalthink.github.io/2019/06/04/kafka-consumer-offset-commit/">Kafka consumer 的 offset 的提交方式</a>。</p>
<p>注意：手动 commit 时，提交的是下一次要读取的 offset。举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(running) &#123;</span><br><span class="line">           <span class="comment">// 取得消息</span></span><br><span class="line">           ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">           <span class="comment">// 根据分区来遍历数据</span></span><br><span class="line">           <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">               List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line">               <span class="comment">// 数据处理</span></span><br><span class="line">               <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords) &#123;</span><br><span class="line">                   System.out.println(record.offset() + <span class="string">&quot;: &quot;</span> + record.value());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 取得当前读取到的最后一条记录的offset</span></span><br><span class="line">               <span class="keyword">long</span> lastOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">               <span class="comment">// 提交offset，记得要 + 1</span></span><br><span class="line">               consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(lastOffset + <span class="number">1</span>)));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   	consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="commit-offset-请求的处理"><a href="#commit-offset-请求的处理" class="headerlink" title="commit offset 请求的处理"></a>commit offset 请求的处理</h3><p>当 Kafka Server 端接收到来自 client 端的 offset commit 请求时，对于提交的 offset，GroupCoordinator 会记录在 GroupMetadata 对象中，至于其实现的逻辑细节，此处不再赘述。</p>
<h2 id="partition-分配机制"><a href="#partition-分配机制" class="headerlink" title="partition 分配机制"></a>partition 分配机制</h2><p>consumer 提供了三种不同的 partition 分配策略，可以通过 <code>partition.assignment.strategy</code> 参数进行配置，默认情况下使用的是 <code>org.apache.kafka.clients.consumer.RangeAssignor</code>，Kafka 中提供了另外两种 partition 的分配策略 <code>org.apache.kafka.clients.consumer.RoundRobinAssignor</code> 和 <code>org.apache.kafka.clients.consumer.StickyAssignor</code>，它们关系如下图所示：</p>
<p><img src="/2020/11/24/kafka-consumer-commitandpartition/image-20201124162306959.png" alt="image-20201124162306959"></p>
<p>通过上图可以看出，用户可以自定义相应的 partition 分配机制，只需要继承这个 AbstractPartitionAssignor 抽象类即可。</p>
<blockquote>
<p>partition 分配策略，其实也就是 reblance 策略。</p>
</blockquote>
<h3 id="AbstractPartitionAssignor"><a href="#AbstractPartitionAssignor" class="headerlink" title="AbstractPartitionAssignor"></a>AbstractPartitionAssignor</h3><p>AbstractPartitionAssignor 有一个抽象方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Perform the group assignment given the partition counts and member subscriptions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> partitionsPerTopic The number of partitions for each subscribed topic. Topics not in metadata will be excluded</span></span><br><span class="line"><span class="comment"> *                           from this map.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subscriptions Map from the memberId to their respective topic subscription</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Map from each member to the list of partitions assigned to them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 根据partitionsPerTopic和subscriptions进行分配，具体的实现会在子类中实现(不同的子类，其实现方法不相同)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                         Map&lt;String, Subscription&gt; subscriptions);</span><br></pre></td></tr></table></figure>

<p><code>assign ()</code> 这个方法，有两个参数：</p>
<ul>
<li><code>partitionsPerTopic</code>：所订阅的每个 topic 与其 partition 数的对应关系，metadata 没有的 topic 将会被移除；</li>
<li><code>subscriptions</code>：每个 consumerId 与其所订阅的 topic 列表的关系。</li>
</ul>
<p>继承 AbstractPartitionAssignor 的子类，通过实现 <code>assign ()</code> 方法，来进行相应的 partition 分配。</p>
<h3 id="RangeAssignor-分配模式"><a href="#RangeAssignor-分配模式" class="headerlink" title="RangeAssignor 分配模式"></a>RangeAssignor 分配模式</h3><p><code>assign ()</code> 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                Map&lt;String, Subscription&gt; subscriptions) &#123;</span><br><span class="line">    <span class="comment">// 1.参数含义:(topic, List&lt;consumerId&gt;)，获取每个topic被多少个consumer订阅了</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; consumersPerTopic = consumersPerTopic(subscriptions);</span><br><span class="line">    <span class="comment">// 2.存储最终的分配方案</span></span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">        assignment.put(memberId, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; topicEntry : consumersPerTopic.entrySet()) &#123;</span><br><span class="line">        String topic = topicEntry.getKey();</span><br><span class="line">        List&lt;String&gt; consumersForTopic = topicEntry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.每个topic的partition数量</span></span><br><span class="line">        Integer numPartitionsForTopic = partitionsPerTopic.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (numPartitionsForTopic == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Collections.sort(consumersForTopic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.取商，表示平均每个consumer会分配到多少个partition</span></span><br><span class="line">        <span class="keyword">int</span> numPartitionsPerConsumer = numPartitionsForTopic / consumersForTopic.size();</span><br><span class="line">        <span class="comment">// 5.取余，表示平均分配后还剩下多少个partition未被分配</span></span><br><span class="line">        <span class="keyword">int</span> consumersWithExtraPartition = numPartitionsForTopic % consumersForTopic.size();</span><br><span class="line"></span><br><span class="line">        List&lt;TopicPartition&gt; partitions = AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic);</span><br><span class="line">        <span class="comment">// 6.这里是关键点，分配原则是将未能被平均分配的partition分配到前consumersWithExtraPartition个consumer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = consumersForTopic.size(); i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 假设partition有7个，consumer有5个，则numPartitionsPerConsumer=1，consumersWithExtraPartition=2</span></span><br><span class="line">            <span class="comment">// i=0, start: 0, length: 2, topic-partition: p0, p1</span></span><br><span class="line">            <span class="comment">// i=1, start: 2, length: 2, topic-partition: p2, p3</span></span><br><span class="line">            <span class="comment">// i=2, start: 4, length: 1, topic-partition: p4</span></span><br><span class="line">            <span class="comment">// i=3, start: 5, length: 1, topic-partition: p5</span></span><br><span class="line">            <span class="comment">// i=4, start: 6, length: 1, topic-partition: p6</span></span><br><span class="line">            <span class="keyword">int</span> start = numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition);</span><br><span class="line">            <span class="keyword">int</span> length = numPartitionsPerConsumer + (i + <span class="number">1</span> &gt; consumersWithExtraPartition ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            assignment.get(consumersForTopic.get(i)).addAll(partitions.subList(start, start + length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 topic 的 partition 数为 <code>numPartitionsForTopic</code>，group 中订阅这个 topic 的 member 数为 <code>consumersForTopic.size()</code>，首先需要算出两个值：</p>
<ul>
<li><code>numPartitionsPerConsumer = numPartitionsForTopic / consumersForTopic.size()</code>：表示平均每个 consumer 会分配到几个 partition；</li>
<li><code>consumersWithExtraPartition = numPartitionsForTopic % consumersForTopic.size()</code>：表示平均分配后还剩下多少个 partition 未分配。</li>
</ul>
<p>分配的规则是：对于剩下的那些 partition 分配到前 consumersWithExtraPartition 个 consumer 上，也就是前 consumersWithExtraPartition 个 consumer 获得 topic-partition 列表会比后面多一个。</p>
<p>在上述的程序中，举了一个例子，假设有一个 topic 有 7 个 partition，group 有5个 consumer，这个5个 consumer 都订阅这个 topic，那么 range 的分配方式如下：</p>
<table>
<thead>
<tr>
<th>消费者</th>
<th>分配方案</th>
</tr>
</thead>
<tbody><tr>
<td>consumer 0</td>
<td>start: 0, length: 2, topic-partition: p0, p1</td>
</tr>
<tr>
<td>consumer 1</td>
<td>start: 2, length: 2, topic-partition: p2, p3</td>
</tr>
<tr>
<td>consumer 2</td>
<td>start: 4, length: 1, topic-partition: p4</td>
</tr>
<tr>
<td>consumer 3</td>
<td>start: 5, length: 1, topic-partition: p5</td>
</tr>
<tr>
<td>consumer 4</td>
<td>start: 6, length: 1, topic-partition: p6</td>
</tr>
</tbody></table>
<p>而如果 group 中有 consumer 没有订阅这个 topic，那么这个 consumer 将不会参与分配。下面再举个例子，假设有 2 个 topic，一个有 5 个 partition，另一个有 7 个 partition，group 中有 5 个 consumer，但是只有前 3 个订阅第一个 topic，而另一个 topic 是所有 consumer 都订阅了，那么其分配结果如下：</p>
<table>
<thead>
<tr>
<th>consumer</th>
<th>订阅 topic1 的列表</th>
<th>订阅 topic2 的列表</th>
</tr>
</thead>
<tbody><tr>
<td>consumer 0</td>
<td>t1 p0, t1 p1</td>
<td>t2 p0, t2 p1</td>
</tr>
<tr>
<td>consumer 1</td>
<td>t1 p2, t1 p3</td>
<td>t2 p2, t2 p3</td>
</tr>
<tr>
<td>consumer 2</td>
<td>t1 p4</td>
<td>t2 p4</td>
</tr>
<tr>
<td>consumer 3</td>
<td></td>
<td>t2 p5</td>
</tr>
<tr>
<td>consumer 4</td>
<td></td>
<td>t2 p6</td>
</tr>
</tbody></table>
<h3 id="RoundRobinAssignor"><a href="#RoundRobinAssignor" class="headerlink" title="RoundRobinAssignor"></a>RoundRobinAssignor</h3><p><code>assign ()</code> 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                Map&lt;String, Subscription&gt; subscriptions) &#123;</span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">        assignment.put(memberId, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环状链表，存储所有的consumer，一次迭代完之后又会回到原点</span></span><br><span class="line">    CircularIterator&lt;String&gt; assigner = <span class="keyword">new</span> CircularIterator&lt;&gt;(Utils.sorted(subscriptions.keySet()));</span><br><span class="line">    <span class="comment">// 获取所有订阅的topic的partition总数</span></span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) &#123;</span><br><span class="line">        <span class="keyword">final</span> String topic = partition.topic();</span><br><span class="line">        <span class="keyword">while</span> (!subscriptions.get(assigner.peek()).topics().contains(topic))</span><br><span class="line">            assigner.next();</span><br><span class="line">        assignment.get(assigner.next()).add(partition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TopicPartition&gt; <span class="title">allPartitionsSorted</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                Map&lt;String, Subscription&gt; subscriptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有的topics(有序)</span></span><br><span class="line">    SortedSet&lt;String&gt; topics = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Subscription subscription : subscriptions.values())</span><br><span class="line">        topics.addAll(subscription.topics());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅的Topic的所有的TopicPartition集合</span></span><br><span class="line">    List&lt;TopicPartition&gt; allPartitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String topic : topics) &#123;</span><br><span class="line">        Integer numPartitionsForTopic = partitionsPerTopic.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (numPartitionsForTopic != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// topic的所有partition都添加进去</span></span><br><span class="line">            allPartitions.addAll(AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allPartitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Round Robin 的实现原则，简单来说就是：列出所有 topic-partition 和列出所有的 consumer member，然后开始分配，一轮之后继续下一轮，假设有一个 topic，它有7个 partition，group 中有 3 个 consumer 都订阅了这个 topic，那么其分配方式为：</p>
<table>
<thead>
<tr>
<th>消费者</th>
<th>分配列表</th>
</tr>
</thead>
<tbody><tr>
<td>consumer 0</td>
<td>p0, p3, p6</td>
</tr>
<tr>
<td>consumer 1</td>
<td>p1, p4</td>
</tr>
<tr>
<td>consumer 2</td>
<td>p2, p5</td>
</tr>
</tbody></table>
<p>对于多个 topic 的订阅，假设有 2 个 topic，一个有 5 个 partition，一个有 7 个 partition，group 中有 5 个 consumer，但是只有前 3 个订阅第一个 topic，而另一个 topic 是所有 consumer 都订阅了，那么其分配结果如下：</p>
<table>
<thead>
<tr>
<th>消费者</th>
<th>订阅 topic1 的列表</th>
<th>订阅的 topic2 的列表</th>
</tr>
</thead>
<tbody><tr>
<td>consumer 0</td>
<td>t1 p0, t1 p3</td>
<td>t2 p0, t2 p5</td>
</tr>
<tr>
<td>consumer 1</td>
<td>t1 p1, t1 p4</td>
<td>t2 p1, t2 p6</td>
</tr>
<tr>
<td>consumer 2</td>
<td>t1 p2</td>
<td>t2 p2</td>
</tr>
<tr>
<td>consumer 3</td>
<td></td>
<td>t2 p3</td>
</tr>
<tr>
<td>consumer 4</td>
<td></td>
<td>t2 p4</td>
</tr>
</tbody></table>
<h3 id="StickyAssignor"><a href="#StickyAssignor" class="headerlink" title="StickyAssignor"></a>StickyAssignor</h3><p><code>assign ()</code> 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                Map&lt;String, Subscription&gt; subscriptions) &#123;</span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; currentAssignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;TopicPartition, ConsumerGenerationPair&gt; prevAssignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    partitionMovements = <span class="keyword">new</span> PartitionMovements();</span><br><span class="line"></span><br><span class="line">    prepopulateCurrentAssignments(subscriptions, currentAssignment, prevAssignment);</span><br><span class="line">    <span class="keyword">boolean</span> isFreshAssignment = currentAssignment.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a mapping of all topic partitions to all consumers that can be assigned to them</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;String&gt;&gt; partition2AllPotentialConsumers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// a mapping of all consumers to all potential topic partitions that can be assigned to them</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; consumer2AllPotentialPartitions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize partition2AllPotentialConsumers and consumer2AllPotentialPartitions in the following two for loops</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry: partitionsPerTopic.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry.getValue(); ++i)</span><br><span class="line">            partition2AllPotentialConsumers.put(<span class="keyword">new</span> TopicPartition(entry.getKey(), i), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Subscription&gt; entry: subscriptions.entrySet()) &#123;</span><br><span class="line">        String consumer = entry.getKey();</span><br><span class="line">        consumer2AllPotentialPartitions.put(consumer, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        entry.getValue().topics().stream().filter(topic -&gt; partitionsPerTopic.get(topic) != <span class="keyword">null</span>).forEach(topic -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; partitionsPerTopic.get(topic); ++i) &#123;</span><br><span class="line">                TopicPartition topicPartition = <span class="keyword">new</span> TopicPartition(topic, i);</span><br><span class="line">                consumer2AllPotentialPartitions.get(consumer).add(topicPartition);</span><br><span class="line">                partition2AllPotentialConsumers.get(topicPartition).add(consumer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add this consumer to currentAssignment (with an empty topic partition assignment) if it does not already exist</span></span><br><span class="line">        <span class="keyword">if</span> (!currentAssignment.containsKey(consumer))</span><br><span class="line">            currentAssignment.put(consumer, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a mapping of partition to current consumer</span></span><br><span class="line">    Map&lt;TopicPartition, String&gt; currentPartitionConsumer = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;TopicPartition&gt;&gt; entry: currentAssignment.entrySet())</span><br><span class="line">        <span class="keyword">for</span> (TopicPartition topicPartition: entry.getValue())</span><br><span class="line">            currentPartitionConsumer.put(topicPartition, entry.getKey());</span><br><span class="line"></span><br><span class="line">    List&lt;TopicPartition&gt; sortedPartitions = sortPartitions(</span><br><span class="line">            currentAssignment, prevAssignment.keySet(), isFreshAssignment, partition2AllPotentialConsumers, consumer2AllPotentialPartitions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all partitions that need to be assigned (initially set to all partitions but adjusted in the following loop)</span></span><br><span class="line">    List&lt;TopicPartition&gt; unassignedPartitions = <span class="keyword">new</span> ArrayList&lt;&gt;(sortedPartitions);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;String, List&lt;TopicPartition&gt;&gt;&gt; it = currentAssignment.entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">        Map.Entry&lt;String, List&lt;TopicPartition&gt;&gt; entry = it.next();</span><br><span class="line">        <span class="keyword">if</span> (!subscriptions.containsKey(entry.getKey())) &#123;</span><br><span class="line">            <span class="comment">// if a consumer that existed before (and had some partition assignments) is now removed, remove it from currentAssignment</span></span><br><span class="line">            <span class="keyword">for</span> (TopicPartition topicPartition: entry.getValue())</span><br><span class="line">                currentPartitionConsumer.remove(topicPartition);</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// otherwise (the consumer still exists)</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;TopicPartition&gt; partitionIter = entry.getValue().iterator(); partitionIter.hasNext();) &#123;</span><br><span class="line">                TopicPartition partition = partitionIter.next();</span><br><span class="line">                <span class="keyword">if</span> (!partition2AllPotentialConsumers.containsKey(partition)) &#123;</span><br><span class="line">                    <span class="comment">// if this topic partition of this consumer no longer exists remove it from currentAssignment of the consumer</span></span><br><span class="line">                    partitionIter.remove();</span><br><span class="line">                    currentPartitionConsumer.remove(partition);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!subscriptions.get(entry.getKey()).topics().contains(partition.topic())) &#123;</span><br><span class="line">                    <span class="comment">// if this partition cannot remain assigned to its current consumer because the consumer</span></span><br><span class="line">                    <span class="comment">// is no longer subscribed to its topic remove it from currentAssignment of the consumer</span></span><br><span class="line">                    partitionIter.remove();</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// otherwise, remove the topic partition from those that need to be assigned only if</span></span><br><span class="line">                    <span class="comment">// its current consumer is still subscribed to its topic (because it is already assigned</span></span><br><span class="line">                    <span class="comment">// and we would want to preserve that assignment as much as possible)</span></span><br><span class="line">                    unassignedPartitions.remove(partition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// at this point we have preserved all valid topic partition to consumer assignments and removed</span></span><br><span class="line">    <span class="comment">// all invalid topic partitions and invalid consumers. Now we need to assign unassignedPartitions</span></span><br><span class="line">    <span class="comment">// to consumers so that the topic partition assignments are as balanced as possible.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// an ascending sorted set of consumers based on how many topic partitions are already assigned to them</span></span><br><span class="line">    TreeSet&lt;String&gt; sortedCurrentSubscriptions = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> SubscriptionComparator(currentAssignment));</span><br><span class="line">    sortedCurrentSubscriptions.addAll(currentAssignment.keySet());</span><br><span class="line"></span><br><span class="line">    balance(currentAssignment, prevAssignment, sortedPartitions, unassignedPartitions, sortedCurrentSubscriptions,</span><br><span class="line">            consumer2AllPotentialPartitions, partition2AllPotentialConsumers, currentPartitionConsumer);</span><br><span class="line">    <span class="keyword">return</span> currentAssignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sticky 分区策略是从 0.11 版本才开始引入的，它主要有两个目的：</p>
<ol>
<li>分区的分配要尽可能均匀</li>
<li>分区的分配要尽可能与上次分配的保持相同</li>
</ol>
<p>当两者冲突的时候，第一个目标优先于第二个目标。</p>
<p>sticky 的分区方式作用发生分区重分配的时候，尽可能地让前后两次分配相同，进而减少系统资源的损耗及其他异常情况的发生。因为 sticky 分区策略的代码，要比 range 和 roundrobin 复杂很多，此处不做具体的细节分析，只简单举例如下：</p>
<p>假设有 3 个 topic，一个有 2 个 partition，一个有 3 个 partition，另外一个有 4 个 partition，group 中有 3 个 consumer，第一个 consumer 订阅了第一个 topic，第二个 consumer 订阅了前两个 topic，第三个 consumer 订阅了三个 topic，那么它们的分配方案如下：</p>
<table>
<thead>
<tr>
<th>消费者</th>
<th>订阅 topic1 的列表</th>
<th>订阅 topic2 的列表</th>
<th>订阅 topic3 的列表</th>
</tr>
</thead>
<tbody><tr>
<td>consumer1</td>
<td>t1 p0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>consumer2</td>
<td>t1 p1, t2 p1</td>
<td>t2 p0, t2 p3</td>
<td></td>
</tr>
<tr>
<td>consumer3</td>
<td></td>
<td></td>
<td>t3 p0, t3 p1, t3 p2, t3 p3</td>
</tr>
</tbody></table>
<p>上面三个分区策略有着不同的分配方式，在实际使用过程中，需要根据自己的需求选择合适的策略，但是如果你只有一个 consumer，那么选择哪个方式都是一样的，但是如果是多个 consumer 不在同一台设备上进行消费，那么 sticky 方式应该更加合适。</p>
<h3 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h3><p>如之前所说，只需要继承 AbstractPartitionAssignor 并复写其中方法即可 (当然也可以直接实现 PartitionAssignor 接口) 自定义分区策略，其中有两个方法需要复写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                             Map&lt;String, Subscription&gt; subscriptions);</span><br></pre></td></tr></table></figure>

<p>其中 <code>assign ()</code> 方法表示的是分区分配方案的实现，而 <code>name ()</code> 方法则表示了这个分配策略的唯一名称，比如之前提到的 range，roundrobin 和 sticky, 这个名字会在和 GroupCoordinator 的通信中返回，通过它 consumer leader 来确定整个 group 的分区方案 (分区策略是由 group 中的 consumer 共同投票决定的，谁使用的多，就使用哪个策略)。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="http://generalthink.github.io/2019/06/06/kafka-consumer-partition-assign/">http://generalthink.github.io/2019/06/06/kafka-consumer-partition-assign/</a></p>
<p><a target="_blank" rel="noopener" href="https://matt33.com/2017/11/19/consumer-two-summary/">https://matt33.com/2017/11/19/consumer-two-summary/</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>
<p>至此，关于 Kafka 的学习暂时告一段落，未来有需要时，会继续学习。更多关于 Kafka 原理等知识的介绍，参考：</p>
<p><a target="_blank" rel="noopener" href="http://generalthink.github.io/tags/Kafka/">http://generalthink.github.io/tags/Kafka/</a></p>
<p><a target="_blank" rel="noopener" href="https://matt33.com/tags/kafka/">https://matt33.com/tags/kafka/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/kafka-consumer-subscribeandassign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/kafka-consumer-subscribeandassign/" class="post-title-link" itemprop="url">KafkaConsumer 源码之 consumer 的两种订阅模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 10:18:47" itemprop="dateCreated datePublished" datetime="2020-11-24T10:18:47+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-05 15:33:01" itemprop="dateModified" datetime="2021-01-05T15:33:01+08:00">2021-01-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在<a target="_blank" rel="noopener" href="https://acatsmiling.github.io/2020/10/29/kafka-consumer/">前面的文章</a>中，有简单的介绍了 KafkaConsumer 的两种订阅模式，本篇文章对此进行扩展说明一下。</p>
<p>KafkaConsumer 的两种订阅模式， <code>subscribe ()</code> 模式和 <code>assign ()</code> 模式，前者是 topic 粒度 (使用 group 管理)，后者是 topic-partition 粒度 (用户自己去管理)。</p>
<h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><p>KafkaConsumer 为订阅模式提供了 4 种 API，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅指定的topic列表，并且会自动进行动态partition订阅</span></span><br><span class="line"><span class="comment">// 当发生以下情况时，会进行rebalance:1.订阅的topic列表改变；2.topic被创建或删除；3.consumer线程die；4.加一个新的consumer线程</span></span><br><span class="line"><span class="comment">// 当发生rebalance时，会唤醒ConsumerRebalanceListener线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，但是这里没有设置listener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅那些满足一定规则(pattern)的topic</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Pattern pattern, ConsumerRebalanceListener listener)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，但是这里没有设置listener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Pattern pattern)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上 4 种 API 都是按照 topic 级别去订阅，可以动态地获取其分配的 topic-partition，这是使用 <strong>Group 动态管理</strong>，它不能与手动 partition 管理一起使用。当监控到发生下面的事件时，Group 将会触发 rebalance 操作：</p>
<ol>
<li>订阅的 topic 列表变化；</li>
<li>topic 被创建或删除；</li>
<li>consumer group 的某个 consumer 实例挂掉；</li>
<li>一个新的 consumer 实例通过 join 方法加入到一个 group 中。</li>
</ol>
<p>在这种模式下，当 KafkaConsumer 调用 <code>poll ()</code> 方法时，第一步会首先加入到一个 group 中，并获取其分配的 topic-partition 列表，具体细节在前面的文章中已经分析过了。</p>
<p>这里介绍一下当调用 <code>subscribe ()</code> 方法之后，consumer 所做的事情，分两种情况介绍，一种按 topic 列表订阅，一种是按 pattern 模式订阅：</p>
<ul>
<li>topic 列表订阅</li>
</ul>
<p>topic 列表订阅，最终调用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscribe to the given list of topics to get dynamically</span></span><br><span class="line"><span class="comment"> * assigned partitions. &lt;b&gt;Topic subscriptions are not incremental. This list will replace the current</span></span><br><span class="line"><span class="comment"> * assignment (if there is one).&lt;/b&gt; Note that it is not possible to combine topic subscription with group management</span></span><br><span class="line"><span class="comment"> * with manual partition assignment through &#123;<span class="doctag">@link</span> #assign(Collection)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the given list of topics is empty, it is treated the same as &#123;<span class="doctag">@link</span> #unsubscribe()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * As part of group management, the consumer will keep track of the list of consumers that belong to a particular</span></span><br><span class="line"><span class="comment"> * group and will trigger a rebalance operation if any one of the following events are triggered:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Number of partitions change for any of the subscribed topics</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;A subscribed topic is created or deleted</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;An existing member of the consumer group is shutdown or fails</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;A new member is added to the consumer group</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When any of these events are triggered, the provided listener will be invoked first to indicate that</span></span><br><span class="line"><span class="comment"> * the consumer&#x27;s assignment has been revoked, and then again when the new assignment has been received.</span></span><br><span class="line"><span class="comment"> * Note that rebalances will only occur during an active call to &#123;<span class="doctag">@link</span> #poll(Duration)&#125;, so callbacks will</span></span><br><span class="line"><span class="comment"> * also only be invoked during that time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The provided listener will immediately override any listener set in a previous call to subscribe.</span></span><br><span class="line"><span class="comment"> * It is guaranteed, however, that the partitions revoked/assigned through this interface are from topics</span></span><br><span class="line"><span class="comment"> * subscribed in this call. See &#123;<span class="doctag">@link</span> ConsumerRebalanceListener&#125; for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topics The list of topics to subscribe to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener Non-null listener instance to get notifications on partition assignment/revocation for the</span></span><br><span class="line"><span class="comment"> *                 subscribed topics</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException If topics is null or contains null or empty elements, or if listener is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If &#123;<span class="doctag">@code</span> subscribe()&#125; is called previously with pattern, or assign is called</span></span><br><span class="line"><span class="comment"> *                               previously (without a subsequent call to &#123;<span class="doctag">@link</span> #unsubscribe()&#125;), or if not</span></span><br><span class="line"><span class="comment"> *                               configured at-least one partition assignment strategy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        maybeThrowInvalidGroupIdException();</span><br><span class="line">        <span class="keyword">if</span> (topics == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic collection to subscribe to cannot be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (topics.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// treat subscribing to empty topic list as the same as unsubscribing</span></span><br><span class="line">            <span class="keyword">this</span>.unsubscribe();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String topic : topics) &#123;</span><br><span class="line">                <span class="keyword">if</span> (topic == <span class="keyword">null</span> || topic.trim().isEmpty())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic collection to subscribe to cannot contain null or empty topic&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throwIfNoAssignorsConfigured();</span><br><span class="line">            fetcher.clearBufferedDataForUnassignedTopics(topics);</span><br><span class="line">            log.info(<span class="string">&quot;Subscribed to topic(s): &#123;&#125;&quot;</span>, Utils.join(topics, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">            <span class="comment">// 核心步骤在此处执行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.subscribe(<span class="keyword">new</span> HashSet&lt;&gt;(topics), listener))</span><br><span class="line">                metadata.requestUpdateForNewTopics();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将 SubscriptionType 类型设置为 <strong>AUTO_TOPICS</strong>，并更新 SubscriptionState 中记录的 subscription 属性 (记录的是订阅的 topic 列表)；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">subscribe</span><span class="params">(Set&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    registerRebalanceListener(listener);</span><br><span class="line">    setSubscriptionType(SubscriptionType.AUTO_TOPICS);</span><br><span class="line">    <span class="keyword">return</span> changeSubscription(topics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">changeSubscription</span><span class="params">(Set&lt;String&gt; topicsToSubscribe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subscription.equals(topicsToSubscribe))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    subscription = topicsToSubscribe;</span><br><span class="line">    <span class="keyword">if</span> (subscriptionType != SubscriptionType.USER_ASSIGNED) &#123;</span><br><span class="line">        groupSubscription = <span class="keyword">new</span> HashSet&lt;&gt;(groupSubscription);</span><br><span class="line">        groupSubscription.addAll(topicsToSubscribe);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        groupSubscription = <span class="keyword">new</span> HashSet&lt;&gt;(topicsToSubscribe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>请求更新 metadata。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">requestUpdateForNewTopics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Override the timestamp of last refresh to let immediate update.</span></span><br><span class="line">    <span class="keyword">this</span>.lastRefreshMs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.requestVersion++;</span><br><span class="line">    requestUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request an update of the current cluster metadata info, return the current updateVersion before the update</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">requestUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.needUpdate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.updateVersion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>pattern 模式订阅</li>
</ul>
<p>pattern 模式订阅，最终调用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscribe to all topics matching specified pattern to get dynamically assigned partitions.</span></span><br><span class="line"><span class="comment"> * The pattern matching will be done periodically against all topics existing at the time of check.</span></span><br><span class="line"><span class="comment"> * This can be controlled through the &#123;<span class="doctag">@code</span> metadata.max.age.ms&#125; configuration: by lowering</span></span><br><span class="line"><span class="comment"> * the max metadata age, the consumer will refresh metadata more often and check for matching topics.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> #subscribe(Collection, ConsumerRebalanceListener)&#125; for details on the</span></span><br><span class="line"><span class="comment"> * use of the &#123;<span class="doctag">@link</span> ConsumerRebalanceListener&#125;. Generally rebalances are triggered when there</span></span><br><span class="line"><span class="comment"> * is a change to the topics matching the provided pattern and when consumer group membership changes.</span></span><br><span class="line"><span class="comment"> * Group rebalances only take place during an active call to &#123;<span class="doctag">@link</span> #poll(Duration)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern Pattern to subscribe to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener Non-null listener instance to get notifications on partition assignment/revocation for the</span></span><br><span class="line"><span class="comment"> *                 subscribed topics</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException If pattern or listener is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If &#123;<span class="doctag">@code</span> subscribe()&#125; is called previously with topics, or assign is called</span></span><br><span class="line"><span class="comment"> *                               previously (without a subsequent call to &#123;<span class="doctag">@link</span> #unsubscribe()&#125;), or if not</span></span><br><span class="line"><span class="comment"> *                               configured at-least one partition assignment strategy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Pattern pattern, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    maybeThrowInvalidGroupIdException();</span><br><span class="line">    <span class="keyword">if</span> (pattern == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic pattern to subscribe to cannot be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        throwIfNoAssignorsConfigured();</span><br><span class="line">        log.info(<span class="string">&quot;Subscribed to pattern: &#x27;&#123;&#125;&#x27;&quot;</span>, pattern);</span><br><span class="line">        <span class="keyword">this</span>.subscriptions.subscribe(pattern, listener);</span><br><span class="line">        <span class="keyword">this</span>.coordinator.updatePatternSubscription(metadata.fetch());</span><br><span class="line">        <span class="keyword">this</span>.metadata.requestUpdateForNewTopics();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将 SubscriptionType 类型设置为 <strong>AUTO_PATTERN</strong>，并更新 SubscriptionState 中记录的 subscribedPattern 属性，设置为 pattern；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Pattern pattern, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    registerRebalanceListener(listener);</span><br><span class="line">    setSubscriptionType(SubscriptionType.AUTO_PATTERN);</span><br><span class="line">    <span class="keyword">this</span>.subscribedPattern = pattern;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 coordinator 的 <code>updatePatternSubscription ()</code> 方法，遍历所有 topic 的 metadata，找到所有满足 pattern 的 topic 列表，更新到 SubscriptionState 的 subscriptions 属性，并请求更新 Metadata；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePatternSubscription</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; topicsToSubscribe = cluster.topics().stream()</span><br><span class="line">            .filter(subscriptions::matchesSubscribedPattern)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">    <span class="keyword">if</span> (subscriptions.subscribeFromPattern(topicsToSubscribe))</span><br><span class="line">        metadata.requestUpdateForNewTopics();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">subscribeFromPattern</span><span class="params">(Set&lt;String&gt; topics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subscriptionType != SubscriptionType.AUTO_PATTERN)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Attempt to subscribe from pattern while subscription type set to &quot;</span> +</span><br><span class="line">                                           subscriptionType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changeSubscription(topics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">changeSubscription</span><span class="params">(Set&lt;String&gt; topicsToSubscribe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subscription.equals(topicsToSubscribe))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    subscription = topicsToSubscribe;</span><br><span class="line">    <span class="keyword">if</span> (subscriptionType != SubscriptionType.USER_ASSIGNED) &#123;</span><br><span class="line">        groupSubscription = <span class="keyword">new</span> HashSet&lt;&gt;(groupSubscription);</span><br><span class="line">        groupSubscription.addAll(topicsToSubscribe);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        groupSubscription = <span class="keyword">new</span> HashSet&lt;&gt;(topicsToSubscribe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">requestUpdateForNewTopics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Override the timestamp of last refresh to let immediate update.</span></span><br><span class="line">    <span class="keyword">this</span>.lastRefreshMs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.requestVersion++;</span><br><span class="line">    requestUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request an update of the current cluster metadata info, return the current updateVersion before the update</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">requestUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.needUpdate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.updateVersion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他部分，两者基本一样，只是 pattern 模型在每次更新 topic-metadata 时，获取全局的 topic 列表，如果发现有新加入的符合条件的 topic，就立马去订阅，其他的地方，包括 group 管理、topic-partition 的分配都是一样的。</p>
<h2 id="分配模式"><a href="#分配模式" class="headerlink" title="分配模式"></a>分配模式</h2><p>当调用 <code>assign ()</code> 方法手动分配 topic-partition 列表时，不会使用 consumer 的 Group 管理机制，也即是当 consumer group member 变化或 topic 的 metadata 信息变化时，不会触发 rebalance 操作。比如：当 topic 的 partition 增加时，这里无法感知，需要用户进行相应的处理，Apache Flink 就是使用的这种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Manually assign a list of partitions to this consumer. This interface does not allow for incremental assignment</span></span><br><span class="line"><span class="comment"> * and will replace the previous assignment (if there is one).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If the given list of topic partitions is empty, it is treated the same as &#123;<span class="doctag">@link</span> #unsubscribe()&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Manual topic assignment through this method does not use the consumer&#x27;s group management</span></span><br><span class="line"><span class="comment"> * functionality. As such, there will be no rebalance operation triggered when group membership or cluster and topic</span></span><br><span class="line"><span class="comment"> * metadata change. Note that it is not possible to use both manual partition assignment with &#123;<span class="doctag">@link</span> #assign(Collection)&#125;</span></span><br><span class="line"><span class="comment"> * and group assignment with &#123;<span class="doctag">@link</span> #subscribe(Collection, ConsumerRebalanceListener)&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If auto-commit is enabled, an async commit (based on the old assignment) will be triggered before the new</span></span><br><span class="line"><span class="comment"> * assignment replaces the old one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> partitions The list of partitions to assign this consumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException If partitions is null or contains null or empty topics</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If &#123;<span class="doctag">@code</span> subscribe()&#125; is called previously with topics or pattern</span></span><br><span class="line"><span class="comment"> *                               (without a subsequent call to &#123;<span class="doctag">@link</span> #unsubscribe()&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (partitions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic partition collection to assign to cannot be null&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (partitions.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.unsubscribe();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TopicPartition tp : partitions) &#123;</span><br><span class="line">                String topic = (tp != <span class="keyword">null</span>) ? tp.topic() : <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (topic == <span class="keyword">null</span> || topic.trim().isEmpty())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic partitions to assign to cannot have null or empty topic&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fetcher.clearBufferedDataForUnassignedPartitions(partitions);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// make sure the offsets of topic partitions the consumer is unsubscribing from</span></span><br><span class="line">            <span class="comment">// are committed since there will be no following rebalance</span></span><br><span class="line">            <span class="keyword">if</span> (coordinator != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.coordinator.maybeAutoCommitOffsetsAsync(time.milliseconds());</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;Subscribed to partition(s): &#123;&#125;&quot;</span>, Utils.join(partitions, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.assignFromUser(<span class="keyword">new</span> HashSet&lt;&gt;(partitions)))</span><br><span class="line">                metadata.requestUpdateForNewTopics();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>assign ()</code> 方法是手动向 consumer 分配一些 topic-partition 列表，并且这个接口不允许增加分配的 topic-partition 列表，将会覆盖之前分配的 topic-partition 列表，如果给定的 topic-partition 列表为空，它的作用将会与 <code>unsubscribe ()</code> 方法一样。</p>
<p>这种手动 topic 分配也不会使用 consumer 的 group 管理，当 group 的 member 变化或 topic 的 metadata 变化时，也不会触发 rebalance 操作。</p>
</blockquote>
<p>这里所说的 consumer 的 group 管理，就是前面所说的 consumer 如何加入 group 的管理过程。如果使用的是 assign 模式，也即是非 AUTO_TOPICS 或 AUTO_PATTERN 模式时，consumer 实例在调用 <code>poll ()</code> 方法时，不会向 GroupCoordinator 发送 join-group、sync-group、heartbeat 请求，也就是说 GroupCoordinator 拿不到这个 consumer 实例的相关信息，也不会去维护这个 member 是否存活，这种情况下就需要用户自己管理自己的处理程序。但是这种模式可以进行 offset commit，这将在下一篇文章进行分析。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据上面的讲述，这里做一下小结，两种模式对比如下图所示：</p>
<p><img src="/2020/11/24/kafka-consumer-subscribeandassign/image-20201124145646131.png" alt="image-20201124145646131"></p>
<p>简单说明如下：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">不同之处</th>
<th align="center">相同之处</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>subscribe ()</code></td>
<td align="center">使用 Kafka group 管理，自动进行 rebalance 操作</td>
<td align="center">可以在 Kafka 保存 offset</td>
</tr>
<tr>
<td align="center"><code>assign ()</code></td>
<td align="center">用户自己进行相关的处理</td>
<td align="center">也可以进行 offset commit，但是尽量保证 <code>group.id</code> 唯一性，如果使用一个与上面模式一样的 group，offset commit 请求将会被拒绝</td>
</tr>
</tbody></table>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="https://matt33.com/2017/11/18/consumer-subscribe/">https://matt33.com/2017/11/18/consumer-subscribe/</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/18/maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/18/maven/" class="post-title-link" itemprop="url">maven 的基础使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-18 15:18:48" itemprop="dateCreated datePublished" datetime="2020-11-18T15:18:48+08:00">2020-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-27 11:48:19" itemprop="dateModified" datetime="2021-01-27T11:48:19+08:00">2021-01-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="maven-的功能"><a href="#maven-的功能" class="headerlink" title="maven 的功能"></a>maven 的功能</h2><p>maven 是一个项目管理工具，主要作用是在项目开发阶段对项目进行<strong>依赖管理</strong>和<strong>项目构建</strong>。</p>
<ul>
<li>依赖管理：仅仅通过 jar 包的几个属性，就能确定唯一的 jar 包，在指定的文件 pom.xml 中，只要写入这些依赖属性，就会自动下载并管理 jar 包。</li>
</ul>
<ul>
<li>项目构建：内置很多的插件与生命周期，支持多种任务，比如校验、编译、测试、打包、部署、发布…</li>
</ul>
<ul>
<li>项目的知识管理：管理项目相关的其他内容，比如开发者信息，版本等等。</li>
</ul>
<h2 id="maven-的安装与配置"><a href="#maven-的安装与配置" class="headerlink" title="maven 的安装与配置"></a>maven 的安装与配置</h2><ul>
<li>下载，地址：<a target="_blank" rel="noopener" href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></li>
</ul>
<p><img src="/2020/11/18/maven/image-20201118160234868.png" alt="image-20201118160234868"></p>
<blockquote>
<p>注意：安装 maven 之前，必须先确保你的机器中已经安装了 jdk，如果是 maven 3 则必须 jdk 1.7 以上。</p>
</blockquote>
<ul>
<li>解压，添加环境变量 <strong>MAVEN_HOME</strong>，值为解压后的 maven 路径。</li>
</ul>
<p><img src="/2020/11/18/maven/1605703683(1).jpg" alt="1605703683(1)"></p>
<ul>
<li>在 <strong>Path</strong> 环境变量的变量值末尾添加 <strong>%MAVEN_HOME%\bin;</strong> 。</li>
</ul>
<p><img src="/2020/11/18/maven/1605703778(1).jpg" alt="1605703778(1)"></p>
<ul>
<li>在 cmd 窗口输入 <strong>mvn –version</strong>，显示 maven 版本信息，说明安装配置成功。</li>
</ul>
<p><img src="/2020/11/18/maven/1605704022(1).jpg" alt="1605704022(1)"></p>
<h2 id="在-IDEA-中使用-maven"><a href="#在-IDEA-中使用-maven" class="headerlink" title="在 IDEA 中使用 maven"></a>在 IDEA 中使用 maven</h2><p><img src="/2020/11/18/maven/image-20210120172317523.png" alt="image-20210120172317523"></p>
<h2 id="maven-的仓库"><a href="#maven-的仓库" class="headerlink" title="maven 的仓库"></a>maven 的仓库</h2><p>maven 仓库分为本地仓库和远程仓库，而远程仓库又分为 maven 中央仓库、其他远程仓库和私服 (私有服务器)。其中，中央仓库是由 maven 官方提供的，而私服就需要我们自己搭建。</p>
<p><img src="/2020/11/18/maven/160b27fd1730a299" alt="image.png"></p>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>默认情况下，不管 linux 还是 windows，每个用户在自己的用户目录下都有一个路径名为 .m2\repository 的仓库目录，如：C:\Users\XiSun\.m2\repository。如果不自定义本地仓库的地址，则会将下载的构件放到该目录下。</p>
<p>修改 maven 根目录下的 conf 文件夹中的 setting.xml 文件，可以自定义本地仓库地址，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\Program Files\Maven\apache-maven-3.6.3-maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>运行 maven 的时候，maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</strong></p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="maven-中央仓库"><a href="#maven-中央仓库" class="headerlink" title="maven 中央仓库"></a>maven 中央仓库</h4><p>maven 中央仓库，是由 maven 社区提供的仓库，其中包含了大量常用的库。一般来说，简单的  java 项目依赖的构件都可以在这里下载到。</p>
<blockquote>
<p>在 maven 安装目录的 lib 目录下，有一个 maven-model-builder-3.6.1.jar，里面的 org/apache/maven/model/pom-4.0.0.xml 文件定义了 maven 默认中央仓库的地址：<a target="_blank" rel="noopener" href="https://repo.maven.apache.org/maven2">https://repo.maven.apache.org/maven2</a></p>
</blockquote>
<p>因为 maven 中央仓库默认在国外，国内使用难免很慢，推荐将其更换为阿里云的镜像。</p>
<p>全局配置：修改 maven 根目录下的 conf 文件夹中的 setting.xml 文件，在 mirrors 节点上，添加如下内容。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>局部配置：修改项目的 pom.xml 文件，在 repositories 上，添加如下内容。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    	<span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多中央仓库地址参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Hello_World_QWP/article/details/82463799%E3%80%82">https://blog.csdn.net/Hello_World_QWP/article/details/82463799。</a></p>
</blockquote>
<h4 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h4><p>maven 私服就是公司局域网内的 maven 远程仓库，每个员工的电脑上安装 maven 软件并且连接 maven 私服，程序员可以将自己开发的项目打成 jar 并发布到私服，其它项目组成员就可以从私服下载所依赖的 jar。</p>
<p>私服还充当一个代理服务器的角色，当私服上没有 jar 包时，会从 maven 中央仓库自动下载。</p>
<p>nexus 是一个 maven 仓库管理器 (其实就是一个软件)，nexus 可以充当 maven 私服，同时 nexus 还提供强大的仓库管理、构件搜索等功能。</p>
<p>如果 maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，maven 提供了远程仓库的概念，它是开发人员自己定制的仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p>
<h5 id="搭建-maven-私服"><a href="#搭建-maven-私服" class="headerlink" title="搭建 maven 私服"></a>搭建 maven 私服</h5><ol>
<li><p>下载 nexus，地址：<a target="_blank" rel="noopener" href="https://help.sonatype.com/repomanager2/download/download-archives---repository-manager-oss">https://help.sonatype.com/repomanager2/download/download-archives---repository-manager-oss</a></p>
</li>
<li><p>安装 nexus</p>
</li>
</ol>
<p>将下载的压缩包进行解压，进入 bin 目录：</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%8717.png" alt="1559551510928"></p>
<p>打开 cmd 窗口并进入上面 bin 目录下，执行 <code>nexus.bat install</code> 命令安装服务 (注意需要以管理员身份运行 cmd 命令)：</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%8718.png" alt="1559551531544"></p>
<ol start="3">
<li>启动 nexus</li>
</ol>
<p>经过前面命令已经完成 nexus 的安装，可以通过如下两种方式启动 nexus 服务。</p>
<ul>
<li>在 Windows 系统服务中启动 nexus</li>
</ul>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%8719.png" alt="1559551564441"></p>
<ul>
<li>在命令行执行 <code>nexus.bat start</code> 命令启动 nexus</li>
</ul>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%8720.png" alt="1559551591730"></p>
<ol start="4">
<li>访问 nexus</li>
</ol>
<p>启动 nexus 服务后，访问 <a target="_blank" rel="noopener" href="http://localhost:8081/nexus%EF%BC%8C%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92">http://localhost:8081/nexus，点击右上角</a> LogIn 按钮，使用默认用户名 admin 和密码 admin123 登录系统。</p>
<p>登录成功后，点击左侧菜单 Repositories，可以看到 nexus 内置的仓库列表，如下图：</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%87.png" alt="1559551620133"></p>
<h5 id="nexus-仓库类型"><a href="#nexus-仓库类型" class="headerlink" title="nexus 仓库类型"></a>nexus 仓库类型</h5><p>通过前面的仓库列表可以看到，nexus 默认内置了很多仓库，这些仓库可以划分为 4 种类型，每种类型的仓库用于存放特定的 jar 包，具体说明如下。</p>
<ul>
<li>hosted：宿主仓库，部署自己的 jar 到这个类型的仓库，包括 Releases 和 Snapshots 两部分，Releases 为公司内部发布版本仓库，Snapshots 为公司内部测试版本仓库。</li>
</ul>
<ul>
<li><p>proxy：代理仓库，用于代理远程的公共仓库，如 maven 中央仓库，用户连接私服，私服自动去中央仓库下载 jar 包或者插件。</p>
</li>
<li><p>group：仓库组，用来合并多个 hosted 或 proxy 仓库，通常我们配置自己的 maven 连接仓库组。</p>
</li>
<li><p>virtual (虚拟)：兼容 Maven1 版本的 jar 或者插件。</p>
</li>
</ul>
<h5 id="nexus-仓库类型与安装目录对应关系"><a href="#nexus-仓库类型与安装目录对应关系" class="headerlink" title="nexus 仓库类型与安装目录对应关系"></a>nexus 仓库类型与安装目录对应关系</h5><p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%8722.png" alt="1559551752012"></p>
<h5 id="将项目发布到-maven-私服"><a href="#将项目发布到-maven-私服" class="headerlink" title="将项目发布到 maven 私服"></a>将项目发布到 maven 私服</h5><p>maven 私服是搭建在公司局域网内的 maven 仓库，公司内的所有开发团队都可以使用。例如技术研发团队开发了一个基础组件，就可以将这个基础组件打成 jar 包发布到私服，其他团队成员就可以从私服下载这个 jar 包到本地仓库并在项目中使用。</p>
<p>具体操作步骤如下：</p>
<ol>
<li>配置 maven 的 settings.xml 文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：一定要在 idea 工具中引入的 maven 的 settings.xml 文件中配置。</p>
</blockquote>
<ol start="2">
<li>配置项目的 pom.xml 文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">   		<span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行 <code>mvn clean deploy</code> 命令</li>
</ol>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%8723.png" alt="1559551977984"></p>
<h5 id="从私服下载-jar-到本地仓库"><a href="#从私服下载-jar-到本地仓库" class="headerlink" title="从私服下载 jar 到本地仓库"></a>从私服下载 jar 到本地仓库</h5><p>前面我们已经完成了将本地项目打成 jar 包发布到 maven 私服，下面我们就需要从 maven 私服下载 jar 包到本地仓库。</p>
<p>具体操作步骤如下：</p>
<ol>
<li>在 maven 的 settings.xml 文件中配置下载模板</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--仓库地址，即nexus仓库组的地址--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--是否下载releases构件--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--是否下载snapshots构件--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 maven 的 settings.xml 文件中配置激活下载模板</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="将第三方-jar-安装到本地仓库和-maven-私服"><a href="#将第三方-jar-安装到本地仓库和-maven-私服" class="headerlink" title="将第三方 jar 安装到本地仓库和 maven 私服"></a>将第三方 jar 安装到本地仓库和 maven 私服</h3><p>在 maven 工程的 pom.xml 文件中配置某个 jar 包的坐标后，如果本地的 maven 仓库不存在这个 jar 包，maven 工具会自动到配置的 maven 私服下载，如果私服中也不存在，maven 私服就会从 maven 中央仓库进行下载。</p>
<p>但是并不是所有的 jar 包都可以从中央仓库下载到，比如常用的 Oracle 数据库驱动的 jar 包在中央仓库就不存在。此时需要到 Oracle 的官网下载驱动 jar 包，然后将此 jar 包通过 maven 命令安装到我们本地的 maven 仓库或者 maven 私服中，这样在 maven 项目中就可以使用 maven 坐标引用到此 jar 包了。</p>
<h4 id="将第三方-jar-安装到本地仓库"><a href="#将第三方-jar-安装到本地仓库" class="headerlink" title="将第三方 jar 安装到本地仓库"></a>将第三方 jar 安装到本地仓库</h4><ol>
<li><p>下载 Oracle 的 jar 包</p>
</li>
<li><p>mvn install 命令进行安装</p>
   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=ojdbc14-10.2.0.4.0.jar -DgroupId=com.oracle -DartifactId=ojdbc14 –Dversion=10.2.0.4.0 -Dpackaging=jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看本地 maven 仓库，确认安装是否成功</p>
</li>
</ol>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%8724.png" alt="1559552325997"></p>
<p>再比如安装 Classifier4J-0.6.jar，打开 cmd 窗口，切换到 jar 包所在目录，输入 mvn 命令，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -DgroupId=net.sf(自定义，需要与pom.xml文件中的groupId一致) -DartifactId=classifier4j(自定义，需要与pom.xml文件中的artifaceId一致) -Dversion=0.6(自定义，需要与pom.xml文件中的version一致) -Dpackaging=jar -Dfile=Classifier4J-0.6.jar(本地jar包)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-DgroupId、-DartifactId、-Dversion、-Dpackaging、-Dfile 前面均有一个空格。</p>
</blockquote>
<p>使用示例如下：</p>
<p><img src="/2020/11/18/maven/image-20201118153146623.png"></p>
<p>之后，在 maven 的本地仓库，根据 groupId —— artifactId —— version，即可找到打包进来的本地 jar 包，也可以在项目中的 pom.xml 文件引入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>classifier4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="将第三方-jar-安装到-maven-私服"><a href="#将第三方-jar-安装到-maven-私服" class="headerlink" title="将第三方 jar 安装到 maven 私服"></a>将第三方 jar 安装到 maven 私服</h4><ol>
<li><p>下载 Oracle 的 jar 包</p>
</li>
<li><p>在 maven 的 settings.xml 配置文件中配置第三方仓库的 server 信息</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>thirdparty<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>执行 mvn deploy 命令进行安装</p>
   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy:deploy-file -Dfile=ojdbc14-10.2.0.4.0.jar -DgroupId=com.oracle -DartifactId=ojdbc14 –Dversion=10.2.0.4.0 -Dpackaging=jar –Durl=http://localhost:8081/nexus/content/repositories/thirdparty/ -DrepositoryId=thirdparty</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="maven-的依赖搜索顺序"><a href="#maven-的依赖搜索顺序" class="headerlink" title="maven 的依赖搜索顺序"></a>maven 的依赖搜索顺序</h2><p>一般情况下，当执行 maven 构建命令时，maven 按照以下顺序查找依赖的库：</p>
<ul>
<li><strong>步骤 1</strong>：在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>
<li><strong>步骤 2</strong>：在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li>
<li><strong>步骤 3</strong>：如果远程仓库没有被设置，maven 将简单的停滞处理并抛出错误 (无法找到依赖的文件)。</li>
<li><strong>步骤 4</strong>：在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 maven 将停止处理并抛出错误 (无法找到依赖的文件)。</li>
</ul>
<h2 id="maven-的常用命令"><a href="#maven-的常用命令" class="headerlink" title="maven 的常用命令"></a>maven 的常用命令</h2><ul>
<li>clean：     清理</li>
</ul>
<ul>
<li>compile：编译</li>
</ul>
<ul>
<li>test：        测试</li>
</ul>
<ul>
<li>package：打包</li>
</ul>
<ul>
<li>install：    安装</li>
</ul>
<h2 id="maven-的坐标书写规范"><a href="#maven-的坐标书写规范" class="headerlink" title="maven 的坐标书写规范"></a>maven 的坐标书写规范</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="maven-的依赖范围"><a href="#maven-的依赖范围" class="headerlink" title="maven 的依赖范围"></a>maven 的依赖范围</h2><table>
<thead>
<tr>
<th>依赖范围</th>
<th>对于编译 classpath 有效</th>
<th>对于测试 classpath 有效</th>
<th>对于运行 classpath 有效</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>spring-core</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>JDBC 驱动</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>本地的，maven 仓库之外的类库</td>
</tr>
</tbody></table>
<p>默认使用 compile 依赖范围。</p>
<p>使用 system 依赖范围的依赖时，必须通过 systemPath 元素显示地指定依赖文件的路径。由于此类依赖不是通过 maven 仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath 元素可以引用环境变量，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="maven-的依赖传递"><a href="#maven-的依赖传递" class="headerlink" title="maven 的依赖传递"></a>maven 的依赖传递</h2><h3 id="什么是依赖传递"><a href="#什么是依赖传递" class="headerlink" title="什么是依赖传递"></a>什么是依赖传递</h3><p>在 maven 中，依赖是可以传递的，假设存在三个项目，分别是项目 A，项目 B 以及项目 C。假设 C 依赖 B，B 依赖 A，那么根据 maven 项目依赖的特征，不难推出项目 C 也依赖 A。如图所示：</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%873.png" alt="1559549336921"></p>
<p>​                         <img src="/2020/11/18/maven/%E5%9B%BE%E7%89%874.png" alt="1559549377105"></p>
<p>通过上面的图可以看到， 在一个 web 项目中，直接依赖了 spring-webmvc，而 spring-webmvc 依赖了 spring-aop、spring-beans 等。最终的结果就是在这个 web 项目中，间接依赖了 spring-aop、spring-beans 等。</p>
<h3 id="什么是依赖冲突"><a href="#什么是依赖冲突" class="headerlink" title="什么是依赖冲突"></a>什么是依赖冲突</h3><p>由于依赖传递现象的存在，如图所示，spring-webmvc 依赖 spirng-beans-4.2.4，spring-aop 依赖 spring-beans-5.0.2，现在 spirng-beans-4.2.4 已经加入到了工程中，而我们希望 spring-beans-5.0.2 加入工程。这就造成了依赖冲突。</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%875.png" alt="1559549435874"></p>
<h3 id="如何解决依赖冲突"><a href="#如何解决依赖冲突" class="headerlink" title="如何解决依赖冲突"></a>如何解决依赖冲突</h3><ol>
<li>使用 maven 提供的依赖调节原则 </li>
</ol>
<ol start="2">
<li><p>排除依赖</p>
</li>
<li><p>锁定版本 </p>
</li>
</ol>
<h4 id="依赖调节原则"><a href="#依赖调节原则" class="headerlink" title="依赖调节原则"></a>依赖调节原则</h4><h5 id="路径近者优先原则"><a href="#路径近者优先原则" class="headerlink" title="路径近者优先原则"></a>路径近者优先原则</h5><p>当依赖声明不在同一个 pom.xml 文件中时，或者说存在依赖传递时，路径最短的 jar 包将被选为最终依赖。</p>
<p><img src="/2020/11/18/maven/image-20210118164236303.png" alt="image-20210118164236303"></p>
<p>上图中，Jar2.0 将被选为最终依赖。</p>
<h5 id="第一声明者优先原则"><a href="#第一声明者优先原则" class="headerlink" title="第一声明者优先原则"></a>第一声明者优先原则</h5><p>当依赖声明不在同一个 pom.xml 文件中时，或者说存在依赖传递时，并且依赖传递长度相同时，最先声明的依赖将被选为最终依赖。</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%876.png" alt="1559549523188"></p>
<p>上图中，spring-aop 和 spring-webmvc 都依赖了 spring-beans，但是因为 spring-aop 在前面，所以最终使用的 spring-beans 是由 spring-aop 传递过来的，而 spring-webmvc 传递过来的 spring-beans 则被忽略了。</p>
<h5 id="覆盖优先"><a href="#覆盖优先" class="headerlink" title="覆盖优先"></a>覆盖优先</h5><p>当依赖声明在同一个 pom.xml 文件中时，后面声明的依赖将覆盖前面声明的依赖。</p>
<h4 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h4><p>使用 exclusions 标签将传递过来的依赖排除出去。</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%877.png" alt="1559549561284"></p>
<h4 id="版本锁定"><a href="#版本锁定" class="headerlink" title="版本锁定"></a>版本锁定</h4><p>采用直接锁定版本的方法确定依赖 jar 包的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本为准添加到工程中，此方法在企业开发中经常使用。</p>
<p>版本锁定的使用方式：</p>
<p>第一步：在 dependencyManagement 标签中锁定依赖的版本</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%878.png" alt="1559549614223"></p>
<p>第二步：在 dependencies 标签中声明需要导入的 maven 坐标</p>
<p><img src="/2020/11/18/maven/%E5%9B%BE%E7%89%879.png" alt="1559549637900"></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>能查找依赖的网站：<a target="_blank" rel="noopener" href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903543711907848">https://juejin.cn/post/6844903543711907848</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a1d9fd97f568">https://www.jianshu.com/p/a1d9fd97f568</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/10/kafka-consumer-offsetandfetcher/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/10/kafka-consumer-offsetandfetcher/" class="post-title-link" itemprop="url">KafkaConsumer 源码之 consumer 如何拉取 offset 和数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-10 11:32:06" itemprop="dateCreated datePublished" datetime="2020-11-10T11:32:06+08:00">2020-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-05 15:32:53" itemprop="dateModified" datetime="2021-01-05T15:32:53+08:00">2021-01-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://acatsmiling.github.io/2020/11/04/kafka-consumer-group/">上一篇文章</a>讲了 consumer 如何加入 consumer group，现在加入 group 成功之后，就要准备开始消费。</p>
<p><code>kafkaConsumer.poll ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Step1:确认KafkaConsumer实例是单线程运行，以及没有被关闭</span></span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Consumer is not subscribed to any topics or assigned any partitions&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="comment">// Step2:更新metadata信息，获取GroupCoordinator的ip以及接口，并连接、 join-group、sync-group，期间group会进行rebalance。在此步骤，consumer会先加入group，然后获取需要消费的topic partition的offset信息</span></span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;Still waiting for metadata&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step3:拉取数据，核心步骤</span></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);</span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// before returning the fetched records, we can send off the next round of fetches</span></span><br><span class="line">                <span class="comment">// and avoid block waiting for their responses to enable pipelining while the user</span></span><br><span class="line">                <span class="comment">// is handling the fetched records.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> since the consumed position has already been updated, we must not allow</span></span><br><span class="line">                <span class="comment">// wakeups or any other errors to be triggered prior to returning the fetched records.</span></span><br><span class="line">                <span class="comment">// 在返回数据之前，发送下次的fetch请求，避免用户在下次获取数据时线程block</span></span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.pollNoWakeup();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧跟上一篇文章，我们继续分析 consumer 加入 group 后的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Visible for testing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.上一篇主要集中在coordinator.poll(timer)方法源码分析(主要功能是:consumer加入group)</span></span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.poll(timer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.本篇文章从updateFetchPositions(timer)方法开始继续分析(主要功能是:consumer获得partition的offset)</span></span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KafkaConsumer-的消费策略"><a href="#KafkaConsumer-的消费策略" class="headerlink" title="KafkaConsumer 的消费策略"></a>KafkaConsumer 的消费策略</h2><p>首先，我们应该知道，KafkaConsumer 关于如何消费的 2 种策略：</p>
<ul>
<li><p><strong>手动指定</strong>：调用 <code>consumer.seek(TopicPartition, offset)</code>，然后开始 <code>poll ()</code>。</p>
</li>
<li><p><strong>自动指定</strong>：<code>poll ()</code> 之前给集群发送请求，让集群告知客户端，当前该 TopicPartition 的 offset 是多少，这也是我们此次分析的重点。</p>
</li>
</ul>
<p>在讲如何拉取 offset 之前，先认识下下面这个类 (SubscriptionState 的内部类)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartitionState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FetchState fetchState;</span><br><span class="line">    <span class="keyword">private</span> FetchPosition position; <span class="comment">// last consumed position</span></span><br><span class="line">    <span class="keyword">private</span> Long highWatermark; <span class="comment">// the high watermark from last fetch</span></span><br><span class="line">    <span class="keyword">private</span> Long logStartOffset; <span class="comment">// the log start offset</span></span><br><span class="line">    <span class="keyword">private</span> Long lastStableOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> paused;  <span class="comment">// whether this partition has been paused by the user</span></span><br><span class="line">    <span class="keyword">private</span> OffsetResetStrategy resetStrategy;  <span class="comment">// the strategy to use if the offset needs resetting</span></span><br><span class="line">    <span class="keyword">private</span> Long nextRetryTimeMs;</span><br><span class="line">    <span class="keyword">private</span> Integer preferredReadReplica;</span><br><span class="line">    <span class="keyword">private</span> Long preferredReadReplicaExpireTimeMs;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer 实例订阅的每个 topic-partition 都会有一个对应的 TopicPartitionState 对象，在这个对象中会记录上面内容，最需要关注的就是 <strong>position 这个属性，它表示上一次消费的位置</strong>。通过 <code>consumer.seek ()</code> 方式指定消费 offset 的时候，其实设置的就是这个 position 值。</p>
<h2 id="updateFetchPositions-拉取-offset"><a href="#updateFetchPositions-拉取-offset" class="headerlink" title="updateFetchPositions - 拉取 offset"></a>updateFetchPositions - 拉取 offset</h2><p>在 consumer 成功加入 group 并开始消费之前，我们还需要知道 consumer 是从 offset 为多少的位置开始消费。consumer 加入 group 之后，就得去获取 offset 了，下面的方法，就是开始更新 position (offset)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the fetch position to the committed position (if there is one)</span></span><br><span class="line"><span class="comment"> * or reset it using the offset reset policy the user has configured.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> org.apache.kafka.common.errors.AuthenticationException if authentication fails. See the exception for more details</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoOffsetForPartitionException If no offset is stored for a given partition and no offset reset policy is</span></span><br><span class="line"><span class="comment"> *             defined</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true iff the operation completed without timing out</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateFetchPositions</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If any partitions have been truncated due to a leader change, we need to validate the offsets</span></span><br><span class="line">    fetcher.validateOffsetsIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step1:查看TopicPartitionState的position是否为空，第一次消费肯定为空</span></span><br><span class="line">    cachedSubscriptionHashAllFetchPositions = subscriptions.hasAllFetchPositions();</span><br><span class="line">    <span class="keyword">if</span> (cachedSubscriptionHashAllFetchPositions) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any partitions which do not have a valid position and are not</span></span><br><span class="line">    <span class="comment">// awaiting reset, then we need to fetch committed offsets. We will only do a</span></span><br><span class="line">    <span class="comment">// coordinator lookup if there are partitions which have missing positions, so</span></span><br><span class="line">    <span class="comment">// a consumer with manually assigned partitions can avoid a coordinator dependence</span></span><br><span class="line">    <span class="comment">// by always ensuring that assigned partitions have an initial position.</span></span><br><span class="line">    <span class="comment">// Step2:如果没有有效的offset，那么需要从GroupCoordinator中获取</span></span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.refreshCommittedOffsetsIfNeeded(timer)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are partitions still needing a position and a reset policy is defined,</span></span><br><span class="line">    <span class="comment">// request reset using the default policy. If no reset strategy is defined and there</span></span><br><span class="line">    <span class="comment">// are partitions with a missing position, then we will raise an exception.</span></span><br><span class="line">    <span class="comment">// Step3:如果还存在partition不知道position，并且设置了offsetreset策略，那么就等待重置，不然就抛出异常</span></span><br><span class="line">    subscriptions.resetMissingPositions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally send an asynchronous request to lookup and update the positions of any</span></span><br><span class="line">    <span class="comment">// partitions which are awaiting reset.</span></span><br><span class="line">    <span class="comment">// Step4:向PartitionLeader(GroupCoordinator所在机器)发送ListOffsetRequest重置position</span></span><br><span class="line">    fetcher.resetOffsetsIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要分为 4 个步骤，具体如下：</p>
<ol>
<li>首先，查看当前 TopicPartition 的 position 是否为空，如果不为空，表示知道下次 fetch position (即拉取数据时从哪个位置开始拉取)，但如果是第一次消费，这个 <code>TopicPartitionState.position</code> 肯定为空。</li>
<li>然后，通过 GroupCoordinator 为缺少 fetch position 的 partition 拉取 position (即 last committed offset)。</li>
<li>继而，仍不知道 partition 的 position (_consumer_offsets 中未保存位移信息)，且设置了 offsetreset 策略，那么就等待重置，如果没有设置重置策略，就抛出 <code>NoOffsetForPartitionException</code> 异常。</li>
<li>最后，为那些需要重置 fetch position 的 partition 发送 ListOffsetRequest 重置 position (<code>consumer.beginningOffsets ()</code>，<code>consumer.endOffsets ()</code>，<code>consumer.offsetsForTimes ()</code>，<code>consumer.seek ()</code> 都会发送 ListOffRequest 请求)。</li>
</ol>
<blockquote>
<p>上面说的几个方法相当于都是用户自己自定义消费的 offset，所以可能出现越界 (消费位置无法在实际分区中查到) 的情况，所以也是会发送 ListOffsetRequest 请求的，即触发 <code>auto.offset.reset</code> 参数的执行。<br>比如现在某个 partition 的可拉取 offset 最大值为 100，如果你指定消费 offset=200 的位置，那肯定拉取不到，此时就会根据 <code>auto.offset.reset</code> 策略将拉取位置重置为 100 (默认的 <code>auto.offset.reset</code> 为 latest)。</p>
</blockquote>
<h3 id="refreshCommittedOffsetsIfNeeded"><a href="#refreshCommittedOffsetsIfNeeded" class="headerlink" title="refreshCommittedOffsetsIfNeeded"></a>refreshCommittedOffsetsIfNeeded</h3><p>我们先看下 Setp 2 中 GroupCoordinator 是如何 fetch position 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Refresh the committed offsets for provided partitions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true iff the operation completed within the timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshCommittedOffsetsIfNeeded</span><span class="params">(Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;TopicPartition&gt; missingFetchPositions = subscriptions.missingFetchPositions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.发送获取offset的请求，核心步骤</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = fetchCommittedOffsets(missingFetchPositions, timer);</span><br><span class="line">    <span class="keyword">if</span> (offsets == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;TopicPartition, OffsetAndMetadata&gt; entry : offsets.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> TopicPartition tp = entry.getKey();</span><br><span class="line">        <span class="comment">// 2.获取response中的offset</span></span><br><span class="line">        <span class="keyword">final</span> OffsetAndMetadata offsetAndMetadata = entry.getValue();</span><br><span class="line">        <span class="keyword">final</span> ConsumerMetadata.LeaderAndEpoch leaderAndEpoch = metadata.leaderAndEpoch(tp);</span><br><span class="line">        <span class="keyword">final</span> SubscriptionState.FetchPosition position = <span class="keyword">new</span> SubscriptionState.FetchPosition(</span><br><span class="line">                offsetAndMetadata.offset(), offsetAndMetadata.leaderEpoch(),</span><br><span class="line">                leaderAndEpoch);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;Setting offset for partition &#123;&#125; to the committed offset &#123;&#125;&quot;</span>, tp, position);</span><br><span class="line">        entry.getValue().leaderEpoch().ifPresent(epoch -&gt; <span class="keyword">this</span>.metadata.updateLastSeenEpochIfNewer(entry.getKey(), epoch));</span><br><span class="line">        <span class="comment">// 3.实际就是设置SubscriptionState的position值</span></span><br><span class="line">        <span class="keyword">this</span>.subscriptions.seekUnvalidated(tp, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fetchCommittedOffsets ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fetch the current committed offsets from the coordinator for a set of partitions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> partitions The partitions to fetch offsets for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A map from partition to the committed offset or null if the operation timed out</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; <span class="title">fetchCommittedOffsets</span><span class="params">(<span class="keyword">final</span> Set&lt;TopicPartition&gt; partitions,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                    <span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (partitions.isEmpty()) <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Generation generation = generation();</span><br><span class="line">    <span class="keyword">if</span> (pendingCommittedOffsetRequest != <span class="keyword">null</span> &amp;&amp; !pendingCommittedOffsetRequest.sameRequest(partitions, generation)) &#123;</span><br><span class="line">        <span class="comment">// if we were waiting for a different request, then just clear it.</span></span><br><span class="line">        pendingCommittedOffsetRequest = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ensureCoordinatorReady(timer)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// contact coordinator to fetch committed offsets</span></span><br><span class="line">        <span class="keyword">final</span> RequestFuture&lt;Map&lt;TopicPartition, OffsetAndMetadata&gt;&gt; future;</span><br><span class="line">        <span class="keyword">if</span> (pendingCommittedOffsetRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">            future = pendingCommittedOffsetRequest.response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.封装FetchRequest请求</span></span><br><span class="line">            future = sendOffsetFetchRequest(partitions);</span><br><span class="line">            pendingCommittedOffsetRequest = <span class="keyword">new</span> PendingCommittedOffsetRequest(partitions, generation, future);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.通过KafkaClient发送请求</span></span><br><span class="line">        client.poll(future, timer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">            pendingCommittedOffsetRequest = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (future.succeeded()) &#123;</span><br><span class="line">                <span class="comment">// 3.请求成功，获取请求的响应数据</span></span><br><span class="line">                <span class="keyword">return</span> future.value();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!future.isRetriable()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> future.exception();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timer.sleep(retryBackoffMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的步骤和我们之前提到的发送其他请求毫无区别，基本就是这三个套路。</p>
<p>在获取到响应之后，会通过 <code>subscriptions.seekUnvalidated ()</code> 方法为每个 TopicPartition 设置 position 值后，就知道从哪里开始消费订阅 topic 下的 partition 了。</p>
<h3 id="resetMissingPositions"><a href="#resetMissingPositions" class="headerlink" title="resetMissingPositions"></a>resetMissingPositions</h3><p>在 Step 3 中，什么时候发起 FetchRequest 拿不到 position 呢？</p>
<p>我们知道消费位移 (consume offset) 是保存在 _consumer_offsets 这个 topic 里面的，当我们进行消费的时候需要知道上次消费到了什么位置。那么就会发起请求去看上次消费到了 topic 的 partition 的哪个位置，但是这个消费位移是有保存时长的，默认为 7 天 (broker 端通过 <code>offsets.retention.minutes</code> 设置)。</p>
<p>当隔了一段时间再进行消费，如果这个间隔时间超过了参数的配置值，那么原先的位移信息就会丢失，最后只能通过客户端参数 <code>auto.offset.reset</code> 来确定开始消费的位置。</p>
<p>如果我们第一次消费 topic，那么在 _consumer_offsets 中也是找不到消费位移的，所以就会执行第四个步骤，发起 ListOffsetRequest 请求根据配置的 reset 策略 (即 <code>auto.offset.reset</code>) 来决定开始消费的位置。</p>
<h3 id="resetOffsetsIfNeeded"><a href="#resetOffsetsIfNeeded" class="headerlink" title="resetOffsetsIfNeeded"></a>resetOffsetsIfNeeded</h3><p>在 Step 4 中，发起 ListOffsetRequest 请求和处理 response 的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset offsets for all assigned partitions that require it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> org.apache.kafka.clients.consumer.NoOffsetForPartitionException If no offset reset strategy is defined</span></span><br><span class="line"><span class="comment"> *   and one or more partitions aren&#x27;t awaiting a seekToBeginning() or seekToEnd().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetOffsetsIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raise exception from previous offset fetch if there is one</span></span><br><span class="line">    RuntimeException exception = cachedListOffsetsException.getAndSet(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.需要执行reset策略的partition</span></span><br><span class="line">    Set&lt;TopicPartition&gt; partitions = subscriptions.partitionsNeedingReset(time.milliseconds());</span><br><span class="line">    <span class="keyword">if</span> (partitions.isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, Long&gt; offsetResetTimestamps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> TopicPartition partition : partitions) &#123;</span><br><span class="line">        Long timestamp = offsetResetStrategyTimestamp(partition);</span><br><span class="line">        <span class="keyword">if</span> (timestamp != <span class="keyword">null</span>)</span><br><span class="line">            offsetResetTimestamps.put(partition, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.执行reset策略</span></span><br><span class="line">    resetOffsetsAsync(offsetResetTimestamps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetOffsetsAsync</span><span class="params">(Map&lt;TopicPartition, Long&gt; partitionResetTimestamps)</span> </span>&#123;</span><br><span class="line">    Map&lt;Node, Map&lt;TopicPartition, ListOffsetRequest.PartitionData&gt;&gt; timestampsToSearchByNode =</span><br><span class="line">            groupListOffsetRequests(partitionResetTimestamps, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, Map&lt;TopicPartition, ListOffsetRequest.PartitionData&gt;&gt; entry : timestampsToSearchByNode.entrySet()) &#123;</span><br><span class="line">        Node node = entry.getKey();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;TopicPartition, ListOffsetRequest.PartitionData&gt; resetTimestamps = entry.getValue();</span><br><span class="line">        subscriptions.setNextAllowedRetry(resetTimestamps.keySet(), time.milliseconds() + requestTimeoutMs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.发送ListOffsetRequest请求</span></span><br><span class="line">        RequestFuture&lt;ListOffsetResult&gt; future = sendListOffsetRequest(node, resetTimestamps, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.为ListOffsetRequest请求添加监听器</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ListOffsetResult&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ListOffsetResult result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!result.partitionsToRetry.isEmpty()) &#123;</span><br><span class="line">                    subscriptions.requestFailed(result.partitionsToRetry, time.milliseconds() + retryBackoffMs);</span><br><span class="line">                    metadata.requestUpdate();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, ListOffsetData&gt; fetchedOffset : result.fetchedOffsets.entrySet()) &#123;</span><br><span class="line">                    TopicPartition partition = fetchedOffset.getKey();</span><br><span class="line">                    ListOffsetData offsetData = fetchedOffset.getValue();</span><br><span class="line">                    ListOffsetRequest.PartitionData requestedReset = resetTimestamps.get(partition);</span><br><span class="line">                    <span class="comment">// 3.发送ListOffsetRequest请求成功，对结果reset，如果reset策略设置的是latest，那么requestedReset.timestamp = -1，如果是earliest，requestedReset.timestamp = -2</span></span><br><span class="line">                    resetOffsetIfNeeded(partition, timestampToOffsetResetStrategy(requestedReset.timestamp), offsetData);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">                subscriptions.requestFailed(resetTimestamps.keySet(), time.milliseconds() + retryBackoffMs);</span><br><span class="line">                metadata.requestUpdate();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> RetriableException) &amp;&amp; !cachedListOffsetsException.compareAndSet(<span class="keyword">null</span>, e))</span><br><span class="line">                    log.error(<span class="string">&quot;Discarding error in ListOffsetResponse because another error is pending&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sendListOffsetRequest ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Send the ListOffsetRequest to a specific broker for the partitions and target timestamps.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node The node to send the ListOffsetRequest to.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestampsToSearch The mapping from partitions to the target timestamps.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requireTimestamp  True if we require a timestamp in the response.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A response which can be polled to obtain the corresponding timestamps and offsets.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ListOffsetResult&gt; <span class="title">sendListOffsetRequest</span><span class="params">(<span class="keyword">final</span> Node node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              <span class="keyword">final</span> Map&lt;TopicPartition, ListOffsetRequest.PartitionData&gt; timestampsToSearch,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              <span class="keyword">boolean</span> requireTimestamp)</span> </span>&#123;</span><br><span class="line">    ListOffsetRequest.Builder builder = ListOffsetRequest.Builder</span><br><span class="line">            .forConsumer(requireTimestamp, isolationLevel)</span><br><span class="line">            .setTargetTimes(timestampsToSearch);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Sending ListOffsetRequest &#123;&#125; to broker &#123;&#125;&quot;</span>, builder, node);</span><br><span class="line">    <span class="keyword">return</span> client.send(node, builder)</span><br><span class="line">            .compose(<span class="keyword">new</span> RequestFutureAdapter&lt;ClientResponse, ListOffsetResult&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse response, RequestFuture&lt;ListOffsetResult&gt; future)</span> </span>&#123;</span><br><span class="line">                    ListOffsetResponse lor = (ListOffsetResponse) response.responseBody();</span><br><span class="line">                    log.trace(<span class="string">&quot;Received ListOffsetResponse &#123;&#125; from broker &#123;&#125;&quot;</span>, lor, node);</span><br><span class="line">                    handleListOffsetResponse(timestampsToSearch, lor, future);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resetOffsetIfNeeded ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetOffsetIfNeeded</span><span class="params">(TopicPartition partition, OffsetResetStrategy requestedResetStrategy, ListOffsetData offsetData)</span> </span>&#123;</span><br><span class="line">    SubscriptionState.FetchPosition position = <span class="keyword">new</span> SubscriptionState.FetchPosition(</span><br><span class="line">            offsetData.offset, offsetData.leaderEpoch, metadata.leaderAndEpoch(partition));</span><br><span class="line">    offsetData.leaderEpoch.ifPresent(epoch -&gt; metadata.updateLastSeenEpochIfNewer(partition, epoch));</span><br><span class="line">    <span class="comment">// reset对应的TopicPartition fetch的position</span></span><br><span class="line">    subscriptions.maybeSeekUnvalidated(partition, position.offset, requestedResetStrategy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释下 <code>auto.offset.reset</code> 的两个值 (latest 和 earliest) 的区别：</p>
<p>假设我们现在要消费 MyConsumerTopic 的数据，它有 3 个分区，生产者往这个 topic 发送了 10 条数据，然后分区数据按照 MyConsumerTopic-0 (3 条数据)，MyConsumerTopic-1 (3 条数据)，MyConsumerTopic-2 (4 条数据) 这样分配。</p>
<p>当设置为 latest 的时候，返回的 offset 具体到每个 partition 就是 HW 值 (partition 0 是 3，partition 1 是 3，partition 2 是 4)。</p>
<p>当设置为 earliest 的时候，就会从起始处 (即 LogStartOffset，注意不是 LSO) 开始消费，这里就是从 0 开始。</p>
<p><img src="/2020/11/10/kafka-consumer-offsetandfetcher/kafka-partition-analysis.png"></p>
<ul>
<li><p><strong>Log Start Offset</strong>：表示 partition 的起始位置，初始值为 0，由于消息的增加以及日志清除策略影响，这个值会阶段性增大。尤其注意这个不能缩写为 LSO，LSO 代表的是 LastStableOffset，和事务有关。</p>
</li>
<li><p><strong>Consumer Offset</strong>：消费位移，表示 partition 的某个消费者消费到的位移位置。</p>
</li>
<li><p><strong>High Watermark</strong>：简称 HW，代表消费端能看到的 partition 的最高日志位移，HW 大于等于 ConsumerOffset 的值。</p>
</li>
<li><p><strong>Log End Offset</strong>：简称 LEO，代表 partition 的最高日志位移，对消费者不可见，HW 到 LEO 这之间的数据未被 follwer 完全同步。</p>
</li>
</ul>
<p>至此，我们成功的知道 consumer 消费的 partition 的 offset 位置在哪里，下面就开始拉取 partition 里的数据。</p>
<h2 id="pollForFetches-拉取数据"><a href="#pollForFetches-拉取数据" class="headerlink" title="pollForFetches - 拉取数据"></a>pollForFetches - 拉取数据</h2><p>现在万事俱备只欠东风了，consumer 成功加入 group，也确定了需要拉取的 topic partition 的 offset，那么现在就应该去拉取数据了，其核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollForFetches(Timer timer) &#123;</span><br><span class="line">    <span class="keyword">long</span> pollTimeout = coordinator == <span class="keyword">null</span> ? timer.remainingMs() :</span><br><span class="line">            Math.min(coordinator.timeToNextPoll(timer.currentTimeMs()), timer.remainingMs());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if data is available already, return it immediately</span></span><br><span class="line">    <span class="comment">// 1.获取fetcher已经拉取到的数据</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</span><br><span class="line">    <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> records;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到此，说明上次fetch到的数据已经全部拉取了，需要再次发送fetch请求，从broker拉取新的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// send any new fetches (won&#x27;t resend pending fetches)</span></span><br><span class="line">    <span class="comment">// 2.发送fetch请求，会从多个topic-partition拉取数据(只要对应的topic-partition没有未完成的请求)</span></span><br><span class="line">    fetcher.sendFetches();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We do not want to be stuck blocking in poll if we are missing some positions</span></span><br><span class="line">    <span class="comment">// since the offset lookup may be backing off after a failure</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the use of cachedSubscriptionHashAllFetchPositions means we MUST call</span></span><br><span class="line">    <span class="comment">// updateAssignmentMetadataIfNeeded before this method.</span></span><br><span class="line">    <span class="keyword">if</span> (!cachedSubscriptionHashAllFetchPositions &amp;&amp; pollTimeout &gt; retryBackoffMs) &#123;</span><br><span class="line">        pollTimeout = retryBackoffMs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timer pollTimer = time.timer(pollTimeout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.真正开始发送，底层同样使用NIO</span></span><br><span class="line">    client.poll(pollTimer, () -&gt; &#123;</span><br><span class="line">        <span class="comment">// since a fetch might be completed by the background thread, we need this poll condition</span></span><br><span class="line">        <span class="comment">// to ensure that we do not block unnecessarily in poll()</span></span><br><span class="line">        <span class="keyword">return</span> !fetcher.hasCompletedFetches();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer.update(pollTimer.currentTimeMs());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// after the long poll, we should check whether the group needs to rebalance</span></span><br><span class="line">    <span class="comment">// prior to returning data so that the group can stabilize faster</span></span><br><span class="line">    <span class="comment">// 4.如果group需要rebalance，直接返回空数据，这样更快地让group进入稳定状态</span></span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; coordinator.rejoinNeededOrPending()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 5.返回拉取到的新数据</span></span><br><span class="line">    <span class="keyword">return</span> fetcher.fetchedRecords();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fetcher-sendFetches"><a href="#fetcher-sendFetches" class="headerlink" title="fetcher.sendFetches"></a>fetcher.sendFetches</h3><p>这里需要注意的是 <code>fetcher.sendFetches ()</code> 方法，在发送请求的同时会注册回调函数，当有 response 的时候，会解析 response，将返回的数据放到 Fetcher 的成员变量中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set-up a fetch request for any node that we have assigned partitions for which doesn&#x27;t already have</span></span><br><span class="line"><span class="comment"> * an in-flight fetch or pending fetch data.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> number of fetches sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">sendFetches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update metrics in case there was an assignment change</span></span><br><span class="line">    sensors.maybeUpdateAssignment(subscriptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建FetchRequest</span></span><br><span class="line">    Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; fetchRequestMap = prepareFetchRequests();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.FetchRequestData&gt; entry : fetchRequestMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node fetchTarget = entry.getKey();</span><br><span class="line">        <span class="keyword">final</span> FetchSessionHandler.FetchRequestData data = entry.getValue();</span><br><span class="line">        <span class="keyword">final</span> FetchRequest.Builder request = FetchRequest.Builder</span><br><span class="line">                .forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, data.toSend())</span><br><span class="line">                .isolationLevel(isolationLevel)</span><br><span class="line">                .setMaxBytes(<span class="keyword">this</span>.maxBytes)</span><br><span class="line">                .metadata(data.metadata())</span><br><span class="line">                .toForget(data.toForget())</span><br><span class="line">                .rackId(clientRackId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Sending &#123;&#125; &#123;&#125; to broker &#123;&#125;&quot;</span>, isolationLevel, data.toString(), fetchTarget);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.发送FetchRequest</span></span><br><span class="line">        RequestFuture&lt;ClientResponse&gt; future = client.send(fetchTarget, request);</span><br><span class="line">        <span class="comment">// We add the node to the set of nodes with pending fetch requests before adding the</span></span><br><span class="line">        <span class="comment">// listener because the future may have been fulfilled on another thread (e.g. during a</span></span><br><span class="line">        <span class="comment">// disconnection being handled by the heartbeat thread) which will mean the listener</span></span><br><span class="line">        <span class="comment">// will be invoked synchronously.</span></span><br><span class="line">        <span class="keyword">this</span>.nodesWithPendingFetchRequests.add(entry.getKey().id());</span><br><span class="line">        future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ClientResponse&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        FetchResponse&lt;Records&gt; response = (FetchResponse&lt;Records&gt;) resp.responseBody();</span><br><span class="line">                        FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;Unable to find FetchSessionHandler for node &#123;&#125;. Ignoring fetch response.&quot;</span>,</span><br><span class="line">                                    fetchTarget.id());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!handler.handleResponse(response)) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> HashSet&lt;&gt;(response.responseData().keySet());</span><br><span class="line">                        FetchResponseMetricAggregator metricAggregator = <span class="keyword">new</span> FetchResponseMetricAggregator(sensors, partitions);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&lt;Records&gt;&gt; entry : response.responseData().entrySet()) &#123;</span><br><span class="line">                            TopicPartition partition = entry.getKey();</span><br><span class="line">                            FetchRequest.PartitionData requestData = data.sessionPartitions().get(partition);</span><br><span class="line">                            <span class="keyword">if</span> (requestData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                String message;</span><br><span class="line">                                <span class="keyword">if</span> (data.metadata().isFull()) &#123;</span><br><span class="line">                                    message = MessageFormatter.arrayFormat(</span><br><span class="line">                                            <span class="string">&quot;Response for missing full request partition: partition=&#123;&#125;; metadata=&#123;&#125;&quot;</span>,</span><br><span class="line">                                            <span class="keyword">new</span> Object[]&#123;partition, data.metadata()&#125;).getMessage();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    message = MessageFormatter.arrayFormat(</span><br><span class="line">                                            <span class="string">&quot;Response for missing session request partition: partition=&#123;&#125;; metadata=&#123;&#125;; toSend=&#123;&#125;; toForget=&#123;&#125;&quot;</span>,</span><br><span class="line">                                            <span class="keyword">new</span> Object[]&#123;partition, data.metadata(), data.toSend(), data.toForget()&#125;).getMessage();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// Received fetch response for missing session partition</span></span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">long</span> fetchOffset = requestData.fetchOffset;</span><br><span class="line">                                FetchResponse.PartitionData&lt;Records&gt; fetchData = entry.getValue();</span><br><span class="line"></span><br><span class="line">                                log.debug(<span class="string">&quot;Fetch &#123;&#125; at offset &#123;&#125; for partition &#123;&#125; returned fetch data &#123;&#125;&quot;</span>,</span><br><span class="line">                                        isolationLevel, fetchOffset, partition, fetchData);</span><br><span class="line">                                <span class="comment">// 3.发送FetchRequest请求成功，将返回的数据放到ConcurrentLinkedQueue&lt;CompletedFetch&gt;中</span></span><br><span class="line">                                completedFetches.add(<span class="keyword">new</span> CompletedFetch(partition, fetchOffset, fetchData, metricAggregator,</span><br><span class="line">                                        resp.requestHeader().apiVersion()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        sensors.fetchLatency.record(resp.requestLatencyMs());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handler.handleError(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nodesWithPendingFetchRequests.remove(fetchTarget.id());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchRequestMap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要分为以下两步：</p>
<ol>
<li><code>prepareFetchRequests ()</code>：为订阅的所有 topic-partition list 创建 fetch 请求 (只要该 topic-partition 没有还在处理的请求)，创建的 fetch 请求依然是按照 node 级别创建的；</li>
<li><code>client.send ()</code>：发送 fetch 请求，并设置相应的 Listener，请求处理成功的话，就加入到 completedFetches 中，在加入这个 completedFetches 队列时，是按照 topic-partition 级别去加入，这样也就方便了后续的处理。</li>
</ol>
<p>从这里可以看出，在每次发送 fetch 请求时，都会向所有可发送的 topic-partition 发送 fetch 请求，调用一次 <code>fetcher.sendFetches</code>，拉取到的数据，可能需要多次 pollForFetches 循环才能处理完，因为 Fetcher 线程是在后台运行，这也保证了尽可能少地阻塞用户的处理线程，因为如果 Fetcher 中没有可处理的数据，用户的线程是会阻塞在 poll 方法中的。</p>
<h3 id="fetcher-fetchedRecords"><a href="#fetcher-fetchedRecords" class="headerlink" title="fetcher.fetchedRecords"></a>fetcher.fetchedRecords</h3><p>这个方法的作用就是获取已经从 server 拉取到的 Records，其核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the fetched records, empty the record buffer and update the consumed position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> returning empty records guarantees the consumed position are NOT updated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The fetched records per partition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OffsetOutOfRangeException If there is OffsetOutOfRange error in fetchResponse and</span></span><br><span class="line"><span class="comment"> *         the defaultResetPolicy is NONE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> TopicAuthorizationException If there is TopicAuthorization error in fetchResponse.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetchedRecords() &#123;</span><br><span class="line">    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetched = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 在max.poll.records中设置单词最大的拉取条数，默认500条</span></span><br><span class="line">    <span class="keyword">int</span> recordsRemaining = maxPollRecords;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (recordsRemaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextInLineRecords == <span class="keyword">null</span> || nextInLineRecords.isFetched) &#123;<span class="comment">// nextInLineRecords为空时</span></span><br><span class="line">                <span class="comment">// Step1:当一个nextInLineRecords处理完，就从completedFetches处理下一个完成的Fetch请求</span></span><br><span class="line">                CompletedFetch completedFetch = completedFetches.peek();</span><br><span class="line">                <span class="keyword">if</span> (completedFetch == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Step2:获取下一个要处理的nextInLineRecords</span></span><br><span class="line">                    nextInLineRecords = parseCompletedFetch(completedFetch);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// Remove a completedFetch upon a parse with exception if (1) it contains no records, and</span></span><br><span class="line">                    <span class="comment">// (2) there are no fetched records with actual content preceding this exception.</span></span><br><span class="line">                    <span class="comment">// The first condition ensures that the completedFetches is not stuck with the same completedFetch</span></span><br><span class="line">                    <span class="comment">// in cases such as the TopicAuthorizationException, and the second condition ensures that no</span></span><br><span class="line">                    <span class="comment">// potential data loss due to an exception in a following record.</span></span><br><span class="line">                    FetchResponse.PartitionData partition = completedFetch.partitionData;</span><br><span class="line">                    <span class="keyword">if</span> (fetched.isEmpty() &amp;&amp; (partition.records == <span class="keyword">null</span> || partition.records.sizeInBytes() == <span class="number">0</span>)) &#123;</span><br><span class="line">                        completedFetches.poll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                completedFetches.poll();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Step3:拉取records，更新position</span></span><br><span class="line">                List&lt;ConsumerRecord&lt;K, V&gt;&gt; records = fetchRecords(nextInLineRecords, recordsRemaining);</span><br><span class="line">                TopicPartition partition = nextInLineRecords.partition;</span><br><span class="line">                <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                    List&lt;ConsumerRecord&lt;K, V&gt;&gt; currentRecords = fetched.get(partition);</span><br><span class="line">                    <span class="keyword">if</span> (currentRecords == <span class="keyword">null</span>) &#123;<span class="comment">// 正常情况下，一个node只会发送一个request，一般只会有一个</span></span><br><span class="line">                        fetched.put(partition, records);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// this case shouldn&#x27;t usually happen because we only send one fetch at a time per partition,</span></span><br><span class="line">                        <span class="comment">// but it might conceivably happen in some rare cases (such as partition leader changes).</span></span><br><span class="line">                        <span class="comment">// we have to copy to a new list because the old one may be immutable</span></span><br><span class="line">                        List&lt;ConsumerRecord&lt;K, V&gt;&gt; newRecords = <span class="keyword">new</span> ArrayList&lt;&gt;(records.size() + currentRecords.size());</span><br><span class="line">                        newRecords.addAll(currentRecords);</span><br><span class="line">                        newRecords.addAll(records);</span><br><span class="line">                        fetched.put(partition, newRecords);</span><br><span class="line">                    &#125;</span><br><span class="line">                    recordsRemaining -= records.size();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fetched.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step4:返回相应的Records数据</span></span><br><span class="line">    <span class="keyword">return</span> fetched;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; fetchRecords(PartitionRecords partitionRecords, <span class="keyword">int</span> maxRecords) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptions.isAssigned(partitionRecords.partition)) &#123;</span><br><span class="line">        <span class="comment">// this can happen when a rebalance happened before fetched records are returned to the consumer&#x27;s poll call</span></span><br><span class="line">        log.debug(<span class="string">&quot;Not returning fetched records for partition &#123;&#125; since it is no longer assigned&quot;</span>,</span><br><span class="line">                partitionRecords.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!subscriptions.isFetchable(partitionRecords.partition)) &#123;</span><br><span class="line">        <span class="comment">// this can happen when a partition is paused before fetched records are returned to the consumer&#x27;s</span></span><br><span class="line">        <span class="comment">// poll call or if the offset is being reset</span></span><br><span class="line">        <span class="comment">// 这个topic-partition不能被消费了，比如调用了pause</span></span><br><span class="line">        log.debug(<span class="string">&quot;Not returning fetched records for assigned partition &#123;&#125; since it is no longer fetchable&quot;</span>,</span><br><span class="line">                partitionRecords.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SubscriptionState.FetchPosition position = subscriptions.position(partitionRecords.partition);</span><br><span class="line">        <span class="keyword">if</span> (partitionRecords.nextFetchOffset == position.offset) &#123;<span class="comment">// offset对的上，也就是拉取是按顺序拉的</span></span><br><span class="line">            <span class="comment">// 获取该topic-partition对应的records，并更新partitionRecords的fetchOffset(用于判断是否顺序)</span></span><br><span class="line">            List&lt;ConsumerRecord&lt;K, V&gt;&gt; partRecords = partitionRecords.fetchRecords(maxRecords);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partitionRecords.nextFetchOffset &gt; position.offset) &#123;</span><br><span class="line">                SubscriptionState.FetchPosition nextPosition = <span class="keyword">new</span> SubscriptionState.FetchPosition(</span><br><span class="line">                        partitionRecords.nextFetchOffset,</span><br><span class="line">                        partitionRecords.lastEpoch,</span><br><span class="line">                        position.currentLeader);</span><br><span class="line">                log.trace(<span class="string">&quot;Returning fetched records at offset &#123;&#125; for assigned partition &#123;&#125; and update &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;position to &#123;&#125;&quot;</span>, position, partitionRecords.partition, nextPosition);</span><br><span class="line">                <span class="comment">// 更新消费到的offset(the fetch position)</span></span><br><span class="line">                subscriptions.position(partitionRecords.partition, nextPosition);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取Lag(即position与hw之间差值)，hw为null时，才返回null</span></span><br><span class="line">            Long partitionLag = subscriptions.partitionLag(partitionRecords.partition, isolationLevel);</span><br><span class="line">            <span class="keyword">if</span> (partitionLag != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.sensors.recordPartitionLag(partitionRecords.partition, partitionLag);</span><br><span class="line"></span><br><span class="line">            Long lead = subscriptions.partitionLead(partitionRecords.partition);</span><br><span class="line">            <span class="keyword">if</span> (lead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.sensors.recordPartitionLead(partitionRecords.partition, lead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> partRecords;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// these records aren&#x27;t next in line based on the last consumed position, ignore them</span></span><br><span class="line">            <span class="comment">// they must be from an obsolete request</span></span><br><span class="line">            log.debug(<span class="string">&quot;Ignoring fetched records for &#123;&#125; at offset &#123;&#125; since the current position is &#123;&#125;&quot;</span>,</span><br><span class="line">                    partitionRecords.partition, partitionRecords.nextFetchOffset, position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    partitionRecords.drain();</span><br><span class="line">    <span class="keyword">return</span> emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer 的 Fetcher 处理从 server 获取的 fetch response 大致分为以下几个过程：</p>
<ol>
<li>通过 <code>completedFetches.peek()</code> 获取已经成功的 fetch response (在 <code>fetcher.sendFetches ()</code> 方法中会把发送FetchRequest请求成功后的结果放在这个集合中，是拆分为 topic-partition 的粒度放进去的)；</li>
<li><code>parseCompletedFetch()</code> 处理上面获取的 completedFetch，构造成 PartitionRecords 类型；</li>
<li>通过 <code>fetchRecords()</code> 方法处理 PartitionRecords 对象，在这个里面会去验证 fetchOffset 是否能对得上，只有 fetchOffset 是一致的情况下才会去处理相应的数据，并更新 the fetch offset 的信息，如果 fetchOffset 不一致，这里就不会处理，the fetch offset 就不会更新，下次 fetch 请求时是会接着 the fetch offset 的位置去请求相应的数据；</li>
<li>返回相应的 Records 数据。</li>
</ol>
<p>至此，KafkaConsumer 如何拉取消息的整体流程也分析完毕。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="http://generalthink.github.io/2019/05/31/kafka-consumer-offset/">http://generalthink.github.io/2019/05/31/kafka-consumer-offset/</a></p>
<p><a target="_blank" rel="noopener" href="https://matt33.com/2017/11/11/consumer-pollonce/">https://matt33.com/2017/11/11/consumer-pollonce/</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/10/ouyangxiu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/10/ouyangxiu/" class="post-title-link" itemprop="url">欧阳修</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-10 08:51:06" itemprop="dateCreated datePublished" datetime="2020-11-10T08:51:06+08:00">2020-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-23 16:48:11" itemprop="dateModified" datetime="2020-11-23T16:48:11+08:00">2020-11-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="伐树记"><a href="#伐树记" class="headerlink" title="伐树记"></a>伐树记</h2><p>署之东园，久茀不治。修至始辟之，粪瘠溉枯，为蔬圃十数畦，又植花果桐竹凡百本。</p>
<p>春阳既浮，萌者将动。园之守启曰：“园有樗焉，其根壮而叶大。根壮则梗地脉，耗阳气，而新植者不得滋；叶大则阴翳蒙碍，而新植者不得畅以茂。又其材拳曲臃肿，疏轻而不坚，不足养，是宜伐。”因尽薪之。明日，圃之守又曰：“圃之南有杏焉，凡其根庇之广可六七尺，其下之地最壤腴，以杏故，特不得蔬，是亦宜薪。”修曰：“噫！今杏方春且华，将待其实，若独不能损数畦之广为杏地邪？“因勿伐。</p>
<p>既而悟且叹曰：“吁！庄周之说曰：樗、栎以不材终其天年，桂、漆以有用而见伤夭。今樗诚不材矣，然一旦悉翦弃；杏之体最坚密，美泽可用，反见存。岂才不才各遭其时之可否邪？”</p>
<p>他日，客有过修者。仆夫曳薪过堂下，因指而语客以所疑。客曰： “是何怪邪？夫以无用处无用，庄周之贵也。以无用而贼有用，乌能免哉！彼杏之有华实也，以有生之具而庇其根，幸矣。若桂、漆之不能逃乎斤斧者，盖有利之者在死，势不得以生也，与乎杏实异矣。今樗之臃肿不材，而以壮大害物，其见伐，诚宜尔。与夫‘才者死、不才者生’之说，又异矣。凡物幸之与不幸，视其处之而已。”客既去，修善其言而记之。</p>
<h2 id="非非堂记"><a href="#非非堂记" class="headerlink" title="非非堂记"></a>非非堂记</h2><p>权衡之平物，动则轻重差，其于静也，锱铢不失。水之鉴物，动则不能有睹，其于静也，毫发可辨。在乎人，耳司听，目司视，动则乱于聪明，其于静也，闻见必审。处身者不为外物眩晃而动，则其心静，心静则智识明，是是非非，无所施而不中。夫是是近乎谄，非非近乎讪，不幸而过，宁讪无谄。是者，君子之常，是之何加？一以视之，未若非非之为正也。</p>
<p>予居洛之明年，既新厅事，有文纪于壁末。营其西偏作堂，户北向，植丛竹，辟户于其南，纳日月之光。设一几一榻，架书数百卷，朝夕居其中。以其静也，闭目澄心，览今照古，思虑无所不至焉。故其堂以非非为名云。</p>
<h2 id="浪淘沙-·-把酒祝东风"><a href="#浪淘沙-·-把酒祝东风" class="headerlink" title="浪淘沙 · 把酒祝东风"></a>浪淘沙 · 把酒祝东风</h2><p>把酒祝东风，且共从容。垂杨紫陌洛城东。总是当时携手处，游遍芳丛。</p>
<p>聚散苦匆匆，此恨无穷。今年花胜去年红。可惜明年花更好，知与谁同？</p>
<h2 id="玉楼春-·-尊前拟把归期说"><a href="#玉楼春-·-尊前拟把归期说" class="headerlink" title="玉楼春 · 尊前拟把归期说"></a>玉楼春 · 尊前拟把归期说</h2><p>尊前拟把归期说，欲语春容先惨咽。人生自是有情痴，此恨不关风与月。</p>
<p>离歌且莫翻新阕，一曲能教肠寸结。直须看尽洛城花，始共春风容易别。</p>
<h2 id="生查子-·-元夕"><a href="#生查子-·-元夕" class="headerlink" title="生查子 · 元夕"></a>生查子 · 元夕</h2><p>去年元夜时，花市灯如昼。</p>
<p>月上柳梢头，人约黄昏后。</p>
<p>今年元夜时，月与灯依旧。</p>
<p>不见去年人，泪满春衫袖。</p>
<h2 id="读李翱文"><a href="#读李翱文" class="headerlink" title="读李翱文"></a>读李翱文</h2><p>予始读翱《复性书》三篇，曰：此《中庸》之义疏尔。智者诚其性，当读《中庸》；愚者虽读此不晓也，不作可焉。又读《与韩侍郎荐贤书》，以谓翱特穷时愤世无荐己者，故丁宁如此；使其得志，亦未必。然以韩为秦汉间好侠行义之一豪俊，亦善论人者也。最后读《幽怀赋》，然后置书而叹，叹已复读，不自休。恨翱不生于今，不得与之交；又恨予不得生翱时，与翱上下其论也。</p>
<p>凡昔翱一时人，有道而能文者，莫若韩愈。愈尝有赋矣，不过羡二鸟之光荣，叹一饱之无时尔。此其心使光荣而饱，则不复云矣。若翱独不然，其赋曰：“众嚣嚣而杂处兮，咸叹老而嗟卑；视予心之不然兮，虑行道之犹非。”又怪神尧以一旅取天下，后世子孙不能以天下取河北，以为忧。呜呼！使当时君子皆易其叹老嗟卑之心为翱所忧之心，则唐之天下岂有乱与亡哉！</p>
<p>然翱幸不生今时，见今之事，则其忧又甚矣。奈何今之人不忧也？余行天下，见人多矣，脱有一人能如翱忧者，又皆贱远，与翱无异；其余光荣而饱者，一闻忧世之言，不以为狂人，则以为病痴子，不怒则笑之矣。呜呼，在位而不肯自忧，又禁他人使皆不得忧，可叹也夫!</p>
<p>景祐三年十月十七日，欧阳修书。</p>
<h2 id="答吴充秀才书"><a href="#答吴充秀才书" class="headerlink" title="答吴充秀才书"></a>答吴充秀才书</h2><p>修顿首白，先辈吴君足下。前辱示书及文三篇，发而读之，浩乎若千万言之多，及少定而视焉，才数百言尔。非夫辞丰意雄，沛然有不可御之势，何以至此！然犹自患伥伥莫有开之使前者，此好学之谦言也。</p>
<p>修材不足用于时，仕不足荣于世，其毁誉不足轻重，气力不足动人。世之欲假誉以为重，借力而后进者，奚取于修焉？先辈学精文雄，其施于时，又非待修誉而为重，力而后进者也。然而惠然见临，若有所责，得非急于谋道，不择其人而问焉者欤？</p>
<p>夫学者未始不为道，而至者鲜焉；非道之于人远也，学者有所溺焉尔。盖文之为言，难工而可喜，易悦而自足。世之学者往往溺之，一有工焉，则曰：“吾学足矣。“甚者至弃百事不关于心，曰：“吾文士也，职于文而已。”此其所以至之鲜也。</p>
<p>昔孔子老而归鲁，六经之作，数年之顷尔。然读《易》者如无《春秋》，读《书》者如无《诗》，何其用功少而至于至也！圣人之文虽不可及，然大抵道胜者，文不难而自至也。故孟子皇皇不暇著书，荀卿盖亦晚而有作。若子云、仲淹，方勉焉以模言语，此道未足而强言者也。后之惑者，徒见前世之文传，以为学者文而已，故愈力愈勤而愈不至。此足下所谓”终日不出于轩序，不能纵横高下皆如意“者，道未足也。若道之充焉，虽行乎天地，入于渊泉，无不之也。</p>
<p>先辈之文浩乎沛然，可谓善矣。而又志于为道，犹自以为未广。若不止焉，孟、荀可至而不难也。修，学道而不至者，然幸不甘于所悦而溺于所止。因吾子之能不自止，又以励修之少进焉。幸甚！幸甚！修白。</p>
<h2 id="答祖择之书"><a href="#答祖择之书" class="headerlink" title="答祖择之书"></a>答祖择之书</h2><p>修启。秀才人至，蒙示书一通，并诗赋杂文两策，谕之曰：“一览以为如何？”某既陋，不足以辱好学者之问；又其少贱而长穷，其素所为未有足称以取信于人。亦尝有人问者，以不足问之愚，而未尝答人之问。足下卒然及之，是以愧惧不知所言。虽然，不远数百里走使者以及门，意厚礼勤，何敢不报。</p>
<p>某闻古之学者必严其师，师严然后道尊，道尊然后笃敬，笃敬然后能自守，能自守然后果于用，果于用然后不畏而不迁。三代之衰，学校废。至两汉，师道尚存，故其学者各守其经以自用。是以汉之政理文章与其当时之事，后世莫及者，其所从来深矣。后世师，法渐坏，而今世无师，则学者不尊严，故自轻其道。轻之则不能至，不至则不能笃信，信不笃则不知所守，守不固则有所畏而物可移。是故学者惟俯仰徇时，以希禄利为急，至于忘本趋末，流而不返。夫以不信不固之心，守不至之学，虽欲果于自用，而莫知其所以用之之道，又况有禄利之诱、刑祸之惧以迁之哉！此足下所谓志古知道之士世所鲜，而未有合者，由此也。</p>
<p>足下所为文，用意甚高，卓然有不顾世俗之心，直欲自到于古人。今世之人用心如足下者有几？是则乡曲之中能为足下之师者谓谁，交游之间能发足下之议论者谓谁？学不师则守不一，议论不博则无所发明而究其深。足下之言高趣远，甚善，然所守未一而议论未精，此其病也。窃惟足下之交游能为足下称才誉美者不少，今皆舍之，远而见及，乃知足下是欲求其不至。此古君子之用心也，是以言之不敢隐。</p>
<p>夫世无师矣，学者当师经，师经必先求其意，意得则心定，心定则道纯，道纯则充于中者实，中充实则发为文者辉光，施于世者果致。三代、两汉之学，不过此也。足下患世未有合者，而不弃其愚，将某以为合，故敢道此。未知足下之意合否？</p>
<h2 id="与荆南乐秀才书"><a href="#与荆南乐秀才书" class="headerlink" title="与荆南乐秀才书"></a>与荆南乐秀才书</h2><p>修顿首白秀才足下。前者舟行往来，屡辱见过。又辱以所业一编，先之启事，及门而贽。田秀才西来，辱书；其后予家奴自府还县，比又辱书。仆有罪之人，人所共弃，而足下见礼如此，何以当之？当之未暇答，宜遂绝，而再辱书；再而未答，益宜绝，而又辱之。何其勤之甚也！如修者，天下穷贱之人尔，安能使足下之切切如是邪？盖足下力学好问，急于自为谋而然也。然蒙索仆所为文字者，此似有所过听也。</p>
<p>仆少从进士举于有司，学为诗赋，以备程试，凡三举而得第。与士君子相识者多，故往往能道仆名字，而又以游从相爱之私，或过称其文字。故使足下闻仆虚名，而欲见其所为者，由此也。</p>
<p>仆少孤贫，贪禄仕以养亲，不暇就师穷经，以学圣人之遗业。而涉猎书史，姑随世俗作所谓时文者，皆穿蠹经传，移此俪彼，以为浮薄，惟恐不悦于时人，非有卓然自立之言如古人者。然有司过采，屡以先多士。及得第已来，自以前所为不足以称有司之举而当长者之知，始大改其为，庶几有立。然言出而罪至，学成而身辱，为彼则获誉，为此则受祸，此明效也。</p>
<p>夫时文虽曰浮巧，然其为功，亦不易也。仆天姿不好而强为之，故比时人之为者尤不工，然已足以取禄仕而窃名誉者，顺时故也。先辈少年志盛，方欲取荣誉于世，则莫若顺时。天圣中，天子下诏书，敕学者去浮华，其后风俗大变。今时之士大夫所为，彬彬有两汉之风矣。先辈往学之，非徒足以顺时取誉而已，如其至之，是直齐肩于两汉之士也。若仆者，其前所为既不足学，其后所为慎不可学，是以徘徊不敢出其所为者，为此也。</p>
<p>在《易》之《困》曰：“有言不信。”谓夫人方困时，其言不为人所信也。今可谓困矣，安足为足下所取信哉？辱书既多且切，不敢不答。幸察。</p>
<h2 id="答李诩第一书"><a href="#答李诩第一书" class="headerlink" title="答李诩第一书"></a>答李诩第一书</h2><p>修白。人至，辱书及《性诠》三篇，曰以质其果是。夫自信笃者，无所待于人；有质于人者，自疑者也。今吾子自谓“夫子与孟、荀、扬、韩复生，不能夺吾言”，其可谓自信不疑者矣。而返以质于修。使修有过于夫子者，乃可为吾子辩，况修未及孟、荀、扬、韩之一二也。修非知道者，好学而未至者也。世无师久矣，尚赖朋友切磋之益，苟不自满而中止，庶几终身而有成。固常乐与学者论议往来，非敢以益于人，盖求益于人者也。况如吾子之文章论议，岂易得哉？固乐为吾子辩也。苟尚有所疑，敢不尽其所学以告，既吾子自信如是，虽夫子不能夺，使修何所说焉？人还索书，未知所答，惭惕惭惕。修再拜。</p>
<h2 id="答李诩第二书"><a href="#答李诩第二书" class="headerlink" title="答李诩第二书"></a>答李诩第二书</h2><p>修白。前辱示书及《性诠》三篇，见吾子好学善辩，而文能尽其意之详。令世之言性者多矣，有所不及也，故思与吾子卒其说。</p>
<p>修患世之学者多言性，故常为说曰“夫性，非学者之所急，而圣人之所罕言也。《易》六十四卦不言性，其言者动静得失吉凶之常理也；《春秋》二百四十二年不言性，其言者善恶是非之实录也；《诗》三百五篇不言性，其言者政教兴衰之美刺也；《书》五十九篇不言性，其言者尧、舜、三代之治乱也；《礼》、《乐》之书虽不完，而杂出于诸儒之记，然其大要，治国修身之法也。六经之所载，皆人事之切于世者，是以言之甚详。至于性也，百不一二言之，或因言而及焉，非为性而言也，故虽言而不究。</p>
<p>予之所谓不言者，非谓绝而无言，盖其言者鲜，而又不主于性而言也。《论语》所载七十二子之问于孔子者，问孝、问忠、问仁义、问礼乐、问修身、问为政、问朋友、问鬼神者有矣，未尝有问性者。孔子之告其弟子者，凡数千言，其及于性者一言而已。予故曰：非学者之所急，而圣人之罕言也。</p>
<p>《书》曰“习与性成”，《语》曰“性相近，习相远”者，戒人慎所习而言也。《中庸》曰“天命之谓性，率性之谓道”者，明性无常，必有以率之也。《乐记》亦曰“感物而动，性之欲”者，明物之感人无不至也。然终不言性果善果恶，但戒人慎所习与所感，而勤其所以率之者尔。予故曰“因言以及之，而不究也。</p>
<p>修少好学，知学之难。凡所谓六经之所载，七十二子之所问者，学之终身，有不能达者矣；于其所达，行之终身，有不能至者矣。以予之汲汲于此而不暇乎其他，因以知七十二子亦以是汲汲而不暇也，又以知圣人所以教人垂世，亦皇皇而不暇也。今之学者于古圣贤所皇皇汲汲者，学之行之，或未至其一二，而好为性说，以穷圣贤之所罕言而不究者，执后儒之偏说，事无用之空言，此予之所不暇也。</p>
<p>或有问曰：性果不足学乎？予曰：性者，与身俱生而人之所皆有也。为君子者，修身治人而已，性之善恶不必究也。使性果善邪，身不可以不修，人不可以不治；使性果恶邪，身不可以不修，人不可以不治。不修其身，虽君子而为小人，《书》曰“惟圣罔念作狂”是也；能修其身，虽小人而为君子，《书》曰“惟狂克念作圣”是也。治道备，人斯为善矣，《书》曰“黎民于变时雍”是也；治道失，人斯为恶矣，《书》曰“殷顽民”，又曰“旧染污俗”是也。故为君子者，以修身治人为急，而不穷性以为言。夫七十二子之不问，六经之不主言，或虽言而不究，岂略之哉，盖有意也。</p>
<p>或又问曰：然则三子言性，过欤？曰：不过也。其不同何也？曰：始异而终同也。使孟子曰人性善矣，遂怠而不教，则是过也；使荀子曰人性恶矣，遂弃而不教，则是过也；使扬子曰人性混矣，遂肆而不教，则是过也。然三子者，或身奔走诸侯以行其道，或著书累千万言以告于后世，未尝不区区以仁义礼乐为急。盖其意以谓善者一日不教，则失而入于恶；恶者勤而教之，则可使至于善；混者驱而率之，则可使去恶而就善也。其说与《书》之“习与性成”，《语》之“性近习远”，《中庸》之“有以率之”，《乐记》之“慎物所感”皆合。夫三子者，推其言则殊，察其用心则一，故予以为推其言不过始异而终同也。凡论三子者，以予言而一之，则譊譊者可以息矣。</p>
<p>予之所说如此，吾子其择焉。</p>
<h2 id="醉翁亭记"><a href="#醉翁亭记" class="headerlink" title="醉翁亭记"></a>醉翁亭记</h2><p>环滁皆山也。其西南诸峰，林壑尤美，望之蔚然而深秀者，琅琊也。山行六七里，渐闻水声潺潺，而泻出于两峰之间者，酿泉也。峰回路转，有亭翼然临于泉上者，醉翁亭也。作亭者谁？山之僧智仙也。名之者谁？太守自谓也。太守与客来饮于此，饮少辄醉，而年又最高，故自号曰醉翁也。醉翁之意不在酒，在乎山水之间也。山水之乐，得之心而寓之酒也。</p>
<p>若夫日出而林霏开，云归而岩穴暝，晦明变化者，山间之朝暮也。野芳发而幽香，佳木秀而繁阴，风霜高洁，水落而石出者，山间之四时也。朝而往，暮而归，四时之景不同，而乐亦无穷也。</p>
<p>至于负者歌于途，行者休于树，前者呼，后者应，伛偻提携，往来而不绝者，滁人游也。临溪而渔，溪深而鱼肥。酿泉为酒，泉香而酒洌；山肴野蔌，杂然而前陈者，太守宴也。宴酣之乐，非丝非竹，射者中，弈者胜，觥筹交错，起坐而喧哗者，众宾欢也。苍颜白发，颓然乎其间者，太守醉也。</p>
<p>已而夕阳在山，人影散乱，太守归而宾客从也。树林阴翳，鸣声上下，游人去而禽鸟乐也。然而禽鸟知山林之乐，而不知人之乐；人知从太守游而乐，而不知太守之乐其乐也。醉能同其乐，醒能述以文者，太守也。太守谓谁？庐陵欧阳修也。</p>
<h2 id="朝中措-·-送刘仲原甫出守维扬"><a href="#朝中措-·-送刘仲原甫出守维扬" class="headerlink" title="朝中措 · 送刘仲原甫出守维扬"></a>朝中措 · 送刘仲原甫出守维扬</h2><p>平山阑槛倚晴空，山色有无中。手种堂前垂柳，别来几度春风？</p>
<p>文章太守，挥毫万字，一饮千钟。行乐直须年少，尊前看取衰翁。</p>
<h2 id="夜行船-·-忆昔西都欢纵"><a href="#夜行船-·-忆昔西都欢纵" class="headerlink" title="夜行船 · 忆昔西都欢纵"></a>夜行船 · 忆昔西都欢纵</h2><p>忆昔西都欢纵。自别后、有谁能共。伊川山水洛川花，细寻思、旧游如梦。</p>
<p>今日相逢情愈重。愁闻唱、画楼钟动。白发天涯逢此景，倒金尊、殢谁相送。</p>
<h2 id="伶官传序"><a href="#伶官传序" class="headerlink" title="伶官传序"></a>伶官传序</h2><p>呜呼！盛衰之理，虽曰天命，岂非人事哉！原庄宗之所以得天下，与其所以失之者，可以知之矣。</p>
<p>世言晋王之将终也，以三矢赐庄宗而告之曰：“梁，吾仇也；燕王，吾所立，契丹，与吾约为兄弟，而皆背晋以归梁。此三者，吾遗恨也。与尔三矢，尔其无忘乃父之志！”庄宗受而藏之于庙。其后用兵，则遣从事以一少牢告庙，请其矢，盛以锦囊，负而前驱，及凯旋而纳之。</p>
<p>方其系燕父子以组，函梁君臣之首，入于太庙，还矢先王，而告以成功，其意气之盛，可谓壮哉！及仇雠已灭，天下已定，一夫夜呼，乱者四应，仓皇东出，未及见贼而士卒离散，君臣相顾，不知所归。至于誓天断发，泣下沾襟，何其衰也！岂得之难而失之易欤？抑本其成败之迹，而皆自于人欤？</p>
<p>《书》曰：“满招损，谦得益。”忧劳可以兴国，逸豫可以亡身，自然之理也。故方其盛也，举天下之豪杰莫能与之争；及其衰也，数十伶人困之，而身死国灭，为天下笑。夫祸患常积于忽微，而智勇多困于所溺，岂独伶人也哉！作《伶官传》。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/04/kafka-consumer-group/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/04/kafka-consumer-group/" class="post-title-link" itemprop="url">KafkaConsumer 源码之 consumer 如何加入 consumer group</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-04 09:35:04" itemprop="dateCreated datePublished" datetime="2020-11-04T09:35:04+08:00">2020-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-05 15:32:45" itemprop="dateModified" datetime="2021-01-05T15:32:45+08:00">2021-01-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>33 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kafka 的 consumer 比 producer 要复杂许多，producer 没有 group 的概念，也不需要关注 offset，而 consumer 不一样，它有组织 (consumer group)，有纪律 (offset)。这些对 consumer 的要求就会很高，这篇文章就主要介绍 consumer 是如何加入 consumer group 的。</p>
<p>在这之前，我们需要先了解一下什么是 GroupCoordinator。简单地说，<strong>GroupCoordinator 是运行在服务器上的一个服务，Kafka 集群上的每一个 broker 节点启动的时候，都会启动一个 GroupCoordinator 服务，其功能是负责进行 consumer 的 group 成员与 offset 管理 (但每个 GroupCoordinator 只是管理一部分的 consumer group member 和 offset 信息)。</strong></p>
<p>consumer group 对应的 GroupCoordinator 节点的确定，会通过如下方式：</p>
<p>将 consumer group 的 <code>group.id</code> 进行 hash，把得到的值的绝对值，对 _consumer_offsets 的 partition 总数取余，然后得到其对应的 partition 值，该 partition 的 leader 所在的 broker 即为该 consumer group 所对应的 GroupCoordinator 节点，GroupCoordinator 会存储与该 consumer group 相关的所有的 Meta 信息。</p>
<blockquote>
<p>1._consumer_offsets 这个 topic 是 Kafka 内部使用的一个 topic，专门用来存储 group 消费的情况，默认情况下有 50 个 partition，每个 partition 默认有三个副本。</p>
<p>2.partition 计算方式：<code>abs(GroupId.hashCode()) % NumPartitions</code>，其中，NumPartitions 是 _consumer_offsets 的 partition 数，默认是 50 个。</p>
<p>3.比如，现在通过计算 <code>abs(GroupId.hashCode()) % NumPartitions</code> 的值为 35，然后就找第 35 个 partition 的 leader 在哪个 broker 上 (假设在 192.168.1.12)，那么 GroupCoordinator 节点就在这个 broker 上。</p>
</blockquote>
<p><strong>同时，这个 consumer group 所提交的消费 offset 信息也会发送给这个 partition 的 leader 所对应的 broker 节点，因此，这个节点不仅是 GroupCoordinator，而且还保存分区分配方案和组内消费者 offset 信息。</strong></p>
<p>更多关于 GroupCoordinator 的解析，参考：<a target="_blank" rel="noopener" href="https://matt33.com/2018/01/28/server-group-coordinator/">Kafka 源码解析之 GroupCoordinator 详解</a>。</p>
<h2 id="KafkaConsumer-消费消息的主体流程"><a href="#KafkaConsumer-消费消息的主体流程" class="headerlink" title="KafkaConsumer 消费消息的主体流程"></a>KafkaConsumer 消费消息的主体流程</h2><p>接下来，我们回顾下 KafkaConsumer 消费消息的主体流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line">KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅主题</span></span><br><span class="line">kafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;consumerCodeTopic&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务器拉取数据</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<h3 id="创建-KafkaConsumer"><a href="#创建-KafkaConsumer" class="headerlink" title="创建 KafkaConsumer"></a>创建 KafkaConsumer</h3><p>创建 KafkaConsumer 的时候，会创建一个 ConsumerCoordinator 服务，由它来负责和 GroupCoordinator 通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no coordinator will be constructed for the default (null) group id</span></span><br><span class="line"><span class="keyword">this</span>.coordinator = groupId == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">	<span class="keyword">new</span> ConsumerCoordinator(logContext,</span><br><span class="line">                        <span class="keyword">this</span>.client,</span><br><span class="line">                        groupId,</span><br><span class="line">                        <span class="keyword">this</span>.groupInstanceId,</span><br><span class="line">                        maxPollIntervalMs,</span><br><span class="line">                        sessionTimeoutMs,</span><br><span class="line">                        <span class="keyword">new</span> Heartbeat(time, sessionTimeoutMs, heartbeatIntervalMs, maxPollIntervalMs, retryBackoffMs),</span><br><span class="line">                        assignors,</span><br><span class="line">                        <span class="keyword">this</span>.metadata,</span><br><span class="line">                        <span class="keyword">this</span>.subscriptions,</span><br><span class="line">                        metrics,</span><br><span class="line">                        metricGrpPrefix,</span><br><span class="line">                        <span class="keyword">this</span>.time,</span><br><span class="line">                        retryBackoffMs,</span><br><span class="line">                        enableAutoCommit,</span><br><span class="line">                        config.getInt(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG),</span><br><span class="line">                        <span class="keyword">this</span>.interceptors,</span><br><span class="line">                        config.getBoolean(ConsumerConfig.LEAVE_GROUP_ON_CLOSE_CONFIG));</span><br></pre></td></tr></table></figure>

<h3 id="订阅-topic"><a href="#订阅-topic" class="headerlink" title="订阅 topic"></a>订阅 topic</h3><p>KafkaConsumer 订阅 topic 的方式有好几种，这在<a target="_blank" rel="noopener" href="https://acatsmiling.github.io/2020/10/29/kafka-consumer/">前面的文章</a>有提到过。订阅的时候，会根据订阅的方式，设置其对应的订阅类型，默认存在四种订阅类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">SubscriptionType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认</span></span><br><span class="line">    NONE,</span><br><span class="line">    <span class="comment">// subscribe方式订阅</span></span><br><span class="line">    AUTO_TOPICS,</span><br><span class="line">    <span class="comment">// subscribe方式订阅</span></span><br><span class="line">    AUTO_PATTERN,</span><br><span class="line">    <span class="comment">// assign方式订阅</span></span><br><span class="line">    USER_ASSIGNED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，采用 <code>kafkaConsumer.subscribe(Collections.singletonList(&quot;consumerCodeTopic&quot;))</code> 方式订阅 topic 时，会将订阅类型设置为 <code>SubscriptionType.AUTO_TOPICS</code>，其核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscribe to the given list of topics to get dynamically assigned partitions.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;Topic subscriptions are not incremental. This list will replace the current</span></span><br><span class="line"><span class="comment"> * assignment (if there is one).&lt;/b&gt; It is not possible to combine topic subscription with group management</span></span><br><span class="line"><span class="comment"> * with manual partition assignment through &#123;<span class="doctag">@link</span> #assign(Collection)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the given list of topics is empty, it is treated the same as &#123;<span class="doctag">@link</span> #unsubscribe()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This is a short-hand for &#123;<span class="doctag">@link</span> #subscribe(Collection, ConsumerRebalanceListener)&#125;, which</span></span><br><span class="line"><span class="comment"> * uses a no-op listener. If you need the ability to seek to particular offsets, you should prefer</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #subscribe(Collection, ConsumerRebalanceListener)&#125;, since group rebalances will cause partition offsets</span></span><br><span class="line"><span class="comment"> * to be reset. You should also provide your own listener if you are doing your own offset</span></span><br><span class="line"><span class="comment"> * management since the listener gives you an opportunity to commit offsets before a rebalance finishes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topics The list of topics to subscribe to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException If topics is null or contains null or empty elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If &#123;<span class="doctag">@code</span> subscribe()&#125; is called previously with pattern, or assign is called</span></span><br><span class="line"><span class="comment"> *                               previously (without a subsequent call to &#123;<span class="doctag">@link</span> #unsubscribe()&#125;), or if not</span></span><br><span class="line"><span class="comment"> *                               configured at-least one partition assignment strategy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics)</span> </span>&#123;</span><br><span class="line">    subscribe(topics, <span class="keyword">new</span> NoOpConsumerRebalanceListener());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscribe to the given list of topics to get dynamically</span></span><br><span class="line"><span class="comment"> * assigned partitions. &lt;b&gt;Topic subscriptions are not incremental. This list will replace the current</span></span><br><span class="line"><span class="comment"> * assignment (if there is one).&lt;/b&gt; Note that it is not possible to combine topic subscription with group management</span></span><br><span class="line"><span class="comment"> * with manual partition assignment through &#123;<span class="doctag">@link</span> #assign(Collection)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the given list of topics is empty, it is treated the same as &#123;<span class="doctag">@link</span> #unsubscribe()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * As part of group management, the consumer will keep track of the list of consumers that belong to a particular</span></span><br><span class="line"><span class="comment"> * group and will trigger a rebalance operation if any one of the following events are triggered:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Number of partitions change for any of the subscribed topics</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;A subscribed topic is created or deleted</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;An existing member of the consumer group is shutdown or fails</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;A new member is added to the consumer group</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When any of these events are triggered, the provided listener will be invoked first to indicate that</span></span><br><span class="line"><span class="comment"> * the consumer&#x27;s assignment has been revoked, and then again when the new assignment has been received.</span></span><br><span class="line"><span class="comment"> * Note that rebalances will only occur during an active call to &#123;<span class="doctag">@link</span> #poll(Duration)&#125;, so callbacks will</span></span><br><span class="line"><span class="comment"> * also only be invoked during that time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The provided listener will immediately override any listener set in a previous call to subscribe.</span></span><br><span class="line"><span class="comment"> * It is guaranteed, however, that the partitions revoked/assigned through this interface are from topics</span></span><br><span class="line"><span class="comment"> * subscribed in this call. See &#123;<span class="doctag">@link</span> ConsumerRebalanceListener&#125; for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topics The list of topics to subscribe to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener Non-null listener instance to get notifications on partition assignment/revocation for the</span></span><br><span class="line"><span class="comment"> *                 subscribed topics</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException If topics is null or contains null or empty elements, or if listener is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If &#123;<span class="doctag">@code</span> subscribe()&#125; is called previously with pattern, or assign is called</span></span><br><span class="line"><span class="comment"> *                               previously (without a subsequent call to &#123;<span class="doctag">@link</span> #unsubscribe()&#125;), or if not</span></span><br><span class="line"><span class="comment"> *                               configured at-least one partition assignment strategy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        maybeThrowInvalidGroupIdException();</span><br><span class="line">        <span class="keyword">if</span> (topics == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic collection to subscribe to cannot be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (topics.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// treat subscribing to empty topic list as the same as unsubscribing</span></span><br><span class="line">            <span class="keyword">this</span>.unsubscribe();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String topic : topics) &#123;</span><br><span class="line">                <span class="keyword">if</span> (topic == <span class="keyword">null</span> || topic.trim().isEmpty())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic collection to subscribe to cannot contain null or empty topic&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throwIfNoAssignorsConfigured();</span><br><span class="line">            fetcher.clearBufferedDataForUnassignedTopics(topics);</span><br><span class="line">            log.info(<span class="string">&quot;Subscribed to topic(s): &#123;&#125;&quot;</span>, Utils.join(topics, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.subscribe(<span class="keyword">new</span> HashSet&lt;&gt;(topics), listener))</span><br><span class="line">                metadata.requestUpdateForNewTopics();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">subscribe</span><span class="params">(Set&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    registerRebalanceListener(listener);</span><br><span class="line">    setSubscriptionType(SubscriptionType.AUTO_TOPICS);</span><br><span class="line">    <span class="keyword">return</span> changeSubscription(topics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method sets the subscription type if it is not already set (i.e. when it is NONE),</span></span><br><span class="line"><span class="comment"> * or verifies that the subscription type is equal to the give type when it is set (i.e.</span></span><br><span class="line"><span class="comment"> * when it is not NONE)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type The given subscription type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSubscriptionType</span><span class="params">(SubscriptionType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptionType == SubscriptionType.NONE)</span><br><span class="line">        <span class="keyword">this</span>.subscriptionType = type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptionType != type)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(SUBSCRIPTION_EXCEPTION_MESSAGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从服务器拉取数据"><a href="#从服务器拉取数据" class="headerlink" title="从服务器拉取数据"></a>从服务器拉取数据</h3><p>订阅完成后，就可以从服务器拉取数据了，应该注意的是，KafkaConsumer 没有后台线程默默的拉取数据，它的所有行为都集中在 <code>poll ()</code> 方法中，<strong>KafkaConsumer 是线程不安全的，同时只能允许一个线程运行。</strong></p>
<p><code>kafkaConsumer.poll ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Step1:确认KafkaConsumer实例是单线程运行，以及没有被关闭</span></span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Consumer is not subscribed to any topics or assigned any partitions&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="comment">// Step2:更新metadata信息，获取GroupCoordinator的ip以及接口，并连接、 join-group、sync-group，期间group会进行rebalance。在此步骤，consumer会先加入group，然后获取需要消费的topic partition的offset信息</span></span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;Still waiting for metadata&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step3:拉取数据</span></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);</span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// before returning the fetched records, we can send off the next round of fetches</span></span><br><span class="line">                <span class="comment">// and avoid block waiting for their responses to enable pipelining while the user</span></span><br><span class="line">                <span class="comment">// is handling the fetched records.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> since the consumed position has already been updated, we must not allow</span></span><br><span class="line">                <span class="comment">// wakeups or any other errors to be triggered prior to returning the fetched records.</span></span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.pollNoWakeup();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在 Step 1 阶段， <code>poll ()</code> 方法会先进行判定，如果有多个线程同时使用一个 KafkaConsumer 则会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire the light lock and ensure that the consumer hasn&#x27;t been closed.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If the consumer has been closed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireAndEnsureOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">        release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This consumer has already been closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire the light lock protecting this consumer from multi-threaded access. Instead of blocking</span></span><br><span class="line"><span class="comment"> * when the lock is not available, however, we just throw an exception (since multi-threaded usage is not</span></span><br><span class="line"><span class="comment"> * supported).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ConcurrentModificationException if another thread already has the lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    <span class="keyword">if</span> (threadId != currentThread.get() &amp;&amp; !currentThread.compareAndSet(NO_CURRENT_THREAD, threadId))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException(<span class="string">&quot;KafkaConsumer is not safe for multi-threaded access&quot;</span>);</span><br><span class="line">    refcount.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KafkaConsumer-如何加入-consumer-group"><a href="#KafkaConsumer-如何加入-consumer-group" class="headerlink" title="KafkaConsumer 如何加入 consumer group"></a>KafkaConsumer 如何加入 consumer group</h2><p><strong>一个 KafkaConsumer 实例消费数据的前提是能够加入一个 consumer group 成功，并获取其要订阅的 tp（topic-partition）列表，因此首先要做的就是和 GroupCoordinator 建立连接，加入组织。</strong></p>
<blockquote>
<p>consumer 加入 group 的过程，也就是 reblance 的过程。如果出现了频繁 reblance 的问题，可能和 <code>max.poll.interval.ms</code> 和 <code>max.poll.records</code> 两个参数有关。</p>
</blockquote>
<p>因此，我们先把目光集中在 ConsumerCoordinator 上，这个过程主要发生在 Step 2 阶段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Visible for testing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.本篇文章的内容主要集中在coordinator.poll(timer)方法源码分析(主要功能是:consumer加入group)</span></span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.poll(timer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.updateFetchPositions(timer)方法留待下一篇文章分析(主要功能是:consumer获得partition的offset)</span></span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于对 ConsumerCoordinator 的处理都集中在 <code>coordinator.poll ()</code> 方法中。其主要逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Poll for coordinator events. This ensures that the coordinator is known and that the consumer</span></span><br><span class="line"><span class="comment"> * has joined the group (if it is using group management). This also handles periodic offset commits</span></span><br><span class="line"><span class="comment"> * if they are enabled.</span></span><br><span class="line"><span class="comment"> * (确保group的coordinator是已知的，并且这个consumer是已经加入到了group中，也用于offset周期性的commit)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Returns early if the timeout expires</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true iff the operation succeeded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(Timer timer)</span> </span>&#123;</span><br><span class="line">    maybeUpdateSubscriptionMetadata();</span><br><span class="line"></span><br><span class="line">    invokeCompletedOffsetCommitCallbacks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是subscribe方式订阅的topic</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;</span><br><span class="line">        <span class="comment">// Always update the heartbeat last poll time so that the heartbeat thread does not leave the</span></span><br><span class="line">        <span class="comment">// group proactively due to application inactivity even if (say) the coordinator cannot be found.</span></span><br><span class="line">        <span class="comment">// 1.检查心跳线程运行是否正常，如果心跳线程失败则抛出异常，反之则更新poll调用的时间</span></span><br><span class="line">        pollHeartbeat(timer.currentTimeMs());</span><br><span class="line">        <span class="comment">// 2.如果coordinator未知，则初始化ConsumeCoordinator</span></span><br><span class="line">        <span class="keyword">if</span> (coordinatorUnknown() &amp;&amp; !ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要重新加入group，如果订阅的partition变化或者分配的partition变化，都可能需要重新加入group</span></span><br><span class="line">        <span class="keyword">if</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">            <span class="comment">// due to a race condition between the initial metadata fetch and the initial rebalance,</span></span><br><span class="line">            <span class="comment">// we need to ensure that the metadata is fresh before joining initially. This ensures</span></span><br><span class="line">            <span class="comment">// that we have matched the pattern against the cluster&#x27;s topics at least once before joining.</span></span><br><span class="line">            <span class="keyword">if</span> (subscriptions.hasPatternSubscription()) &#123;</span><br><span class="line">                <span class="comment">// For consumer group that uses pattern-based subscription, after a topic is created,</span></span><br><span class="line">                <span class="comment">// any consumer that discovers the topic after metadata refresh can trigger rebalance</span></span><br><span class="line">                <span class="comment">// across the entire consumer group. Multiple rebalances can be triggered after one topic</span></span><br><span class="line">                <span class="comment">// creation if consumers refresh metadata at vastly different times. We can significantly</span></span><br><span class="line">                <span class="comment">// reduce the number of rebalances caused by single topic creation by asking consumer to</span></span><br><span class="line">                <span class="comment">// refresh metadata before re-joining the group as long as the refresh backoff time has</span></span><br><span class="line">                <span class="comment">// passed.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.metadata.timeToAllowUpdate(timer.currentTimeMs()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!client.ensureFreshMetadata(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                maybeUpdateSubscriptionMetadata();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.确保group是active的，重新加入group，分配订阅的partition</span></span><br><span class="line">            <span class="keyword">if</span> (!ensureActiveGroup(timer)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For manually assigned partitions, if there are no ready nodes, await metadata.</span></span><br><span class="line">        <span class="comment">// If connections to all nodes fail, wakeups triggered while attempting to send fetch</span></span><br><span class="line">        <span class="comment">// requests result in polls returning immediately, causing a tight loop of polls. Without</span></span><br><span class="line">        <span class="comment">// the wakeup, poll() with no channels would block for the timeout, delaying re-connection.</span></span><br><span class="line">        <span class="comment">// awaitMetadataUpdate() initiates new connections with configured backoff and avoids the busy loop.</span></span><br><span class="line">        <span class="comment">// When group management is used, metadata wait is already performed for this scenario as</span></span><br><span class="line">        <span class="comment">// coordinator is unknown, hence this check is not required.</span></span><br><span class="line">        <span class="keyword">if</span> (metadata.updateRequested() &amp;&amp; !client.hasReadyNodes(timer.currentTimeMs())) &#123;</span><br><span class="line">            client.awaitMetadataUpdate(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.如果设置的是自动commit,如果定时达到则自动commit</span></span><br><span class="line">    maybeAutoCommitOffsetsAsync(timer.currentTimeMs());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>coordinator.poll ()</code> 方法中，具体实现可以分为四个步骤：</p>
<ol>
<li><code>pollHeartbeat ()</code>：检测心跳线程运行是否正常，需要定时向 GroupCoordinator 发送心跳，如果超时未发送心跳，consumer 会离开 consumer group。</li>
<li><code>ensureCoordinatorReady ()</code>：当通过 <code>subscribe ()</code> 方法订阅 topic 时，如果 coordinator 未知，则初始化 ConsumerCoordinator (在 <code>ensureCoordinatorReady ()</code> 中实现，该方法主要的作用是发送 FindCoordinatorRequest 请求，并建立连接)。</li>
<li><code>ensureActiveGroup ()</code>：判断是否需要重新加入 group，如果订阅的 partition 变化或者分配的 partition 变化时，需要 rejoin，则通过 <code>ensureActiveGroup ()</code> 发送 join-group、sync-group 请求，加入 group 并获取其 assign 的 TopicPartition list。</li>
<li><code>maybeAutoCommitOffsetsAsync ()</code>：如果设置的是自动 commit，并且达到了发送时限则自动 commit offset。</li>
</ol>
<p>关于 rejoin，<strong>下列几种情况会触发再均衡 (reblance) 操作</strong>：</p>
<ul>
<li><p>订阅的 topic 列表变化</p>
</li>
<li><p>topic 被创建或删除</p>
</li>
<li><p>新的消费者加入消费者组 (第一次进行消费也属于这种情况)</p>
</li>
<li><p>消费者宕机下线 (长时间未发送心跳包)</p>
</li>
<li><p>消费者主动退出消费组，比如调用 <code>unsubscrible ()</code> 方法取消对主题的订阅</p>
</li>
<li><p>消费者组对应的 GroupCoorinator 节点发生了变化</p>
</li>
<li><p>消费者组内所订阅的任一主题或者主题的分区数量发生了变化</p>
</li>
</ul>
<blockquote>
<p>取消  topic 订阅，consumer 心跳线程超时以及在  Server 端给定的时间内未收到心跳请求，这三个都是触发的  LEAVE_GROUP 请求。</p>
</blockquote>
<p>下面重点介绍下第二步中的 <code>ensureCoordinatorReady ()</code> 方法和第三步中的 <code>ensureActiveGroup ()</code> 方法。</p>
<h3 id="ensureCoordinatorReady"><a href="#ensureCoordinatorReady" class="headerlink" title="ensureCoordinatorReady"></a>ensureCoordinatorReady</h3><p><code>ensureCoordinatorReady ()</code>这个方法主要作用：<strong>选择一个连接数最少的 broker (还未响应请求最少的 broker)，发送 FindCoordinator 请求，找到 GroupCoordinator 后，建立对应的 TCP 连接。</strong></p>
<ul>
<li>方法调用流程是 <code>ensureCoordinatorReady ()</code> → <code>lookupCoordinator ()</code> → <code>sendFindCoordinatorRequest ()</code>。</li>
<li>如果 client 收到 server response，那么就与 GroupCoordinator 建立连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Visible for testing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Ensure that the coordinator is ready to receive requests.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true If coordinator discovery and initial connection succeeded, false otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ensureCoordinatorReady</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!coordinatorUnknown())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 找到GroupCoordinator，并建立连接</span></span><br><span class="line">        <span class="keyword">final</span> RequestFuture&lt;Void&gt; future = lookupCoordinator();</span><br><span class="line">        client.poll(future, timer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            <span class="comment">// ran out of time</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (future.failed()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isRetriable()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Coordinator discovery failed, refreshing metadata&quot;</span>);</span><br><span class="line">                client.awaitMetadataUpdate(timer);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> future.exception();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; client.isUnavailable(coordinator)) &#123;</span><br><span class="line">            <span class="comment">// we found the coordinator, but the connection has failed, so mark</span></span><br><span class="line">            <span class="comment">// it dead and backoff before retrying discovery</span></span><br><span class="line">            markCoordinatorUnknown();</span><br><span class="line">            timer.sleep(retryBackoffMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (coordinatorUnknown() &amp;&amp; timer.notExpired());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !coordinatorUnknown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> RequestFuture&lt;Void&gt; <span class="title">lookupCoordinator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (findCoordinatorFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// find a node to ask about the coordinator(找一个最少连接的broker，此处对应的应该就是文章开头处确定GroupCoordinator节点的发发)</span></span><br><span class="line">        Node node = <span class="keyword">this</span>.client.leastLoadedNode();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;No broker available to send FindCoordinator request&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> RequestFuture.noBrokersAvailable();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 对找到的broker发送FindCoordinator请求，并对response进行处理</span></span><br><span class="line">            findCoordinatorFuture = sendFindCoordinatorRequest(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCoordinatorFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Discover the current coordinator for the group. Sends a GroupMetadata request to</span></span><br><span class="line"><span class="comment"> * one of the brokers. The returned future should be polled to get the result of the request.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A request future which indicates the completion of the metadata request</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;Void&gt; <span class="title">sendFindCoordinatorRequest</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initiate the group metadata request</span></span><br><span class="line">    log.debug(<span class="string">&quot;Sending FindCoordinator request to broker &#123;&#125;&quot;</span>, node);</span><br><span class="line">    FindCoordinatorRequest.Builder requestBuilder =</span><br><span class="line">            <span class="keyword">new</span> FindCoordinatorRequest.Builder(</span><br><span class="line">                    <span class="keyword">new</span> FindCoordinatorRequestData()</span><br><span class="line">                        .setKeyType(CoordinatorType.GROUP.id())</span><br><span class="line">                        .setKey(<span class="keyword">this</span>.groupId));</span><br><span class="line">    <span class="comment">// 发送请求，并将response转换为RequestFuture</span></span><br><span class="line">    <span class="comment">// compose的作用是将FindCoordinatorResponseHandler类转换为RequestFuture</span></span><br><span class="line">    <span class="comment">// 实际上就是为返回的Future类重置onSuccess()和onFailure()方法</span></span><br><span class="line">    <span class="keyword">return</span> client.send(node, requestBuilder)</span><br><span class="line">            .compose(<span class="keyword">new</span> FindCoordinatorResponseHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据response返回的ip以及端口信息，和该broke上开启的GroupCoordinator建立连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FindCoordinatorResponseHandler</span> <span class="keyword">extends</span> <span class="title">RequestFutureAdapter</span>&lt;<span class="title">ClientResponse</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Received FindCoordinator response &#123;&#125;&quot;</span>, resp);</span><br><span class="line">        clearFindCoordinatorFuture();</span><br><span class="line"></span><br><span class="line">        FindCoordinatorResponse findCoordinatorResponse = (FindCoordinatorResponse) resp.responseBody();</span><br><span class="line">        Errors error = findCoordinatorResponse.error();</span><br><span class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">            <span class="comment">// 如果正确获取broker上的GroupCoordinator，建立连接，并更新心跳时间</span></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// use MAX_VALUE - node.id as the coordinator id to allow separate connections</span></span><br><span class="line">                <span class="comment">// for the coordinator in the underlying network client layer</span></span><br><span class="line">                <span class="keyword">int</span> coordinatorConnectionId = Integer.MAX_VALUE - findCoordinatorResponse.data().nodeId();</span><br><span class="line"></span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.coordinator = <span class="keyword">new</span> Node(</span><br><span class="line">                        coordinatorConnectionId,</span><br><span class="line">                        findCoordinatorResponse.data().host(),</span><br><span class="line">                        findCoordinatorResponse.data().port());</span><br><span class="line">                log.info(<span class="string">&quot;Discovered group coordinator &#123;&#125;&quot;</span>, coordinator);</span><br><span class="line">                <span class="comment">// 初始化tcp连接</span></span><br><span class="line">                client.tryConnect(coordinator);</span><br><span class="line">                <span class="comment">// 更新心跳时间</span></span><br><span class="line">                heartbeat.resetSessionTimeout();</span><br><span class="line">            &#125;</span><br><span class="line">            future.complete(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</span><br><span class="line">            future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Group coordinator lookup failed: &#123;&#125;&quot;</span>, findCoordinatorResponse.data().errorMessage());</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</span><br><span class="line">        clearFindCoordinatorFuture();</span><br><span class="line">        <span class="keyword">super</span>.onFailure(e, future);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码主要作用就是：往一个负载最小的 broker 节点发起 FindCoordinator 请求，Kafka 在走到这个请求后会根据 group_id 查找对应的 GroupCoordinator 节点 (文章开头处介绍的方法)，如果找到对应的 GroupCoordinator 则会返回其对应的 node_id，host 和 port 信息，并建立连接。</p>
<blockquote>
<p>这里的 GroupCoordinator 节点的确定在文章开头提到过，是通过 <code>group.id</code> 和 partitionCount 来确定的。</p>
</blockquote>
<h3 id="ensureActiveGroup"><a href="#ensureActiveGroup" class="headerlink" title="ensureActiveGroup"></a>ensureActiveGroup</h3><p>现在已经知道了 GroupCoordinator 节点，并建立了连接。<code>ensureActiveGroup ()</code> 这个方法的主要作用：<strong>向 GroupCoordinator 发送 join-group、sync-group 请求，获取 assign 的 tp list。</strong></p>
<ul>
<li>调用过程是 <code>ensureActiveGroup ()</code> → <code>ensureCoordinatorReady ()</code> → <code>startHeartbeatThreadIfNeeded ()</code> → <code>joinGroupIfNeeded ()</code>。</li>
<li><code>joinGroupIfNeeded ()</code> 方法中最重要的方法是 <code>initiateJoinGroup ()</code>，它的的调用流程是 <code>disableHeartbeatThread ()</code> → <code>sendJoinGroupRequest ()</code> → <code>JoinGroupResponseHandler::handle ()</code> → <code>onJoinLeader ()</code>，<code>onJoinFollower ()</code> → <code>sendSyncGroupRequest ()</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensure the group is active (i.e., joined and synced)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true iff the group is active</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">ensureActiveGroup</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// always ensure that the coordinator is ready because we may have been disconnected</span></span><br><span class="line">    <span class="comment">// when sending heartbeats and does not necessarily require us to rejoin the group.</span></span><br><span class="line">    <span class="comment">// 1.确保GroupCoordinator已经连接</span></span><br><span class="line">    <span class="keyword">if</span> (!ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.启动心跳线程，但是并不一定发送心跳，满足条件后才会发送心跳</span></span><br><span class="line">    startHeartbeatThreadIfNeeded();</span><br><span class="line">    <span class="comment">// 3.发送joinGroup请求，并对返回的信息进行处理，核心步骤</span></span><br><span class="line">    <span class="keyword">return</span> joinGroupIfNeeded(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>心跳线程就是在这里启动的，但是并不一定马上发送心跳包，会在满足条件之后才会开始发送。后面最主要的逻辑就集中在 <code>joinGroupIfNeeded ()</code> 方法，它的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Joins the group without starting the heartbeat thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Visible for testing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true iff the operation succeeded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">joinGroupIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call onJoinPrepare if needed. We set a flag to make sure that we do not call it a second</span></span><br><span class="line">        <span class="comment">// time if the client is woken up before a pending rebalance completes. This must be called</span></span><br><span class="line">        <span class="comment">// on each iteration of the loop because an event requiring a rebalance (such as a metadata</span></span><br><span class="line">        <span class="comment">// refresh which changes the matched subscription set) can occur while another rebalance is</span></span><br><span class="line">        <span class="comment">// still in progress.</span></span><br><span class="line">        <span class="comment">// 触发onJoinPrepare，包括offset commit和rebalance listener</span></span><br><span class="line">        <span class="keyword">if</span> (needsJoinPrepare) &#123;</span><br><span class="line">            <span class="comment">// 如果是自动提交，则要开始提交offset以及在join group之前回调reblance listener接口</span></span><br><span class="line">            onJoinPrepare(generation.generationId, generation.memberId);</span><br><span class="line">            needsJoinPrepare = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化joinGroup请求，并发送joinGroup请求，核心步骤</span></span><br><span class="line">        <span class="keyword">final</span> RequestFuture&lt;ByteBuffer&gt; future = initiateJoinGroup();</span><br><span class="line">        client.poll(future, timer);</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            <span class="comment">// we ran out of time</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// join succeed，这一步时，时间上sync-group已经成功了</span></span><br><span class="line">        <span class="keyword">if</span> (future.succeeded()) &#123;</span><br><span class="line">            <span class="comment">// Duplicate the buffer in case `onJoinComplete` does not complete and needs to be retried.</span></span><br><span class="line">            ByteBuffer memberAssignment = future.value().duplicate();</span><br><span class="line">            <span class="comment">// 发送完成，consumer加入group成功，触发onJoinComplete()方法</span></span><br><span class="line">            onJoinComplete(generation.generationId, generation.memberId, generation.protocol, memberAssignment);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We reset the join group future only after the completion callback returns. This ensures</span></span><br><span class="line">            <span class="comment">// that if the callback is woken up, we will retry it on the next joinGroupIfNeeded.</span></span><br><span class="line">            <span class="comment">// 重置joinFuture为空</span></span><br><span class="line">            resetJoinGroupFuture();</span><br><span class="line">            needsJoinPrepare = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resetJoinGroupFuture();</span><br><span class="line">            <span class="keyword">final</span> RuntimeException exception = future.exception();</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> UnknownMemberIdException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> RebalanceInProgressException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> IllegalGenerationException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> MemberIdRequiredException)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!future.isRetriable())</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line"></span><br><span class="line">            timer.sleep(retryBackoffMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initiateJoinGroup ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">initiateJoinGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we store the join future in case we are woken up by the user after beginning the</span></span><br><span class="line">    <span class="comment">// rebalance in the call to poll below. This ensures that we do not mistakenly attempt</span></span><br><span class="line">    <span class="comment">// to rejoin before the pending rebalance has completed.</span></span><br><span class="line">    <span class="keyword">if</span> (joinFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// fence off the heartbeat thread explicitly so that it cannot interfere with the join group.</span></span><br><span class="line">        <span class="comment">// Note that this must come after the call to onJoinPrepare since we must be able to continue</span></span><br><span class="line">        <span class="comment">// sending heartbeats if that callback takes some time.</span></span><br><span class="line">        <span class="comment">// Step1:rebalance期间，心跳线程停止运行</span></span><br><span class="line">        disableHeartbeatThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前状态为rebalance</span></span><br><span class="line">        state = MemberState.REBALANCING;</span><br><span class="line">        <span class="comment">// Step2:发送joinGroup请求，核心步骤</span></span><br><span class="line">        joinFuture = sendJoinGroupRequest();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Step3:为joinGroup请求添加监听器，监听joinGroup请求的结果并做相应的处理</span></span><br><span class="line">        joinFuture.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ByteBuffer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ByteBuffer value)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// handle join completion in the callback so that the callback will be invoked</span></span><br><span class="line">                <span class="comment">// even if the consumer is woken up before finishing the rebalance</span></span><br><span class="line">                <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;Successfully joined group with generation &#123;&#125;&quot;</span>, generation.generationId);</span><br><span class="line">                    <span class="comment">// 如果joinGroup成功，设置状态为stable</span></span><br><span class="line">                    state = MemberState.STABLE;</span><br><span class="line">                    rejoinNeeded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (heartbeatThread != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// Step4:允许心跳线程继续运行</span></span><br><span class="line">                        heartbeatThread.enable();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// we handle failures below after the request finishes. if the join completes</span></span><br><span class="line">                <span class="comment">// after having been woken up, the exception is ignored and we will rejoin</span></span><br><span class="line">                <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果joinGroup失败，设置状态为unjoined</span></span><br><span class="line">                    state = MemberState.UNJOINED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joinFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在 joinGroup 之前会让心跳线程暂时停下来，此时会将 ConsumerCoordinator 的状态设置为 rebalance 状态，当 joinGroup 成功之后会将状态设置为 stable 状态，同时让之前停下来的心跳线程继续运行。</p>
<p><code>sendJoinGroupRequest ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Join the group and return the assignment for the next generation. This function handles both</span></span><br><span class="line"><span class="comment"> * JoinGroup and SyncGroup, delegating to &#123;<span class="doctag">@link</span> #performAssignment(String, String, List)&#125; if</span></span><br><span class="line"><span class="comment"> * elected leader by the coordinator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This is visible only for testing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A request future which wraps the assignment returned from the group leader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 发送joinGroup请求</span></span><br><span class="line"><span class="function">RequestFuture&lt;ByteBuffer&gt; <span class="title">sendJoinGroupRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coordinatorUnknown())</span><br><span class="line">        <span class="keyword">return</span> RequestFuture.coordinatorNotAvailable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send a join group request to the coordinator</span></span><br><span class="line">    log.info(<span class="string">&quot;(Re-)joining group&quot;</span>);</span><br><span class="line">    JoinGroupRequest.Builder requestBuilder = <span class="keyword">new</span> JoinGroupRequest.Builder(</span><br><span class="line">            <span class="keyword">new</span> JoinGroupRequestData()</span><br><span class="line">                    .setGroupId(groupId)</span><br><span class="line">                    .setSessionTimeoutMs(<span class="keyword">this</span>.sessionTimeoutMs)</span><br><span class="line">                    .setMemberId(<span class="keyword">this</span>.generation.memberId)</span><br><span class="line">                    .setGroupInstanceId(<span class="keyword">this</span>.groupInstanceId.orElse(<span class="keyword">null</span>))</span><br><span class="line">                    .setProtocolType(protocolType())</span><br><span class="line">                    .setProtocols(metadata())</span><br><span class="line">                    .setRebalanceTimeoutMs(<span class="keyword">this</span>.rebalanceTimeoutMs)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Sending JoinGroup (&#123;&#125;) to coordinator &#123;&#125;&quot;</span>, requestBuilder, <span class="keyword">this</span>.coordinator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that we override the request timeout using the rebalance timeout since that is the</span></span><br><span class="line">    <span class="comment">// maximum time that it may block on the coordinator. We add an extra 5 seconds for small delays.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> joinGroupTimeoutMs = Math.max(rebalanceTimeoutMs, rebalanceTimeoutMs + <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> client.send(coordinator, requestBuilder, joinGroupTimeoutMs)</span><br><span class="line">            .compose(<span class="keyword">new</span> JoinGroupResponseHandler());<span class="comment">// Step5:处理joinGroup请求后的response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发送 joinGroup 请求之后，会收到来自服务器的响应，然后针对这个响应再做一些重要的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理发送joinGroup请求后的response的handler(同步group信息)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroupResponseHandler</span> <span class="keyword">extends</span> <span class="title">CoordinatorResponseHandler</span>&lt;<span class="title">JoinGroupResponse</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(JoinGroupResponse joinResponse, RequestFuture&lt;ByteBuffer&gt; future)</span> </span>&#123;</span><br><span class="line">        Errors error = joinResponse.error();</span><br><span class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Received successful JoinGroup response: &#123;&#125;&quot;</span>, joinResponse);</span><br><span class="line">            sensors.joinLatency.record(response.requestLatencyMs());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state != MemberState.REBALANCING) &#123;</span><br><span class="line">                    <span class="comment">// if the consumer was woken up before a rebalance completes, we may have already left</span></span><br><span class="line">                    <span class="comment">// the group. In this case, we do not want to continue with the sync group.</span></span><br><span class="line">                    future.raise(<span class="keyword">new</span> UnjoinedGroupException());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    AbstractCoordinator.<span class="keyword">this</span>.generation = <span class="keyword">new</span> Generation(joinResponse.data().generationId(),</span><br><span class="line">                            joinResponse.data().memberId(), joinResponse.data().protocolName());</span><br><span class="line">                    <span class="comment">// Step6:joinGroup成功，下面需要进行sync-group，获取分配的tp列表</span></span><br><span class="line">                    <span class="keyword">if</span> (joinResponse.isLeader()) &#123;</span><br><span class="line">                        <span class="comment">// 当前consumer是leader</span></span><br><span class="line">                        onJoinLeader(joinResponse).chain(future);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前consumer是follower</span></span><br><span class="line">                        onJoinFollower().chain(future);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.COORDINATOR_LOAD_IN_PROGRESS) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Attempt to join group rejected since coordinator &#123;&#125; is loading the group.&quot;</span>, coordinator());</span><br><span class="line">            <span class="comment">// backoff and retry</span></span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_MEMBER_ID) &#123;</span><br><span class="line">            <span class="comment">// reset the member id and retry immediately</span></span><br><span class="line">            resetGeneration();</span><br><span class="line">            log.debug(<span class="string">&quot;Attempt to join group failed due to unknown member id.&quot;</span>);</span><br><span class="line">            future.raise(Errors.UNKNOWN_MEMBER_ID);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.COORDINATOR_NOT_AVAILABLE</span><br><span class="line">                || error == Errors.NOT_COORDINATOR) &#123;</span><br><span class="line">            <span class="comment">// re-discover the coordinator and retry with backoff</span></span><br><span class="line">            markCoordinatorUnknown();</span><br><span class="line">            log.debug(<span class="string">&quot;Attempt to join group failed due to obsolete coordinator information: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.FENCED_INSTANCE_ID) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Received fatal exception: group.instance.id gets fenced&quot;</span>);</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.INCONSISTENT_GROUP_PROTOCOL</span><br><span class="line">                || error == Errors.INVALID_SESSION_TIMEOUT</span><br><span class="line">                || error == Errors.INVALID_GROUP_ID</span><br><span class="line">                || error == Errors.GROUP_AUTHORIZATION_FAILED</span><br><span class="line">                || error == Errors.GROUP_MAX_SIZE_REACHED) &#123;</span><br><span class="line">            <span class="comment">// log the error and re-throw the exception</span></span><br><span class="line">            log.error(<span class="string">&quot;Attempt to join group failed due to fatal error: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">            <span class="keyword">if</span> (error == Errors.GROUP_MAX_SIZE_REACHED) &#123;</span><br><span class="line">                future.raise(<span class="keyword">new</span> GroupMaxSizeReachedException(groupId));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</span><br><span class="line">                future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNSUPPORTED_VERSION) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Attempt to join group failed due to unsupported version error. Please unset field group.instance.id and retry&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;to see if the problem resolves&quot;</span>);</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.MEMBER_ID_REQUIRED) &#123;</span><br><span class="line">            <span class="comment">// Broker requires a concrete member id to be allowed to join the group. Update member id</span></span><br><span class="line">            <span class="comment">// and send another join group request in next cycle.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.generation = <span class="keyword">new</span> Generation(OffsetCommitRequest.DEFAULT_GENERATION_ID,</span><br><span class="line">                        joinResponse.data().memberId(), <span class="keyword">null</span>);</span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.rejoinNeeded = <span class="keyword">true</span>;</span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.state = MemberState.UNJOINED;</span><br><span class="line">            &#125;</span><br><span class="line">            future.raise(Errors.MEMBER_ID_REQUIRED);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// unexpected error, throw the exception</span></span><br><span class="line">            log.error(<span class="string">&quot;Attempt to join group failed due to unexpected error: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">            future.raise(<span class="keyword">new</span> KafkaException(<span class="string">&quot;Unexpected error in join group response: &quot;</span> + error.message()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的主要过程如下：</p>
<ol>
<li>如果 group 是新的 <code>group.id</code>，那么此时 group 初始化的状态为 <strong>Empty</strong>；</li>
<li>当 GroupCoordinator 接收到 consumer 的 join-group 请求后，由于此时这个 group 的 member 列表还是空 (group 是新建的，每个 consumer 实例被称为这个 group 的一个 member)，<strong>第一个加入的 member 将被选为 leader</strong>，也就是说，对于一个新的 consumer group 而言，当第一个 consumer 实例加入后将会被选为 leader。如果后面 leader 挂了，会从其他 member 里面随机选择一个 member 成为新的 leader；</li>
<li>如果 GroupCoordinator 接收到 leader 发送 join-group 请求，将会触发 rebalance，group 的状态变为 <strong>PreparingRebalance</strong>；</li>
<li>此时，GroupCoordinator 将会等待一定的时间，如果在一定时间内，接收到 join-group 请求的 consumer 将被认为是依然存活的，此时 group 会变为 <strong>AwaitSync</strong> 状态，并且 GroupCoordinator 会向这个 group 的所有 member 返回其 response；</li>
<li>consumer 在接收到 GroupCoordinator 的 response 后，如果这个 consumer 是 group 的 leader，那么这个 consumer 将会负责为整个 group assign partition 订阅安排（默认是按 range 的策略，目前也可选 roundrobin），然后 leader 将分配后的信息以 <code>sendSyncGroupRequest ()</code> 请求的方式发给 GroupCoordinator，而作为 follower 的 consumer 实例会发送一个空列表；</li>
<li>GroupCoordinator 在接收到 leader 发来的请求后，会将 assign 的结果返回给所有已经发送 sync-group 请求的 consumer 实例，并且 group 的状态将会转变为 <strong>Stable</strong>，如果后续再收到 sync-group 请求，由于 group 的状态已经是 Stable，将会直接返回其分配结果。</li>
</ol>
<p>sync-group 发送请求核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当consumer为follower时，从GroupCoordinator拉取分配结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">onJoinFollower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// send follower&#x27;s sync group with an empty assignment</span></span><br><span class="line">    SyncGroupRequest.Builder requestBuilder =</span><br><span class="line">            <span class="keyword">new</span> SyncGroupRequest.Builder(</span><br><span class="line">                    <span class="keyword">new</span> SyncGroupRequestData()</span><br><span class="line">                            .setGroupId(groupId)</span><br><span class="line">                            .setMemberId(generation.memberId)</span><br><span class="line">                            .setGroupInstanceId(<span class="keyword">this</span>.groupInstanceId.orElse(<span class="keyword">null</span>))</span><br><span class="line">                            .setGenerationId(generation.generationId)</span><br><span class="line">                            .setAssignments(Collections.emptyList())</span><br><span class="line">            );</span><br><span class="line">    log.debug(<span class="string">&quot;Sending follower SyncGroup to coordinator &#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">this</span>.coordinator, requestBuilder);</span><br><span class="line">    <span class="comment">// 发送sync-group请求</span></span><br><span class="line">    <span class="keyword">return</span> sendSyncGroupRequest(requestBuilder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当consumer客户端为leader时，对group下的所有实例进行分配，将assign的结果发送到GroupCoordinator</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">onJoinLeader</span><span class="params">(JoinGroupResponse joinResponse)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// perform the leader synchronization and send back the assignment for the group(assign 操作)</span></span><br><span class="line">        Map&lt;String, ByteBuffer&gt; groupAssignment = performAssignment(joinResponse.data().leader(), joinResponse.data().protocolName(),</span><br><span class="line">                joinResponse.data().members());</span><br><span class="line"></span><br><span class="line">        List&lt;SyncGroupRequestData.SyncGroupRequestAssignment&gt; groupAssignmentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, ByteBuffer&gt; assignment : groupAssignment.entrySet()) &#123;</span><br><span class="line">            groupAssignmentList.add(<span class="keyword">new</span> SyncGroupRequestData.SyncGroupRequestAssignment()</span><br><span class="line">                    .setMemberId(assignment.getKey())</span><br><span class="line">                    .setAssignment(Utils.toArray(assignment.getValue()))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SyncGroupRequest.Builder requestBuilder =</span><br><span class="line">                <span class="keyword">new</span> SyncGroupRequest.Builder(</span><br><span class="line">                        <span class="keyword">new</span> SyncGroupRequestData()</span><br><span class="line">                                .setGroupId(groupId)</span><br><span class="line">                                .setMemberId(generation.memberId)</span><br><span class="line">                                .setGroupInstanceId(<span class="keyword">this</span>.groupInstanceId.orElse(<span class="keyword">null</span>))</span><br><span class="line">                                .setGenerationId(generation.generationId)</span><br><span class="line">                                .setAssignments(groupAssignmentList)</span><br><span class="line">                );</span><br><span class="line">        log.debug(<span class="string">&quot;Sending leader SyncGroup to coordinator &#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">this</span>.coordinator, requestBuilder);</span><br><span class="line">        <span class="comment">// 发送sync-group请求</span></span><br><span class="line">        <span class="keyword">return</span> sendSyncGroupRequest(requestBuilder);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> RequestFuture.failure(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送SyncGroup请求，获取对partition分配的安排</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">sendSyncGroupRequest</span><span class="params">(SyncGroupRequest.Builder requestBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coordinatorUnknown())</span><br><span class="line">        <span class="keyword">return</span> RequestFuture.coordinatorNotAvailable();</span><br><span class="line">    <span class="keyword">return</span> client.send(coordinator, requestBuilder)</span><br><span class="line">            .compose(<span class="keyword">new</span> SyncGroupResponseHandler());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncGroupResponseHandler</span> <span class="keyword">extends</span> <span class="title">CoordinatorResponseHandler</span>&lt;<span class="title">SyncGroupResponse</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(SyncGroupResponse syncResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                       RequestFuture&lt;ByteBuffer&gt; future)</span> </span>&#123;</span><br><span class="line">        Errors error = syncResponse.error();</span><br><span class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">            <span class="comment">// sync-group成功</span></span><br><span class="line">            sensors.syncLatency.record(response.requestLatencyMs());</span><br><span class="line">            future.complete(ByteBuffer.wrap(syncResponse.data.assignment()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// join的标志位设置为true</span></span><br><span class="line">            requestRejoin();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</span><br><span class="line">                future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.REBALANCE_IN_PROGRESS) &#123;</span><br><span class="line">                <span class="comment">// group正在进行rebalance，任务失败</span></span><br><span class="line">                log.debug(<span class="string">&quot;SyncGroup failed because the group began another rebalance&quot;</span>);</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.FENCED_INSTANCE_ID) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Received fatal exception: group.instance.id gets fenced&quot;</span>);</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_MEMBER_ID</span><br><span class="line">                    || error == Errors.ILLEGAL_GENERATION) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;SyncGroup failed: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">                resetGeneration();</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.COORDINATOR_NOT_AVAILABLE</span><br><span class="line">                    || error == Errors.NOT_COORDINATOR) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;SyncGroup failed: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">                markCoordinatorUnknown();</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future.raise(<span class="keyword">new</span> KafkaException(<span class="string">&quot;Unexpected error from SyncGroup: &quot;</span> + error.message()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个阶段主要是将分区分配方案同步给各个消费者，这个同步仍然是通过 GroupCoordinator 来转发的。</p>
<blockquote>
<p>分区策略并非由 leader 消费者来决定，而是各个消费者投票决定的，谁的票多就采用什么分区策略。这里的分区策略是通过 <code>partition.assignment.strategy</code> 参数设置的，可以设置多个。如果选举出了消费者不支持的策略，那么就会抛出异常 <code>IllegalArgumentException: Member does not support protocol</code>。</p>
</blockquote>
<p>经过上面的步骤，一个 consumer 实例就已经加入 group 成功了，加入 group 成功后，将会触发 ConsumerCoordinator 的 <code>onJoinComplete ()</code> 方法，其作用就是：更新订阅的 tp 列表、更新其对应的 metadata 及触发注册的 listener。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入group成功</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onJoinComplete</span><span class="params">(<span class="keyword">int</span> generation,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String memberId,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String assignmentStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ByteBuffer assignmentBuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// only the leader is responsible for monitoring for metadata changes (i.e. partition changes)</span></span><br><span class="line">    <span class="keyword">if</span> (!isLeader)</span><br><span class="line">        assignmentSnapshot = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    PartitionAssignor assignor = lookupAssignor(assignmentStrategy);</span><br><span class="line">    <span class="keyword">if</span> (assignor == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Coordinator selected invalid assignment protocol: &quot;</span> + assignmentStrategy);</span><br><span class="line"></span><br><span class="line">    Assignment assignment = ConsumerProtocol.deserializeAssignment(assignmentBuffer);</span><br><span class="line">    <span class="keyword">if</span> (!subscriptions.assignFromSubscribed(assignment.partitions())) &#123;</span><br><span class="line">        handleAssignmentMismatch(assignment);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;TopicPartition&gt; assignedPartitions = subscriptions.assignedPartitions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The leader may have assigned partitions which match our subscription pattern, but which</span></span><br><span class="line">    <span class="comment">// were not explicitly requested, so we update the joined subscription here.</span></span><br><span class="line">    maybeUpdateJoinedSubscription(assignedPartitions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give the assignor a chance to update internal state based on the received assignment</span></span><br><span class="line">    assignor.onAssignment(assignment, generation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reschedule the auto commit starting from now</span></span><br><span class="line">    <span class="keyword">if</span> (autoCommitEnabled)</span><br><span class="line">        <span class="keyword">this</span>.nextAutoCommitTimer.updateAndReset(autoCommitIntervalMs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execute the user&#x27;s callback after rebalance</span></span><br><span class="line">    ConsumerRebalanceListener listener = subscriptions.rebalanceListener();</span><br><span class="line">    log.info(<span class="string">&quot;Setting newly assigned partitions: &#123;&#125;&quot;</span>, Utils.join(assignedPartitions, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listener.onPartitionsAssigned(assignedPartitions);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WakeupException | InterruptException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;User provided listener &#123;&#125; failed on partition assignment&quot;</span>, listener.getClass().getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，一个 consumer 实例算是真正上意义上加入 group 成功。</p>
<p>然后 consumer 就进入正常工作状态，同时 consumer 也通过向 GroupCoordinator 发送心跳来维持它们与消费者组的从属关系，以及它们对分区的所有权关系。只要以正常的间隔发送心跳，就被认为是活跃的，但是如果 GroupCoordinator 没有响应，那么就会发送 LeaveGroup 请求退出消费者组。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="http://generalthink.github.io/2019/05/15/how-to-join-kafka-consumer-group/">http://generalthink.github.io/2019/05/15/how-to-join-kafka-consumer-group/</a></p>
<p><a target="_blank" rel="noopener" href="https://matt33.com/2017/10/22/consumer-join-group/">https://matt33.com/2017/10/22/consumer-join-group/</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XiSun"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">XiSun</p>
  <div class="site-description" itemprop="description">心如止水者，虽世间繁华之红尘纷扰，已然空无一物</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiSun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">607k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:12</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
