<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Kafka 的 consumer 比 producer 要复杂许多，producer 没有 group 的概念，也不需要关注 offset，而 consumer 不一样，它有组织 (consumer group)，有纪律 (offset)。这些对 consumer 的要求就会很高，这篇文章就主要介绍 consumer 是如何加入 consumer group 的。 在这之前，我们需要先了解一下什么">
<meta property="og:type" content="article">
<meta property="og:title" content="KafkaConsumer 源码之 consumer 如何加入 consumer group">
<meta property="og:url" content="http://example.com/2020/11/04/kafka-consumer-group/index.html">
<meta property="og:site_name" content="XiSun的博客">
<meta property="og:description" content="Kafka 的 consumer 比 producer 要复杂许多，producer 没有 group 的概念，也不需要关注 offset，而 consumer 不一样，它有组织 (consumer group)，有纪律 (offset)。这些对 consumer 的要求就会很高，这篇文章就主要介绍 consumer 是如何加入 consumer group 的。 在这之前，我们需要先了解一下什么">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-04T01:35:04.000Z">
<meta property="article:modified_time" content="2020-11-20T09:13:43.420Z">
<meta property="article:author" content="XiSun">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/11/04/kafka-consumer-group/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>KafkaConsumer 源码之 consumer 如何加入 consumer group | XiSun的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiSun的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learning is endless</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/04/kafka-consumer-group/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          KafkaConsumer 源码之 consumer 如何加入 consumer group
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-04 09:35:04" itemprop="dateCreated datePublished" datetime="2020-11-04T09:35:04+08:00">2020-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-20 17:13:43" itemprop="dateModified" datetime="2020-11-20T17:13:43+08:00">2020-11-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>33 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Kafka 的 consumer 比 producer 要复杂许多，producer 没有 group 的概念，也不需要关注 offset，而 consumer 不一样，它有组织 (consumer group)，有纪律 (offset)。这些对 consumer 的要求就会很高，这篇文章就主要介绍 consumer 是如何加入 consumer group 的。</p>
<p>在这之前，我们需要先了解一下什么是 GroupCoordinator。简单地说，<strong>GroupCoordinator 是运行在服务器上的一个服务，Kafka 集群上的每一个 broker 节点启动的时候，都会启动一个 GroupCoordinator 服务，其功能是负责进行 consumer 的 group 成员与 offset 管理 (但每个 GroupCoordinator 只是管理一部分的 consumer group member 和 offset 信息)。</strong></p>
<p>consumer group 对应的 GroupCoordinator 节点的确定，会通过如下方式：</p>
<p>将 consumer group 的 <code>group.id</code> 进行 hash，把得到的值的绝对值，对 _consumer_offsets 的 partition 总数取余，然后得到其对应的 partition 值，该 partition 的 leader 所在的 broker 即为该 consumer group 所对应的 GroupCoordinator 节点，GroupCoordinator 会存储与该 consumer group 相关的所有的 Meta 信息。</p>
<blockquote>
<p>1._consumer_offsets 这个 topic 是 Kafka 内部使用的一个 topic，专门用来存储 group 消费的情况，默认情况下有 50 个 partition，每个 partition 默认有三个副本。</p>
<p>2.partition 计算方式：<code>abs(GroupId.hashCode()) % NumPartitions</code>，其中，NumPartitions 是 _consumer_offsets 的 partition 数，默认是 50 个。</p>
<p>3.比如，现在通过计算 <code>abs(GroupId.hashCode()) % NumPartitions</code> 的值为 35，然后就找第 35 个 partition 的 leader 在哪个 broker 上 (假设在 192.168.1.12)，那么 GroupCoordinator 节点就在这个 broker 上。</p>
</blockquote>
<p><strong>同时，这个 consumer group 所提交的消费 offset 信息也会发送给这个 partition 的 leader 所对应的 broker 节点，因此，这个节点不仅是 GroupCoordinator，而且还保存分区分配方案和组内消费者 offset 信息。</strong></p>
<p>更多关于 GroupCoordinator 的解析，参考：<a target="_blank" rel="noopener" href="https://matt33.com/2018/01/28/server-group-coordinator/">Kafka 源码解析之 GroupCoordinator 详解</a>。</p>
<h2 id="KafkaConsumer-消费消息的主体流程"><a href="#KafkaConsumer-消费消息的主体流程" class="headerlink" title="KafkaConsumer 消费消息的主体流程"></a>KafkaConsumer 消费消息的主体流程</h2><p>接下来，我们回顾下 KafkaConsumer 消费消息的主体流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line">KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅主题</span></span><br><span class="line">kafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;consumerCodeTopic&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务器拉取数据</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<h3 id="创建-KafkaConsumer"><a href="#创建-KafkaConsumer" class="headerlink" title="创建 KafkaConsumer"></a>创建 KafkaConsumer</h3><p>创建 KafkaConsumer 的时候，会创建一个 ConsumerCoordinator 服务，由它来负责和 GroupCoordinator 通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no coordinator will be constructed for the default (null) group id</span></span><br><span class="line"><span class="keyword">this</span>.coordinator = groupId == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">	<span class="keyword">new</span> ConsumerCoordinator(logContext,</span><br><span class="line">                        <span class="keyword">this</span>.client,</span><br><span class="line">                        groupId,</span><br><span class="line">                        <span class="keyword">this</span>.groupInstanceId,</span><br><span class="line">                        maxPollIntervalMs,</span><br><span class="line">                        sessionTimeoutMs,</span><br><span class="line">                        <span class="keyword">new</span> Heartbeat(time, sessionTimeoutMs, heartbeatIntervalMs, maxPollIntervalMs, retryBackoffMs),</span><br><span class="line">                        assignors,</span><br><span class="line">                        <span class="keyword">this</span>.metadata,</span><br><span class="line">                        <span class="keyword">this</span>.subscriptions,</span><br><span class="line">                        metrics,</span><br><span class="line">                        metricGrpPrefix,</span><br><span class="line">                        <span class="keyword">this</span>.time,</span><br><span class="line">                        retryBackoffMs,</span><br><span class="line">                        enableAutoCommit,</span><br><span class="line">                        config.getInt(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG),</span><br><span class="line">                        <span class="keyword">this</span>.interceptors,</span><br><span class="line">                        config.getBoolean(ConsumerConfig.LEAVE_GROUP_ON_CLOSE_CONFIG));</span><br></pre></td></tr></table></figure>

<h3 id="订阅-topic"><a href="#订阅-topic" class="headerlink" title="订阅 topic"></a>订阅 topic</h3><p>KafkaConsumer 订阅 topic 的方式有好几种，这在<a target="_blank" rel="noopener" href="https://acatsmiling.github.io/2020/10/29/kafka-consumer/">前面的文章</a>有提到过。订阅的时候，会根据订阅的方式，设置其对应的订阅类型，默认存在四种订阅类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">SubscriptionType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认</span></span><br><span class="line">    NONE,</span><br><span class="line">    <span class="comment">// subscribe方式订阅</span></span><br><span class="line">    AUTO_TOPICS,</span><br><span class="line">    <span class="comment">// subscribe方式订阅</span></span><br><span class="line">    AUTO_PATTERN,</span><br><span class="line">    <span class="comment">// assign方式订阅</span></span><br><span class="line">    USER_ASSIGNED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，采用 <code>kafkaConsumer.subscribe(Collections.singletonList(&quot;consumerCodeTopic&quot;))</code> 方式订阅 topic 时，会将订阅类型设置为 <code>SubscriptionType.AUTO_TOPICS</code>，其核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscribe to the given list of topics to get dynamically assigned partitions.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;Topic subscriptions are not incremental. This list will replace the current</span></span><br><span class="line"><span class="comment"> * assignment (if there is one).&lt;/b&gt; It is not possible to combine topic subscription with group management</span></span><br><span class="line"><span class="comment"> * with manual partition assignment through &#123;<span class="doctag">@link</span> #assign(Collection)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the given list of topics is empty, it is treated the same as &#123;<span class="doctag">@link</span> #unsubscribe()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This is a short-hand for &#123;<span class="doctag">@link</span> #subscribe(Collection, ConsumerRebalanceListener)&#125;, which</span></span><br><span class="line"><span class="comment"> * uses a no-op listener. If you need the ability to seek to particular offsets, you should prefer</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #subscribe(Collection, ConsumerRebalanceListener)&#125;, since group rebalances will cause partition offsets</span></span><br><span class="line"><span class="comment"> * to be reset. You should also provide your own listener if you are doing your own offset</span></span><br><span class="line"><span class="comment"> * management since the listener gives you an opportunity to commit offsets before a rebalance finishes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topics The list of topics to subscribe to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException If topics is null or contains null or empty elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If &#123;<span class="doctag">@code</span> subscribe()&#125; is called previously with pattern, or assign is called</span></span><br><span class="line"><span class="comment"> *                               previously (without a subsequent call to &#123;<span class="doctag">@link</span> #unsubscribe()&#125;), or if not</span></span><br><span class="line"><span class="comment"> *                               configured at-least one partition assignment strategy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics)</span> </span>&#123;</span><br><span class="line">    subscribe(topics, <span class="keyword">new</span> NoOpConsumerRebalanceListener());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscribe to the given list of topics to get dynamically</span></span><br><span class="line"><span class="comment"> * assigned partitions. &lt;b&gt;Topic subscriptions are not incremental. This list will replace the current</span></span><br><span class="line"><span class="comment"> * assignment (if there is one).&lt;/b&gt; Note that it is not possible to combine topic subscription with group management</span></span><br><span class="line"><span class="comment"> * with manual partition assignment through &#123;<span class="doctag">@link</span> #assign(Collection)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the given list of topics is empty, it is treated the same as &#123;<span class="doctag">@link</span> #unsubscribe()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * As part of group management, the consumer will keep track of the list of consumers that belong to a particular</span></span><br><span class="line"><span class="comment"> * group and will trigger a rebalance operation if any one of the following events are triggered:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Number of partitions change for any of the subscribed topics</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;A subscribed topic is created or deleted</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;An existing member of the consumer group is shutdown or fails</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;A new member is added to the consumer group</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When any of these events are triggered, the provided listener will be invoked first to indicate that</span></span><br><span class="line"><span class="comment"> * the consumer&#x27;s assignment has been revoked, and then again when the new assignment has been received.</span></span><br><span class="line"><span class="comment"> * Note that rebalances will only occur during an active call to &#123;<span class="doctag">@link</span> #poll(Duration)&#125;, so callbacks will</span></span><br><span class="line"><span class="comment"> * also only be invoked during that time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The provided listener will immediately override any listener set in a previous call to subscribe.</span></span><br><span class="line"><span class="comment"> * It is guaranteed, however, that the partitions revoked/assigned through this interface are from topics</span></span><br><span class="line"><span class="comment"> * subscribed in this call. See &#123;<span class="doctag">@link</span> ConsumerRebalanceListener&#125; for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topics The list of topics to subscribe to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener Non-null listener instance to get notifications on partition assignment/revocation for the</span></span><br><span class="line"><span class="comment"> *                 subscribed topics</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException If topics is null or contains null or empty elements, or if listener is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If &#123;<span class="doctag">@code</span> subscribe()&#125; is called previously with pattern, or assign is called</span></span><br><span class="line"><span class="comment"> *                               previously (without a subsequent call to &#123;<span class="doctag">@link</span> #unsubscribe()&#125;), or if not</span></span><br><span class="line"><span class="comment"> *                               configured at-least one partition assignment strategy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        maybeThrowInvalidGroupIdException();</span><br><span class="line">        <span class="keyword">if</span> (topics == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic collection to subscribe to cannot be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (topics.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// treat subscribing to empty topic list as the same as unsubscribing</span></span><br><span class="line">            <span class="keyword">this</span>.unsubscribe();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String topic : topics) &#123;</span><br><span class="line">                <span class="keyword">if</span> (topic == <span class="keyword">null</span> || topic.trim().isEmpty())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Topic collection to subscribe to cannot contain null or empty topic&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throwIfNoAssignorsConfigured();</span><br><span class="line">            fetcher.clearBufferedDataForUnassignedTopics(topics);</span><br><span class="line">            log.info(<span class="string">&quot;Subscribed to topic(s): &#123;&#125;&quot;</span>, Utils.join(topics, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.subscribe(<span class="keyword">new</span> HashSet&lt;&gt;(topics), listener))</span><br><span class="line">                metadata.requestUpdateForNewTopics();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">subscribe</span><span class="params">(Set&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    registerRebalanceListener(listener);</span><br><span class="line">    setSubscriptionType(SubscriptionType.AUTO_TOPICS);</span><br><span class="line">    <span class="keyword">return</span> changeSubscription(topics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method sets the subscription type if it is not already set (i.e. when it is NONE),</span></span><br><span class="line"><span class="comment"> * or verifies that the subscription type is equal to the give type when it is set (i.e.</span></span><br><span class="line"><span class="comment"> * when it is not NONE)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type The given subscription type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSubscriptionType</span><span class="params">(SubscriptionType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptionType == SubscriptionType.NONE)</span><br><span class="line">        <span class="keyword">this</span>.subscriptionType = type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptionType != type)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(SUBSCRIPTION_EXCEPTION_MESSAGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从服务器拉取数据"><a href="#从服务器拉取数据" class="headerlink" title="从服务器拉取数据"></a>从服务器拉取数据</h3><p>订阅完成后，就可以从服务器拉取数据了，应该注意的是，KafkaConsumer 没有后台线程默默的拉取数据，它的所有行为都集中在 <code>poll ()</code> 方法中，<strong>KafkaConsumer 是线程不安全的，同时只能允许一个线程运行。</strong></p>
<p><code>kafkaConsumer.poll ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Step1:确认KafkaConsumer实例是单线程运行，以及没有被关闭</span></span><br><span class="line">    acquireAndEnsureOpen();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Consumer is not subscribed to any topics or assigned any partitions&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">                <span class="comment">// Step2:更新metadata信息，获取GroupCoordinator的ip以及接口，并连接、 join-group、sync-group，期间group会进行rebalance。在此步骤，consumer会先加入group，然后获取需要消费的topic partition的offset信息</span></span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;Still waiting for metadata&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step3:拉取数据</span></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);</span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// before returning the fetched records, we can send off the next round of fetches</span></span><br><span class="line">                <span class="comment">// and avoid block waiting for their responses to enable pipelining while the user</span></span><br><span class="line">                <span class="comment">// is handling the fetched records.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> since the consumed position has already been updated, we must not allow</span></span><br><span class="line">                <span class="comment">// wakeups or any other errors to be triggered prior to returning the fetched records.</span></span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;</span><br><span class="line">                    client.pollNoWakeup();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在 Step 1 阶段， <code>poll ()</code> 方法会先进行判定，如果有多个线程同时使用一个 KafkaConsumer 则会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire the light lock and ensure that the consumer hasn&#x27;t been closed.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException If the consumer has been closed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireAndEnsureOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">        release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This consumer has already been closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire the light lock protecting this consumer from multi-threaded access. Instead of blocking</span></span><br><span class="line"><span class="comment"> * when the lock is not available, however, we just throw an exception (since multi-threaded usage is not</span></span><br><span class="line"><span class="comment"> * supported).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ConcurrentModificationException if another thread already has the lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    <span class="keyword">if</span> (threadId != currentThread.get() &amp;&amp; !currentThread.compareAndSet(NO_CURRENT_THREAD, threadId))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException(<span class="string">&quot;KafkaConsumer is not safe for multi-threaded access&quot;</span>);</span><br><span class="line">    refcount.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KafkaConsumer-如何加入-consumer-group"><a href="#KafkaConsumer-如何加入-consumer-group" class="headerlink" title="KafkaConsumer 如何加入 consumer group"></a>KafkaConsumer 如何加入 consumer group</h2><p><strong>一个 KafkaConsumer 实例消费数据的前提是能够加入一个 consumer group 成功，并获取其要订阅的 tp（topic-partition）列表，因此首先要做的就是和 GroupCoordinator 建立连接，加入组织。</strong></p>
<p>因此，我们先把目光集中在 ConsumerCoordinator 上，这个过程主要发生在 Step 2 阶段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Visible for testing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.本篇文章的内容主要集中在coordinator.poll(timer)方法源码分析(主要功能是:consumer加入group)</span></span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.poll(timer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.updateFetchPositions(timer)方法留待下一篇文章分析(主要功能是:consumer获得partition的offset)</span></span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于对 ConsumerCoordinator 的处理都集中在 <code>coordinator.poll ()</code> 方法中。其主要逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Poll for coordinator events. This ensures that the coordinator is known and that the consumer</span></span><br><span class="line"><span class="comment"> * has joined the group (if it is using group management). This also handles periodic offset commits</span></span><br><span class="line"><span class="comment"> * if they are enabled.</span></span><br><span class="line"><span class="comment"> * (确保group的coordinator是已知的，并且这个consumer是已经加入到了group中，也用于offset周期性的commit)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Returns early if the timeout expires</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true iff the operation succeeded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(Timer timer)</span> </span>&#123;</span><br><span class="line">    maybeUpdateSubscriptionMetadata();</span><br><span class="line"></span><br><span class="line">    invokeCompletedOffsetCommitCallbacks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是subscribe方式订阅的topic</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;</span><br><span class="line">        <span class="comment">// Always update the heartbeat last poll time so that the heartbeat thread does not leave the</span></span><br><span class="line">        <span class="comment">// group proactively due to application inactivity even if (say) the coordinator cannot be found.</span></span><br><span class="line">        <span class="comment">// 1.检查心跳线程运行是否正常，如果心跳线程失败则抛出异常，反之则更新poll调用的时间</span></span><br><span class="line">        pollHeartbeat(timer.currentTimeMs());</span><br><span class="line">        <span class="comment">// 2.如果coordinator未知，则初始化ConsumeCoordinator</span></span><br><span class="line">        <span class="keyword">if</span> (coordinatorUnknown() &amp;&amp; !ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要重新加入group，如果订阅的partition变化或者分配的partition变化，都可能需要重新加入group</span></span><br><span class="line">        <span class="keyword">if</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">            <span class="comment">// due to a race condition between the initial metadata fetch and the initial rebalance,</span></span><br><span class="line">            <span class="comment">// we need to ensure that the metadata is fresh before joining initially. This ensures</span></span><br><span class="line">            <span class="comment">// that we have matched the pattern against the cluster&#x27;s topics at least once before joining.</span></span><br><span class="line">            <span class="keyword">if</span> (subscriptions.hasPatternSubscription()) &#123;</span><br><span class="line">                <span class="comment">// For consumer group that uses pattern-based subscription, after a topic is created,</span></span><br><span class="line">                <span class="comment">// any consumer that discovers the topic after metadata refresh can trigger rebalance</span></span><br><span class="line">                <span class="comment">// across the entire consumer group. Multiple rebalances can be triggered after one topic</span></span><br><span class="line">                <span class="comment">// creation if consumers refresh metadata at vastly different times. We can significantly</span></span><br><span class="line">                <span class="comment">// reduce the number of rebalances caused by single topic creation by asking consumer to</span></span><br><span class="line">                <span class="comment">// refresh metadata before re-joining the group as long as the refresh backoff time has</span></span><br><span class="line">                <span class="comment">// passed.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.metadata.timeToAllowUpdate(timer.currentTimeMs()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!client.ensureFreshMetadata(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                maybeUpdateSubscriptionMetadata();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.确保group是active的，重新加入group，分配订阅的partition</span></span><br><span class="line">            <span class="keyword">if</span> (!ensureActiveGroup(timer)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For manually assigned partitions, if there are no ready nodes, await metadata.</span></span><br><span class="line">        <span class="comment">// If connections to all nodes fail, wakeups triggered while attempting to send fetch</span></span><br><span class="line">        <span class="comment">// requests result in polls returning immediately, causing a tight loop of polls. Without</span></span><br><span class="line">        <span class="comment">// the wakeup, poll() with no channels would block for the timeout, delaying re-connection.</span></span><br><span class="line">        <span class="comment">// awaitMetadataUpdate() initiates new connections with configured backoff and avoids the busy loop.</span></span><br><span class="line">        <span class="comment">// When group management is used, metadata wait is already performed for this scenario as</span></span><br><span class="line">        <span class="comment">// coordinator is unknown, hence this check is not required.</span></span><br><span class="line">        <span class="keyword">if</span> (metadata.updateRequested() &amp;&amp; !client.hasReadyNodes(timer.currentTimeMs())) &#123;</span><br><span class="line">            client.awaitMetadataUpdate(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.如果设置的是自动commit,如果定时达到则自动commit</span></span><br><span class="line">    maybeAutoCommitOffsetsAsync(timer.currentTimeMs());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>coordinator.poll ()</code> 方法中，具体实现可以分为四个步骤：</p>
<ol>
<li><code>pollHeartbeat ()</code>：检测心跳线程运行是否正常，需要定时向 GroupCoordinator 发送心跳，如果超时未发送心跳，consumer 会离开 consumer group。</li>
<li><code>ensureCoordinatorReady ()</code>：当通过 <code>subscribe ()</code> 方法订阅 topic 时，如果 coordinator 未知，则初始化 ConsumerCoordinator (在 <code>ensureCoordinatorReady ()</code> 中实现，该方法主要的作用是发送 FindCoordinatorRequest 请求，并建立连接)。</li>
<li><code>ensureActiveGroup ()</code>：判断是否需要重新加入 group，如果订阅的 partition 变化或者分配的 partition 变化时，需要 rejoin，则通过 <code>ensureActiveGroup ()</code> 发送 join-group、sync-group 请求，加入 group 并获取其 assign 的 TopicPartition list。</li>
<li><code>maybeAutoCommitOffsetsAsync ()</code>：如果设置的是自动 commit，并且达到了发送时限则自动 commit offset。</li>
</ol>
<p>关于 rejoin，下列几种情况会触发再均衡 (reblance) 操作：</p>
<ul>
<li><p>订阅的 topic 列表变化</p>
</li>
<li><p>topic 被创建或删除</p>
</li>
<li><p>新的消费者加入消费者组 (第一次进行消费也属于这种情况)</p>
</li>
<li><p>消费者宕机下线 (长时间未发送心跳包)</p>
</li>
<li><p>消费者主动退出消费组，比如调用 <code>unsubscrible ()</code> 方法取消对主题的订阅</p>
</li>
<li><p>消费者组对应的 GroupCoorinator 节点发生了变化</p>
</li>
<li><p>消费者组内所订阅的任一主题或者主题的分区数量发生了变化</p>
</li>
</ul>
<blockquote>
<p>取消  topic 订阅，consumer 心跳线程超时以及在  Server 端给定的时间内未收到心跳请求，这三个都是触发的  LEAVE_GROUP 请求。</p>
</blockquote>
<p>下面重点介绍下第二步中的 <code>ensureCoordinatorReady ()</code> 方法和第三步中的 <code>ensureActiveGroup ()</code> 方法。</p>
<h3 id="ensureCoordinatorReady"><a href="#ensureCoordinatorReady" class="headerlink" title="ensureCoordinatorReady"></a>ensureCoordinatorReady</h3><p><code>ensureCoordinatorReady ()</code>这个方法主要作用：<strong>选择一个连接数最少的 broker (还未响应请求最少的 broker)，发送 FindCoordinator 请求，找到 GroupCoordinator 后，建立对应的 TCP 连接。</strong></p>
<ul>
<li>方法调用流程是 <code>ensureCoordinatorReady ()</code> → <code>lookupCoordinator ()</code> → <code>sendFindCoordinatorRequest ()</code>。</li>
<li>如果 client 收到 server response，那么就与 GroupCoordinator 建立连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Visible for testing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Ensure that the coordinator is ready to receive requests.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true If coordinator discovery and initial connection succeeded, false otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ensureCoordinatorReady</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!coordinatorUnknown())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 找到GroupCoordinator，并建立连接</span></span><br><span class="line">        <span class="keyword">final</span> RequestFuture&lt;Void&gt; future = lookupCoordinator();</span><br><span class="line">        client.poll(future, timer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            <span class="comment">// ran out of time</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (future.failed()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isRetriable()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Coordinator discovery failed, refreshing metadata&quot;</span>);</span><br><span class="line">                client.awaitMetadataUpdate(timer);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> future.exception();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; client.isUnavailable(coordinator)) &#123;</span><br><span class="line">            <span class="comment">// we found the coordinator, but the connection has failed, so mark</span></span><br><span class="line">            <span class="comment">// it dead and backoff before retrying discovery</span></span><br><span class="line">            markCoordinatorUnknown();</span><br><span class="line">            timer.sleep(retryBackoffMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (coordinatorUnknown() &amp;&amp; timer.notExpired());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !coordinatorUnknown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> RequestFuture&lt;Void&gt; <span class="title">lookupCoordinator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (findCoordinatorFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// find a node to ask about the coordinator(找一个最少连接的broker，此处对应的应该就是文章开头处确定GroupCoordinator节点的发发)</span></span><br><span class="line">        Node node = <span class="keyword">this</span>.client.leastLoadedNode();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;No broker available to send FindCoordinator request&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> RequestFuture.noBrokersAvailable();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 对找到的broker发送FindCoordinator请求，并对response进行处理</span></span><br><span class="line">            findCoordinatorFuture = sendFindCoordinatorRequest(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCoordinatorFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Discover the current coordinator for the group. Sends a GroupMetadata request to</span></span><br><span class="line"><span class="comment"> * one of the brokers. The returned future should be polled to get the result of the request.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A request future which indicates the completion of the metadata request</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;Void&gt; <span class="title">sendFindCoordinatorRequest</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initiate the group metadata request</span></span><br><span class="line">    log.debug(<span class="string">&quot;Sending FindCoordinator request to broker &#123;&#125;&quot;</span>, node);</span><br><span class="line">    FindCoordinatorRequest.Builder requestBuilder =</span><br><span class="line">            <span class="keyword">new</span> FindCoordinatorRequest.Builder(</span><br><span class="line">                    <span class="keyword">new</span> FindCoordinatorRequestData()</span><br><span class="line">                        .setKeyType(CoordinatorType.GROUP.id())</span><br><span class="line">                        .setKey(<span class="keyword">this</span>.groupId));</span><br><span class="line">    <span class="comment">// 发送请求，并将response转换为RequestFuture</span></span><br><span class="line">    <span class="comment">// compose的作用是将FindCoordinatorResponseHandler类转换为RequestFuture</span></span><br><span class="line">    <span class="comment">// 实际上就是为返回的Future类重置onSuccess()和onFailure()方法</span></span><br><span class="line">    <span class="keyword">return</span> client.send(node, requestBuilder)</span><br><span class="line">            .compose(<span class="keyword">new</span> FindCoordinatorResponseHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据response返回的ip以及端口信息，和该broke上开启的GroupCoordinator建立连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FindCoordinatorResponseHandler</span> <span class="keyword">extends</span> <span class="title">RequestFutureAdapter</span>&lt;<span class="title">ClientResponse</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Received FindCoordinator response &#123;&#125;&quot;</span>, resp);</span><br><span class="line">        clearFindCoordinatorFuture();</span><br><span class="line"></span><br><span class="line">        FindCoordinatorResponse findCoordinatorResponse = (FindCoordinatorResponse) resp.responseBody();</span><br><span class="line">        Errors error = findCoordinatorResponse.error();</span><br><span class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">            <span class="comment">// 如果正确获取broker上的GroupCoordinator，建立连接，并更新心跳时间</span></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// use MAX_VALUE - node.id as the coordinator id to allow separate connections</span></span><br><span class="line">                <span class="comment">// for the coordinator in the underlying network client layer</span></span><br><span class="line">                <span class="keyword">int</span> coordinatorConnectionId = Integer.MAX_VALUE - findCoordinatorResponse.data().nodeId();</span><br><span class="line"></span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.coordinator = <span class="keyword">new</span> Node(</span><br><span class="line">                        coordinatorConnectionId,</span><br><span class="line">                        findCoordinatorResponse.data().host(),</span><br><span class="line">                        findCoordinatorResponse.data().port());</span><br><span class="line">                log.info(<span class="string">&quot;Discovered group coordinator &#123;&#125;&quot;</span>, coordinator);</span><br><span class="line">                <span class="comment">// 初始化tcp连接</span></span><br><span class="line">                client.tryConnect(coordinator);</span><br><span class="line">                <span class="comment">// 更新心跳时间</span></span><br><span class="line">                heartbeat.resetSessionTimeout();</span><br><span class="line">            &#125;</span><br><span class="line">            future.complete(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</span><br><span class="line">            future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Group coordinator lookup failed: &#123;&#125;&quot;</span>, findCoordinatorResponse.data().errorMessage());</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</span><br><span class="line">        clearFindCoordinatorFuture();</span><br><span class="line">        <span class="keyword">super</span>.onFailure(e, future);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码主要作用就是：往一个负载最小的 broker 节点发起 FindCoordinator 请求，Kafka 在走到这个请求后会根据 group_id 查找对应的 GroupCoordinator 节点 (文章开头处介绍的方法)，如果找到对应的 GroupCoordinator 则会返回其对应的 node_id，host 和 port 信息，并建立连接。</p>
<blockquote>
<p>这里的 GroupCoordinator 节点的确定在文章开头提到过，是通过 <code>group.id</code> 和 partitionCount 来确定的。</p>
</blockquote>
<h3 id="ensureActiveGroup"><a href="#ensureActiveGroup" class="headerlink" title="ensureActiveGroup"></a>ensureActiveGroup</h3><p>现在已经知道了 GroupCoordinator 节点，并建立了连接。<code>ensureActiveGroup ()</code> 这个方法的主要作用：<strong>向 GroupCoordinator 发送 join-group、sync-group 请求，获取 assign 的 tp list。</strong></p>
<ul>
<li>调用过程是 <code>ensureActiveGroup ()</code> → <code>ensureCoordinatorReady ()</code> → <code>startHeartbeatThreadIfNeeded ()</code> → <code>joinGroupIfNeeded ()</code>。</li>
<li><code>joinGroupIfNeeded ()</code> 方法中最重要的方法是 <code>initiateJoinGroup ()</code>，它的的调用流程是 <code>disableHeartbeatThread ()</code> → <code>sendJoinGroupRequest ()</code> → <code>JoinGroupResponseHandler::handle ()</code> → <code>onJoinLeader ()</code>，<code>onJoinFollower ()</code> → <code>sendSyncGroupRequest ()</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensure the group is active (i.e., joined and synced)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true iff the group is active</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">ensureActiveGroup</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// always ensure that the coordinator is ready because we may have been disconnected</span></span><br><span class="line">    <span class="comment">// when sending heartbeats and does not necessarily require us to rejoin the group.</span></span><br><span class="line">    <span class="comment">// 1.确保GroupCoordinator已经连接</span></span><br><span class="line">    <span class="keyword">if</span> (!ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.启动心跳线程，但是并不一定发送心跳，满足条件后才会发送心跳</span></span><br><span class="line">    startHeartbeatThreadIfNeeded();</span><br><span class="line">    <span class="comment">// 3.发送joinGroup请求，并对返回的信息进行处理，核心步骤</span></span><br><span class="line">    <span class="keyword">return</span> joinGroupIfNeeded(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>心跳线程就是在这里启动的，但是并不一定马上发送心跳包，会在满足条件之后才会开始发送。后面最主要的逻辑就集中在 <code>joinGroupIfNeeded ()</code> 方法，它的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Joins the group without starting the heartbeat thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Visible for testing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timer Timer bounding how long this method can block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true iff the operation succeeded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">joinGroupIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ensureCoordinatorReady(timer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call onJoinPrepare if needed. We set a flag to make sure that we do not call it a second</span></span><br><span class="line">        <span class="comment">// time if the client is woken up before a pending rebalance completes. This must be called</span></span><br><span class="line">        <span class="comment">// on each iteration of the loop because an event requiring a rebalance (such as a metadata</span></span><br><span class="line">        <span class="comment">// refresh which changes the matched subscription set) can occur while another rebalance is</span></span><br><span class="line">        <span class="comment">// still in progress.</span></span><br><span class="line">        <span class="comment">// 触发onJoinPrepare，包括offset commit和rebalance listener</span></span><br><span class="line">        <span class="keyword">if</span> (needsJoinPrepare) &#123;</span><br><span class="line">            <span class="comment">// 如果是自动提交，则要开始提交offset以及在join group之前回调reblance listener接口</span></span><br><span class="line">            onJoinPrepare(generation.generationId, generation.memberId);</span><br><span class="line">            needsJoinPrepare = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化joinGroup请求，并发送joinGroup请求，核心步骤</span></span><br><span class="line">        <span class="keyword">final</span> RequestFuture&lt;ByteBuffer&gt; future = initiateJoinGroup();</span><br><span class="line">        client.poll(future, timer);</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">            <span class="comment">// we ran out of time</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// join succeed，这一步时，时间上sync-group已经成功了</span></span><br><span class="line">        <span class="keyword">if</span> (future.succeeded()) &#123;</span><br><span class="line">            <span class="comment">// Duplicate the buffer in case `onJoinComplete` does not complete and needs to be retried.</span></span><br><span class="line">            ByteBuffer memberAssignment = future.value().duplicate();</span><br><span class="line">            <span class="comment">// 发送完成，consumer加入group成功，触发onJoinComplete()方法</span></span><br><span class="line">            onJoinComplete(generation.generationId, generation.memberId, generation.protocol, memberAssignment);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We reset the join group future only after the completion callback returns. This ensures</span></span><br><span class="line">            <span class="comment">// that if the callback is woken up, we will retry it on the next joinGroupIfNeeded.</span></span><br><span class="line">            <span class="comment">// 重置joinFuture为空</span></span><br><span class="line">            resetJoinGroupFuture();</span><br><span class="line">            needsJoinPrepare = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resetJoinGroupFuture();</span><br><span class="line">            <span class="keyword">final</span> RuntimeException exception = future.exception();</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> UnknownMemberIdException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> RebalanceInProgressException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> IllegalGenerationException ||</span><br><span class="line">                    exception <span class="keyword">instanceof</span> MemberIdRequiredException)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!future.isRetriable())</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line"></span><br><span class="line">            timer.sleep(retryBackoffMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initiateJoinGroup ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">initiateJoinGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we store the join future in case we are woken up by the user after beginning the</span></span><br><span class="line">    <span class="comment">// rebalance in the call to poll below. This ensures that we do not mistakenly attempt</span></span><br><span class="line">    <span class="comment">// to rejoin before the pending rebalance has completed.</span></span><br><span class="line">    <span class="keyword">if</span> (joinFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// fence off the heartbeat thread explicitly so that it cannot interfere with the join group.</span></span><br><span class="line">        <span class="comment">// Note that this must come after the call to onJoinPrepare since we must be able to continue</span></span><br><span class="line">        <span class="comment">// sending heartbeats if that callback takes some time.</span></span><br><span class="line">        <span class="comment">// Step1:rebalance期间，心跳线程停止运行</span></span><br><span class="line">        disableHeartbeatThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前状态为rebalance</span></span><br><span class="line">        state = MemberState.REBALANCING;</span><br><span class="line">        <span class="comment">// Step2:发送joinGroup请求，核心步骤</span></span><br><span class="line">        joinFuture = sendJoinGroupRequest();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Step3:为joinGroup请求添加监听器，监听joinGroup请求的结果并做相应的处理</span></span><br><span class="line">        joinFuture.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ByteBuffer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ByteBuffer value)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// handle join completion in the callback so that the callback will be invoked</span></span><br><span class="line">                <span class="comment">// even if the consumer is woken up before finishing the rebalance</span></span><br><span class="line">                <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;Successfully joined group with generation &#123;&#125;&quot;</span>, generation.generationId);</span><br><span class="line">                    <span class="comment">// 如果joinGroup成功，设置状态为stable</span></span><br><span class="line">                    state = MemberState.STABLE;</span><br><span class="line">                    rejoinNeeded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (heartbeatThread != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// Step4:允许心跳线程继续运行</span></span><br><span class="line">                        heartbeatThread.enable();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// we handle failures below after the request finishes. if the join completes</span></span><br><span class="line">                <span class="comment">// after having been woken up, the exception is ignored and we will rejoin</span></span><br><span class="line">                <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果joinGroup失败，设置状态为unjoined</span></span><br><span class="line">                    state = MemberState.UNJOINED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joinFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在 joinGroup 之前会让心跳线程暂时停下来，此时会将 ConsumerCoordinator 的状态设置为 rebalance 状态，当 joinGroup 成功之后会将状态设置为 stable 状态，同时让之前停下来的心跳线程继续运行。</p>
<p><code>sendJoinGroupRequest ()</code> 方法的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Join the group and return the assignment for the next generation. This function handles both</span></span><br><span class="line"><span class="comment"> * JoinGroup and SyncGroup, delegating to &#123;<span class="doctag">@link</span> #performAssignment(String, String, List)&#125; if</span></span><br><span class="line"><span class="comment"> * elected leader by the coordinator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This is visible only for testing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A request future which wraps the assignment returned from the group leader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 发送joinGroup请求</span></span><br><span class="line"><span class="function">RequestFuture&lt;ByteBuffer&gt; <span class="title">sendJoinGroupRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coordinatorUnknown())</span><br><span class="line">        <span class="keyword">return</span> RequestFuture.coordinatorNotAvailable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send a join group request to the coordinator</span></span><br><span class="line">    log.info(<span class="string">&quot;(Re-)joining group&quot;</span>);</span><br><span class="line">    JoinGroupRequest.Builder requestBuilder = <span class="keyword">new</span> JoinGroupRequest.Builder(</span><br><span class="line">            <span class="keyword">new</span> JoinGroupRequestData()</span><br><span class="line">                    .setGroupId(groupId)</span><br><span class="line">                    .setSessionTimeoutMs(<span class="keyword">this</span>.sessionTimeoutMs)</span><br><span class="line">                    .setMemberId(<span class="keyword">this</span>.generation.memberId)</span><br><span class="line">                    .setGroupInstanceId(<span class="keyword">this</span>.groupInstanceId.orElse(<span class="keyword">null</span>))</span><br><span class="line">                    .setProtocolType(protocolType())</span><br><span class="line">                    .setProtocols(metadata())</span><br><span class="line">                    .setRebalanceTimeoutMs(<span class="keyword">this</span>.rebalanceTimeoutMs)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Sending JoinGroup (&#123;&#125;) to coordinator &#123;&#125;&quot;</span>, requestBuilder, <span class="keyword">this</span>.coordinator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that we override the request timeout using the rebalance timeout since that is the</span></span><br><span class="line">    <span class="comment">// maximum time that it may block on the coordinator. We add an extra 5 seconds for small delays.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> joinGroupTimeoutMs = Math.max(rebalanceTimeoutMs, rebalanceTimeoutMs + <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> client.send(coordinator, requestBuilder, joinGroupTimeoutMs)</span><br><span class="line">            .compose(<span class="keyword">new</span> JoinGroupResponseHandler());<span class="comment">// Step5:处理joinGroup请求后的response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发送 joinGroup 请求之后，会收到来自服务器的响应，然后针对这个响应再做一些重要的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理发送joinGroup请求后的response的handler(同步group信息)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroupResponseHandler</span> <span class="keyword">extends</span> <span class="title">CoordinatorResponseHandler</span>&lt;<span class="title">JoinGroupResponse</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(JoinGroupResponse joinResponse, RequestFuture&lt;ByteBuffer&gt; future)</span> </span>&#123;</span><br><span class="line">        Errors error = joinResponse.error();</span><br><span class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Received successful JoinGroup response: &#123;&#125;&quot;</span>, joinResponse);</span><br><span class="line">            sensors.joinLatency.record(response.requestLatencyMs());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state != MemberState.REBALANCING) &#123;</span><br><span class="line">                    <span class="comment">// if the consumer was woken up before a rebalance completes, we may have already left</span></span><br><span class="line">                    <span class="comment">// the group. In this case, we do not want to continue with the sync group.</span></span><br><span class="line">                    future.raise(<span class="keyword">new</span> UnjoinedGroupException());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    AbstractCoordinator.<span class="keyword">this</span>.generation = <span class="keyword">new</span> Generation(joinResponse.data().generationId(),</span><br><span class="line">                            joinResponse.data().memberId(), joinResponse.data().protocolName());</span><br><span class="line">                    <span class="comment">// Step6:joinGroup成功，下面需要进行sync-group，获取分配的tp列表</span></span><br><span class="line">                    <span class="keyword">if</span> (joinResponse.isLeader()) &#123;</span><br><span class="line">                        <span class="comment">// 当前consumer是leader</span></span><br><span class="line">                        onJoinLeader(joinResponse).chain(future);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前consumer是follower</span></span><br><span class="line">                        onJoinFollower().chain(future);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.COORDINATOR_LOAD_IN_PROGRESS) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Attempt to join group rejected since coordinator &#123;&#125; is loading the group.&quot;</span>, coordinator());</span><br><span class="line">            <span class="comment">// backoff and retry</span></span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_MEMBER_ID) &#123;</span><br><span class="line">            <span class="comment">// reset the member id and retry immediately</span></span><br><span class="line">            resetGeneration();</span><br><span class="line">            log.debug(<span class="string">&quot;Attempt to join group failed due to unknown member id.&quot;</span>);</span><br><span class="line">            future.raise(Errors.UNKNOWN_MEMBER_ID);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.COORDINATOR_NOT_AVAILABLE</span><br><span class="line">                || error == Errors.NOT_COORDINATOR) &#123;</span><br><span class="line">            <span class="comment">// re-discover the coordinator and retry with backoff</span></span><br><span class="line">            markCoordinatorUnknown();</span><br><span class="line">            log.debug(<span class="string">&quot;Attempt to join group failed due to obsolete coordinator information: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.FENCED_INSTANCE_ID) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Received fatal exception: group.instance.id gets fenced&quot;</span>);</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.INCONSISTENT_GROUP_PROTOCOL</span><br><span class="line">                || error == Errors.INVALID_SESSION_TIMEOUT</span><br><span class="line">                || error == Errors.INVALID_GROUP_ID</span><br><span class="line">                || error == Errors.GROUP_AUTHORIZATION_FAILED</span><br><span class="line">                || error == Errors.GROUP_MAX_SIZE_REACHED) &#123;</span><br><span class="line">            <span class="comment">// log the error and re-throw the exception</span></span><br><span class="line">            log.error(<span class="string">&quot;Attempt to join group failed due to fatal error: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">            <span class="keyword">if</span> (error == Errors.GROUP_MAX_SIZE_REACHED) &#123;</span><br><span class="line">                future.raise(<span class="keyword">new</span> GroupMaxSizeReachedException(groupId));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</span><br><span class="line">                future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNSUPPORTED_VERSION) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Attempt to join group failed due to unsupported version error. Please unset field group.instance.id and retry&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;to see if the problem resolves&quot;</span>);</span><br><span class="line">            future.raise(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.MEMBER_ID_REQUIRED) &#123;</span><br><span class="line">            <span class="comment">// Broker requires a concrete member id to be allowed to join the group. Update member id</span></span><br><span class="line">            <span class="comment">// and send another join group request in next cycle.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.generation = <span class="keyword">new</span> Generation(OffsetCommitRequest.DEFAULT_GENERATION_ID,</span><br><span class="line">                        joinResponse.data().memberId(), <span class="keyword">null</span>);</span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.rejoinNeeded = <span class="keyword">true</span>;</span><br><span class="line">                AbstractCoordinator.<span class="keyword">this</span>.state = MemberState.UNJOINED;</span><br><span class="line">            &#125;</span><br><span class="line">            future.raise(Errors.MEMBER_ID_REQUIRED);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// unexpected error, throw the exception</span></span><br><span class="line">            log.error(<span class="string">&quot;Attempt to join group failed due to unexpected error: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">            future.raise(<span class="keyword">new</span> KafkaException(<span class="string">&quot;Unexpected error in join group response: &quot;</span> + error.message()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的主要过程如下：</p>
<ol>
<li>如果 group 是新的 <code>group.id</code>，那么此时 group 初始化的状态为 <strong>Empty</strong>；</li>
<li>当 GroupCoordinator 接收到 consumer 的 join-group 请求后，由于此时这个 group 的 member 列表还是空 (group 是新建的，每个 consumer 实例被称为这个 group 的一个 member)，<strong>第一个加入的 member 将被选为 leader</strong>，也就是说，对于一个新的 consumer group 而言，当第一个 consumer 实例加入后将会被选为 leader。如果后面 leader 挂了，会从其他 member 里面随机选择一个 member 成为新的 leader；</li>
<li>如果 GroupCoordinator 接收到 leader 发送 join-group 请求，将会触发 rebalance，group 的状态变为 <strong>PreparingRebalance</strong>；</li>
<li>此时，GroupCoordinator 将会等待一定的时间，如果在一定时间内，接收到 join-group 请求的 consumer 将被认为是依然存活的，此时 group 会变为 <strong>AwaitSync</strong> 状态，并且 GroupCoordinator 会向这个 group 的所有 member 返回其 response；</li>
<li>consumer 在接收到 GroupCoordinator 的 response 后，如果这个 consumer 是 group 的 leader，那么这个 consumer 将会负责为整个 group assign partition 订阅安排（默认是按 range 的策略，目前也可选 roundrobin），然后 leader 将分配后的信息以 <code>sendSyncGroupRequest ()</code> 请求的方式发给 GroupCoordinator，而作为 follower 的 consumer 实例会发送一个空列表；</li>
<li>GroupCoordinator 在接收到 leader 发来的请求后，会将 assign 的结果返回给所有已经发送 sync-group 请求的 consumer 实例，并且 group 的状态将会转变为 <strong>Stable</strong>，如果后续再收到 sync-group 请求，由于 group 的状态已经是 Stable，将会直接返回其分配结果。</li>
</ol>
<p>sync-group 发送请求核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当consumer为follower时，从GroupCoordinator拉取分配结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">onJoinFollower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// send follower&#x27;s sync group with an empty assignment</span></span><br><span class="line">    SyncGroupRequest.Builder requestBuilder =</span><br><span class="line">            <span class="keyword">new</span> SyncGroupRequest.Builder(</span><br><span class="line">                    <span class="keyword">new</span> SyncGroupRequestData()</span><br><span class="line">                            .setGroupId(groupId)</span><br><span class="line">                            .setMemberId(generation.memberId)</span><br><span class="line">                            .setGroupInstanceId(<span class="keyword">this</span>.groupInstanceId.orElse(<span class="keyword">null</span>))</span><br><span class="line">                            .setGenerationId(generation.generationId)</span><br><span class="line">                            .setAssignments(Collections.emptyList())</span><br><span class="line">            );</span><br><span class="line">    log.debug(<span class="string">&quot;Sending follower SyncGroup to coordinator &#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">this</span>.coordinator, requestBuilder);</span><br><span class="line">    <span class="comment">// 发送sync-group请求</span></span><br><span class="line">    <span class="keyword">return</span> sendSyncGroupRequest(requestBuilder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当consumer客户端为leader时，对group下的所有实例进行分配，将assign的结果发送到GroupCoordinator</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">onJoinLeader</span><span class="params">(JoinGroupResponse joinResponse)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// perform the leader synchronization and send back the assignment for the group(assign 操作)</span></span><br><span class="line">        Map&lt;String, ByteBuffer&gt; groupAssignment = performAssignment(joinResponse.data().leader(), joinResponse.data().protocolName(),</span><br><span class="line">                joinResponse.data().members());</span><br><span class="line"></span><br><span class="line">        List&lt;SyncGroupRequestData.SyncGroupRequestAssignment&gt; groupAssignmentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, ByteBuffer&gt; assignment : groupAssignment.entrySet()) &#123;</span><br><span class="line">            groupAssignmentList.add(<span class="keyword">new</span> SyncGroupRequestData.SyncGroupRequestAssignment()</span><br><span class="line">                    .setMemberId(assignment.getKey())</span><br><span class="line">                    .setAssignment(Utils.toArray(assignment.getValue()))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SyncGroupRequest.Builder requestBuilder =</span><br><span class="line">                <span class="keyword">new</span> SyncGroupRequest.Builder(</span><br><span class="line">                        <span class="keyword">new</span> SyncGroupRequestData()</span><br><span class="line">                                .setGroupId(groupId)</span><br><span class="line">                                .setMemberId(generation.memberId)</span><br><span class="line">                                .setGroupInstanceId(<span class="keyword">this</span>.groupInstanceId.orElse(<span class="keyword">null</span>))</span><br><span class="line">                                .setGenerationId(generation.generationId)</span><br><span class="line">                                .setAssignments(groupAssignmentList)</span><br><span class="line">                );</span><br><span class="line">        log.debug(<span class="string">&quot;Sending leader SyncGroup to coordinator &#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">this</span>.coordinator, requestBuilder);</span><br><span class="line">        <span class="comment">// 发送sync-group请求</span></span><br><span class="line">        <span class="keyword">return</span> sendSyncGroupRequest(requestBuilder);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> RequestFuture.failure(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送SyncGroup请求，获取对partition分配的安排</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">sendSyncGroupRequest</span><span class="params">(SyncGroupRequest.Builder requestBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coordinatorUnknown())</span><br><span class="line">        <span class="keyword">return</span> RequestFuture.coordinatorNotAvailable();</span><br><span class="line">    <span class="keyword">return</span> client.send(coordinator, requestBuilder)</span><br><span class="line">            .compose(<span class="keyword">new</span> SyncGroupResponseHandler());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncGroupResponseHandler</span> <span class="keyword">extends</span> <span class="title">CoordinatorResponseHandler</span>&lt;<span class="title">SyncGroupResponse</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(SyncGroupResponse syncResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                       RequestFuture&lt;ByteBuffer&gt; future)</span> </span>&#123;</span><br><span class="line">        Errors error = syncResponse.error();</span><br><span class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">            <span class="comment">// sync-group成功</span></span><br><span class="line">            sensors.syncLatency.record(response.requestLatencyMs());</span><br><span class="line">            future.complete(ByteBuffer.wrap(syncResponse.data.assignment()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// join的标志位设置为true</span></span><br><span class="line">            requestRejoin();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</span><br><span class="line">                future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.REBALANCE_IN_PROGRESS) &#123;</span><br><span class="line">                <span class="comment">// group正在进行rebalance，任务失败</span></span><br><span class="line">                log.debug(<span class="string">&quot;SyncGroup failed because the group began another rebalance&quot;</span>);</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.FENCED_INSTANCE_ID) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Received fatal exception: group.instance.id gets fenced&quot;</span>);</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_MEMBER_ID</span><br><span class="line">                    || error == Errors.ILLEGAL_GENERATION) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;SyncGroup failed: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">                resetGeneration();</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.COORDINATOR_NOT_AVAILABLE</span><br><span class="line">                    || error == Errors.NOT_COORDINATOR) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;SyncGroup failed: &#123;&#125;&quot;</span>, error.message());</span><br><span class="line">                markCoordinatorUnknown();</span><br><span class="line">                future.raise(error);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future.raise(<span class="keyword">new</span> KafkaException(<span class="string">&quot;Unexpected error from SyncGroup: &quot;</span> + error.message()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个阶段主要是将分区分配方案同步给各个消费者，这个同步仍然是通过 GroupCoordinator 来转发的。</p>
<blockquote>
<p>分区策略并非由 leader 消费者来决定，而是各个消费者投票决定的，谁的票多就采用什么分区策略。这里的分区策略是通过 <code>partition.assignment.strategy</code> 参数设置的，可以设置多个。如果选举出了消费者不支持的策略，那么就会抛出异常 <code>IllegalArgumentException: Member does not support protocol</code>。</p>
</blockquote>
<p>经过上面的步骤，一个 consumer 实例就已经加入 group 成功了，加入 group 成功后，将会触发 ConsumerCoordinator 的 <code>onJoinComplete ()</code> 方法，其作用就是：更新订阅的 tp 列表、更新其对应的 metadata 及触发注册的 listener。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入group成功</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onJoinComplete</span><span class="params">(<span class="keyword">int</span> generation,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String memberId,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String assignmentStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ByteBuffer assignmentBuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// only the leader is responsible for monitoring for metadata changes (i.e. partition changes)</span></span><br><span class="line">    <span class="keyword">if</span> (!isLeader)</span><br><span class="line">        assignmentSnapshot = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    PartitionAssignor assignor = lookupAssignor(assignmentStrategy);</span><br><span class="line">    <span class="keyword">if</span> (assignor == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Coordinator selected invalid assignment protocol: &quot;</span> + assignmentStrategy);</span><br><span class="line"></span><br><span class="line">    Assignment assignment = ConsumerProtocol.deserializeAssignment(assignmentBuffer);</span><br><span class="line">    <span class="keyword">if</span> (!subscriptions.assignFromSubscribed(assignment.partitions())) &#123;</span><br><span class="line">        handleAssignmentMismatch(assignment);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;TopicPartition&gt; assignedPartitions = subscriptions.assignedPartitions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The leader may have assigned partitions which match our subscription pattern, but which</span></span><br><span class="line">    <span class="comment">// were not explicitly requested, so we update the joined subscription here.</span></span><br><span class="line">    maybeUpdateJoinedSubscription(assignedPartitions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give the assignor a chance to update internal state based on the received assignment</span></span><br><span class="line">    assignor.onAssignment(assignment, generation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reschedule the auto commit starting from now</span></span><br><span class="line">    <span class="keyword">if</span> (autoCommitEnabled)</span><br><span class="line">        <span class="keyword">this</span>.nextAutoCommitTimer.updateAndReset(autoCommitIntervalMs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execute the user&#x27;s callback after rebalance</span></span><br><span class="line">    ConsumerRebalanceListener listener = subscriptions.rebalanceListener();</span><br><span class="line">    log.info(<span class="string">&quot;Setting newly assigned partitions: &#123;&#125;&quot;</span>, Utils.join(assignedPartitions, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listener.onPartitionsAssigned(assignedPartitions);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WakeupException | InterruptException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;User provided listener &#123;&#125; failed on partition assignment&quot;</span>, listener.getClass().getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，一个 consumer 实例算是真正上意义上加入 group 成功。</p>
<p>然后 consumer 就进入正常工作状态，同时 consumer 也通过向 GroupCoordinator 发送心跳来维持它们与消费者组的从属关系，以及它们对分区的所有权关系。只要以正常的间隔发送心跳，就被认为是活跃的，但是如果 GroupCoordinator 没有响应，那么就会发送 LeaveGroup 请求退出消费者组。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="http://generalthink.github.io/2019/05/15/how-to-join-kafka-consumer-group/">http://generalthink.github.io/2019/05/15/how-to-join-kafka-consumer-group/</a></p>
<p><a target="_blank" rel="noopener" href="https://matt33.com/2017/10/22/consumer-join-group/">https://matt33.com/2017/10/22/consumer-join-group/</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:&#119;&#x64;&#115;&#104;&#x66;&#117;&#116;&#64;&#x31;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;">&#119;&#x64;&#115;&#104;&#x66;&#117;&#116;&#64;&#x31;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Kafka/" rel="tag"># Kafka</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/30/kafka-properties/" rel="prev" title="Kafka 的核心配置参数">
      <i class="fa fa-chevron-left"></i> Kafka 的核心配置参数
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/10/ouyangxiu/" rel="next" title="欧阳修">
      欧阳修 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#KafkaConsumer-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">KafkaConsumer 消费消息的主体流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-KafkaConsumer"><span class="nav-number">1.1.</span> <span class="nav-text">创建 KafkaConsumer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A2%E9%98%85-topic"><span class="nav-number">1.2.</span> <span class="nav-text">订阅 topic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.</span> <span class="nav-text">从服务器拉取数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KafkaConsumer-%E5%A6%82%E4%BD%95%E5%8A%A0%E5%85%A5-consumer-group"><span class="nav-number">2.</span> <span class="nav-text">KafkaConsumer 如何加入 consumer group</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ensureCoordinatorReady"><span class="nav-number">2.1.</span> <span class="nav-text">ensureCoordinatorReady</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ensureActiveGroup"><span class="nav-number">2.2.</span> <span class="nav-text">ensureActiveGroup</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">本文参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XiSun"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">XiSun</p>
  <div class="site-description" itemprop="description">心如止水者，虽世间繁华之红尘纷扰，已然空无一物</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiSun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">119k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
