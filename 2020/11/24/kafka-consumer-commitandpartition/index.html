<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="紧接着上篇文章，这篇文章讲述 consumer 提供的 offset commit 机制和 partition 分配机制，具体如何使用是需要用户结合具体的场景进行选择，本文讲述一下其底层实现。 自动 offset commit 机制1234&#x2F;&#x2F; 自动提交，默认trueprops.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);&#x2F;&#x2F; 设置自">
<meta property="og:type" content="article">
<meta property="og:title" content="KafkaConsumer 源码之 consumer 的 offset commit 机制和 partition 分配机制">
<meta property="og:url" content="http://example.com/2020/11/24/kafka-consumer-commitandpartition/index.html">
<meta property="og:site_name" content="XiSun的博客">
<meta property="og:description" content="紧接着上篇文章，这篇文章讲述 consumer 提供的 offset commit 机制和 partition 分配机制，具体如何使用是需要用户结合具体的场景进行选择，本文讲述一下其底层实现。 自动 offset commit 机制1234&#x2F;&#x2F; 自动提交，默认trueprops.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);&#x2F;&#x2F; 设置自">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2020/11/24/kafka-consumer-commitandpartition/image-20201124154403249.png">
<meta property="og:image" content="http://example.com/2020/11/24/kafka-consumer-commitandpartition/image-20201124162306959.png">
<meta property="article:published_time" content="2020-11-24T07:17:06.000Z">
<meta property="article:modified_time" content="2021-01-05T07:32:30.026Z">
<meta property="article:author" content="XiSun">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/24/kafka-consumer-commitandpartition/image-20201124154403249.png">

<link rel="canonical" href="http://example.com/2020/11/24/kafka-consumer-commitandpartition/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>KafkaConsumer 源码之 consumer 的 offset commit 机制和 partition 分配机制 | XiSun的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiSun的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learning is endless</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/kafka-consumer-commitandpartition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          KafkaConsumer 源码之 consumer 的 offset commit 机制和 partition 分配机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 15:17:06" itemprop="dateCreated datePublished" datetime="2020-11-24T15:17:06+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-05 15:32:30" itemprop="dateModified" datetime="2021-01-05T15:32:30+08:00">2021-01-05</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>紧接着上篇文章，这篇文章讲述 consumer 提供的 offset commit 机制和 partition 分配机制，具体如何使用是需要用户结合具体的场景进行选择，本文讲述一下其底层实现。</p>
<h2 id="自动-offset-commit-机制"><a href="#自动-offset-commit-机制" class="headerlink" title="自动 offset commit 机制"></a>自动 offset commit 机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动提交，默认true</span></span><br><span class="line">props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">// 设置自动每1s提交一次，默认为5s</span></span><br><span class="line">props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过上面设置，启动自动提交 offset 以及设置自动提交间隔时间。</p>
<h2 id="手动-offset-commit-机制"><a href="#手动-offset-commit-机制" class="headerlink" title="手动 offset commit 机制"></a>手动 offset commit 机制</h2><p>先看下两种不同的手动 offset commit 机制，一种是同步 commit，一种是异步 commit，既然其作用都是 offset commit，应该不难猜到它们底层使用接口都是一样的，其调用流程如下图所示：</p>
<p><img src="/2020/11/24/kafka-consumer-commitandpartition/image-20201124154403249.png" alt="image-20201124154403249"></p>
<h3 id="同步-commit"><a href="#同步-commit" class="headerlink" title="同步 commit"></a>同步 commit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对poll()中返回的所有topics和partition列表进行commit</span></span><br><span class="line"><span class="comment">// 这个方法只能将offset提交Kafka中，Kafka将会在每次rebalance之后的第一次拉取或启动时使用同步commit</span></span><br><span class="line"><span class="comment">// 这是同步commit，它将会阻塞进程，直到commit成功或者遇到一些错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitSync</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只对指定的topic-partition列表进行commit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitSync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其实，从上图中，就已经可以看出，同步 commit 的实现方式，<code>client.poll ()</code> 方法会阻塞直到这个 request 完成或超时才会返回。</p>
<h3 id="异步-commit"><a href="#异步-commit" class="headerlink" title="异步 commit"></a>异步 commit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">(OffsetCommitCallback callback)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback callback)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于异步的 commit，最后调用的都是 <code>doCommitOffsetsAsync ()</code> 方法，其具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommitOffsetsAsync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, <span class="keyword">final</span> OffsetCommitCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送offset-commit请求</span></span><br><span class="line">    RequestFuture&lt;Void&gt; future = sendOffsetCommitRequest(offsets);</span><br><span class="line">    <span class="keyword">final</span> OffsetCommitCallback cb = callback == <span class="keyword">null</span> ? defaultOffsetCommitCallback : callback;</span><br><span class="line">    future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Void value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (interceptors != <span class="keyword">null</span>)</span><br><span class="line">                interceptors.onCommit(offsets);</span><br><span class="line">            <span class="comment">// 添加成功的请求，以唤醒相应的回调函数</span></span><br><span class="line">            completedOffsetCommits.add(<span class="keyword">new</span> OffsetCommitCompletion(cb, offsets, <span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">            Exception commitException = e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RetriableException) &#123;</span><br><span class="line">                commitException = <span class="keyword">new</span> RetriableCommitFailedException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加失败的请求，以唤醒相应的回调函数</span></span><br><span class="line">            completedOffsetCommits.add(<span class="keyword">new</span> OffsetCommitCompletion(cb, offsets, commitException));</span><br><span class="line">            <span class="keyword">if</span> (commitException <span class="keyword">instanceof</span> FencedInstanceIdException) &#123;</span><br><span class="line">                asyncCommitFenced.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在异步 commit 中，可以添加相应的回调函数，如果 request 处理成功或处理失败，ConsumerCoordinator 会通过 <code>invokeCompletedOffsetCommitCallbacks ()</code> 方法唤醒相应的回调函数。</p>
<blockquote>
<p>上面简单的介绍了同步 commit 和异步 commit，更详细的分析参考：<a target="_blank" rel="noopener" href="http://generalthink.github.io/2019/06/04/kafka-consumer-offset-commit/">Kafka consumer 的 offset 的提交方式</a>。</p>
<p>注意：手动 commit 时，提交的是下一次要读取的 offset。举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(running) &#123;</span><br><span class="line">           <span class="comment">// 取得消息</span></span><br><span class="line">           ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">           <span class="comment">// 根据分区来遍历数据</span></span><br><span class="line">           <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">               List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line">               <span class="comment">// 数据处理</span></span><br><span class="line">               <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords) &#123;</span><br><span class="line">                   System.out.println(record.offset() + <span class="string">&quot;: &quot;</span> + record.value());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 取得当前读取到的最后一条记录的offset</span></span><br><span class="line">               <span class="keyword">long</span> lastOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">               <span class="comment">// 提交offset，记得要 + 1</span></span><br><span class="line">               consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(lastOffset + <span class="number">1</span>)));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   	consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="commit-offset-请求的处理"><a href="#commit-offset-请求的处理" class="headerlink" title="commit offset 请求的处理"></a>commit offset 请求的处理</h3><p>当 Kafka Server 端接收到来自 client 端的 offset commit 请求时，对于提交的 offset，GroupCoordinator 会记录在 GroupMetadata 对象中，至于其实现的逻辑细节，此处不再赘述。</p>
<h2 id="partition-分配机制"><a href="#partition-分配机制" class="headerlink" title="partition 分配机制"></a>partition 分配机制</h2><p>consumer 提供了三种不同的 partition 分配策略，可以通过 <code>partition.assignment.strategy</code> 参数进行配置，默认情况下使用的是 <code>org.apache.kafka.clients.consumer.RangeAssignor</code>，Kafka 中提供了另外两种 partition 的分配策略 <code>org.apache.kafka.clients.consumer.RoundRobinAssignor</code> 和 <code>org.apache.kafka.clients.consumer.StickyAssignor</code>，它们关系如下图所示：</p>
<p><img src="/2020/11/24/kafka-consumer-commitandpartition/image-20201124162306959.png" alt="image-20201124162306959"></p>
<p>通过上图可以看出，用户可以自定义相应的 partition 分配机制，只需要继承这个 AbstractPartitionAssignor 抽象类即可。</p>
<blockquote>
<p>partition 分配策略，其实也就是 reblance 策略。</p>
</blockquote>
<h3 id="AbstractPartitionAssignor"><a href="#AbstractPartitionAssignor" class="headerlink" title="AbstractPartitionAssignor"></a>AbstractPartitionAssignor</h3><p>AbstractPartitionAssignor 有一个抽象方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Perform the group assignment given the partition counts and member subscriptions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> partitionsPerTopic The number of partitions for each subscribed topic. Topics not in metadata will be excluded</span></span><br><span class="line"><span class="comment"> *                           from this map.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subscriptions Map from the memberId to their respective topic subscription</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Map from each member to the list of partitions assigned to them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 根据partitionsPerTopic和subscriptions进行分配，具体的实现会在子类中实现(不同的子类，其实现方法不相同)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                         Map&lt;String, Subscription&gt; subscriptions);</span><br></pre></td></tr></table></figure>

<p><code>assign ()</code> 这个方法，有两个参数：</p>
<ul>
<li><code>partitionsPerTopic</code>：所订阅的每个 topic 与其 partition 数的对应关系，metadata 没有的 topic 将会被移除；</li>
<li><code>subscriptions</code>：每个 consumerId 与其所订阅的 topic 列表的关系。</li>
</ul>
<p>继承 AbstractPartitionAssignor 的子类，通过实现 <code>assign ()</code> 方法，来进行相应的 partition 分配。</p>
<h3 id="RangeAssignor-分配模式"><a href="#RangeAssignor-分配模式" class="headerlink" title="RangeAssignor 分配模式"></a>RangeAssignor 分配模式</h3><p><code>assign ()</code> 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                Map&lt;String, Subscription&gt; subscriptions) &#123;</span><br><span class="line">    <span class="comment">// 1.参数含义:(topic, List&lt;consumerId&gt;)，获取每个topic被多少个consumer订阅了</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; consumersPerTopic = consumersPerTopic(subscriptions);</span><br><span class="line">    <span class="comment">// 2.存储最终的分配方案</span></span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">        assignment.put(memberId, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; topicEntry : consumersPerTopic.entrySet()) &#123;</span><br><span class="line">        String topic = topicEntry.getKey();</span><br><span class="line">        List&lt;String&gt; consumersForTopic = topicEntry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.每个topic的partition数量</span></span><br><span class="line">        Integer numPartitionsForTopic = partitionsPerTopic.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (numPartitionsForTopic == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Collections.sort(consumersForTopic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.取商，表示平均每个consumer会分配到多少个partition</span></span><br><span class="line">        <span class="keyword">int</span> numPartitionsPerConsumer = numPartitionsForTopic / consumersForTopic.size();</span><br><span class="line">        <span class="comment">// 5.取余，表示平均分配后还剩下多少个partition未被分配</span></span><br><span class="line">        <span class="keyword">int</span> consumersWithExtraPartition = numPartitionsForTopic % consumersForTopic.size();</span><br><span class="line"></span><br><span class="line">        List&lt;TopicPartition&gt; partitions = AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic);</span><br><span class="line">        <span class="comment">// 6.这里是关键点，分配原则是将未能被平均分配的partition分配到前consumersWithExtraPartition个consumer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = consumersForTopic.size(); i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 假设partition有7个，consumer有5个，则numPartitionsPerConsumer=1，consumersWithExtraPartition=2</span></span><br><span class="line">            <span class="comment">// i=0, start: 0, length: 2, topic-partition: p0, p1</span></span><br><span class="line">            <span class="comment">// i=1, start: 2, length: 2, topic-partition: p2, p3</span></span><br><span class="line">            <span class="comment">// i=2, start: 4, length: 1, topic-partition: p4</span></span><br><span class="line">            <span class="comment">// i=3, start: 5, length: 1, topic-partition: p5</span></span><br><span class="line">            <span class="comment">// i=4, start: 6, length: 1, topic-partition: p6</span></span><br><span class="line">            <span class="keyword">int</span> start = numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition);</span><br><span class="line">            <span class="keyword">int</span> length = numPartitionsPerConsumer + (i + <span class="number">1</span> &gt; consumersWithExtraPartition ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            assignment.get(consumersForTopic.get(i)).addAll(partitions.subList(start, start + length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 topic 的 partition 数为 <code>numPartitionsForTopic</code>，group 中订阅这个 topic 的 member 数为 <code>consumersForTopic.size()</code>，首先需要算出两个值：</p>
<ul>
<li><code>numPartitionsPerConsumer = numPartitionsForTopic / consumersForTopic.size()</code>：表示平均每个 consumer 会分配到几个 partition；</li>
<li><code>consumersWithExtraPartition = numPartitionsForTopic % consumersForTopic.size()</code>：表示平均分配后还剩下多少个 partition 未分配。</li>
</ul>
<p>分配的规则是：对于剩下的那些 partition 分配到前 consumersWithExtraPartition 个 consumer 上，也就是前 consumersWithExtraPartition 个 consumer 获得 topic-partition 列表会比后面多一个。</p>
<p>在上述的程序中，举了一个例子，假设有一个 topic 有 7 个 partition，group 有5个 consumer，这个5个 consumer 都订阅这个 topic，那么 range 的分配方式如下：</p>
<table>
<thead>
<tr>
<th>消费者</th>
<th>分配方案</th>
</tr>
</thead>
<tbody><tr>
<td>consumer 0</td>
<td>start: 0, length: 2, topic-partition: p0, p1</td>
</tr>
<tr>
<td>consumer 1</td>
<td>start: 2, length: 2, topic-partition: p2, p3</td>
</tr>
<tr>
<td>consumer 2</td>
<td>start: 4, length: 1, topic-partition: p4</td>
</tr>
<tr>
<td>consumer 3</td>
<td>start: 5, length: 1, topic-partition: p5</td>
</tr>
<tr>
<td>consumer 4</td>
<td>start: 6, length: 1, topic-partition: p6</td>
</tr>
</tbody></table>
<p>而如果 group 中有 consumer 没有订阅这个 topic，那么这个 consumer 将不会参与分配。下面再举个例子，假设有 2 个 topic，一个有 5 个 partition，另一个有 7 个 partition，group 中有 5 个 consumer，但是只有前 3 个订阅第一个 topic，而另一个 topic 是所有 consumer 都订阅了，那么其分配结果如下：</p>
<table>
<thead>
<tr>
<th>consumer</th>
<th>订阅 topic1 的列表</th>
<th>订阅 topic2 的列表</th>
</tr>
</thead>
<tbody><tr>
<td>consumer 0</td>
<td>t1 p0, t1 p1</td>
<td>t2 p0, t2 p1</td>
</tr>
<tr>
<td>consumer 1</td>
<td>t1 p2, t1 p3</td>
<td>t2 p2, t2 p3</td>
</tr>
<tr>
<td>consumer 2</td>
<td>t1 p4</td>
<td>t2 p4</td>
</tr>
<tr>
<td>consumer 3</td>
<td></td>
<td>t2 p5</td>
</tr>
<tr>
<td>consumer 4</td>
<td></td>
<td>t2 p6</td>
</tr>
</tbody></table>
<h3 id="RoundRobinAssignor"><a href="#RoundRobinAssignor" class="headerlink" title="RoundRobinAssignor"></a>RoundRobinAssignor</h3><p><code>assign ()</code> 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                Map&lt;String, Subscription&gt; subscriptions) &#123;</span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">        assignment.put(memberId, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环状链表，存储所有的consumer，一次迭代完之后又会回到原点</span></span><br><span class="line">    CircularIterator&lt;String&gt; assigner = <span class="keyword">new</span> CircularIterator&lt;&gt;(Utils.sorted(subscriptions.keySet()));</span><br><span class="line">    <span class="comment">// 获取所有订阅的topic的partition总数</span></span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) &#123;</span><br><span class="line">        <span class="keyword">final</span> String topic = partition.topic();</span><br><span class="line">        <span class="keyword">while</span> (!subscriptions.get(assigner.peek()).topics().contains(topic))</span><br><span class="line">            assigner.next();</span><br><span class="line">        assignment.get(assigner.next()).add(partition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TopicPartition&gt; <span class="title">allPartitionsSorted</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                Map&lt;String, Subscription&gt; subscriptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有的topics(有序)</span></span><br><span class="line">    SortedSet&lt;String&gt; topics = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Subscription subscription : subscriptions.values())</span><br><span class="line">        topics.addAll(subscription.topics());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅的Topic的所有的TopicPartition集合</span></span><br><span class="line">    List&lt;TopicPartition&gt; allPartitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String topic : topics) &#123;</span><br><span class="line">        Integer numPartitionsForTopic = partitionsPerTopic.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (numPartitionsForTopic != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// topic的所有partition都添加进去</span></span><br><span class="line">            allPartitions.addAll(AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allPartitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Round Robin 的实现原则，简单来说就是：列出所有 topic-partition 和列出所有的 consumer member，然后开始分配，一轮之后继续下一轮，假设有一个 topic，它有7个 partition，group 中有 3 个 consumer 都订阅了这个 topic，那么其分配方式为：</p>
<table>
<thead>
<tr>
<th>消费者</th>
<th>分配列表</th>
</tr>
</thead>
<tbody><tr>
<td>consumer 0</td>
<td>p0, p3, p6</td>
</tr>
<tr>
<td>consumer 1</td>
<td>p1, p4</td>
</tr>
<tr>
<td>consumer 2</td>
<td>p2, p5</td>
</tr>
</tbody></table>
<p>对于多个 topic 的订阅，假设有 2 个 topic，一个有 5 个 partition，一个有 7 个 partition，group 中有 5 个 consumer，但是只有前 3 个订阅第一个 topic，而另一个 topic 是所有 consumer 都订阅了，那么其分配结果如下：</p>
<table>
<thead>
<tr>
<th>消费者</th>
<th>订阅 topic1 的列表</th>
<th>订阅的 topic2 的列表</th>
</tr>
</thead>
<tbody><tr>
<td>consumer 0</td>
<td>t1 p0, t1 p3</td>
<td>t2 p0, t2 p5</td>
</tr>
<tr>
<td>consumer 1</td>
<td>t1 p1, t1 p4</td>
<td>t2 p1, t2 p6</td>
</tr>
<tr>
<td>consumer 2</td>
<td>t1 p2</td>
<td>t2 p2</td>
</tr>
<tr>
<td>consumer 3</td>
<td></td>
<td>t2 p3</td>
</tr>
<tr>
<td>consumer 4</td>
<td></td>
<td>t2 p4</td>
</tr>
</tbody></table>
<h3 id="StickyAssignor"><a href="#StickyAssignor" class="headerlink" title="StickyAssignor"></a>StickyAssignor</h3><p><code>assign ()</code> 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                Map&lt;String, Subscription&gt; subscriptions) &#123;</span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; currentAssignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;TopicPartition, ConsumerGenerationPair&gt; prevAssignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    partitionMovements = <span class="keyword">new</span> PartitionMovements();</span><br><span class="line"></span><br><span class="line">    prepopulateCurrentAssignments(subscriptions, currentAssignment, prevAssignment);</span><br><span class="line">    <span class="keyword">boolean</span> isFreshAssignment = currentAssignment.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a mapping of all topic partitions to all consumers that can be assigned to them</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;String&gt;&gt; partition2AllPotentialConsumers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// a mapping of all consumers to all potential topic partitions that can be assigned to them</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; consumer2AllPotentialPartitions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize partition2AllPotentialConsumers and consumer2AllPotentialPartitions in the following two for loops</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry: partitionsPerTopic.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry.getValue(); ++i)</span><br><span class="line">            partition2AllPotentialConsumers.put(<span class="keyword">new</span> TopicPartition(entry.getKey(), i), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Subscription&gt; entry: subscriptions.entrySet()) &#123;</span><br><span class="line">        String consumer = entry.getKey();</span><br><span class="line">        consumer2AllPotentialPartitions.put(consumer, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        entry.getValue().topics().stream().filter(topic -&gt; partitionsPerTopic.get(topic) != <span class="keyword">null</span>).forEach(topic -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; partitionsPerTopic.get(topic); ++i) &#123;</span><br><span class="line">                TopicPartition topicPartition = <span class="keyword">new</span> TopicPartition(topic, i);</span><br><span class="line">                consumer2AllPotentialPartitions.get(consumer).add(topicPartition);</span><br><span class="line">                partition2AllPotentialConsumers.get(topicPartition).add(consumer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add this consumer to currentAssignment (with an empty topic partition assignment) if it does not already exist</span></span><br><span class="line">        <span class="keyword">if</span> (!currentAssignment.containsKey(consumer))</span><br><span class="line">            currentAssignment.put(consumer, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a mapping of partition to current consumer</span></span><br><span class="line">    Map&lt;TopicPartition, String&gt; currentPartitionConsumer = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;TopicPartition&gt;&gt; entry: currentAssignment.entrySet())</span><br><span class="line">        <span class="keyword">for</span> (TopicPartition topicPartition: entry.getValue())</span><br><span class="line">            currentPartitionConsumer.put(topicPartition, entry.getKey());</span><br><span class="line"></span><br><span class="line">    List&lt;TopicPartition&gt; sortedPartitions = sortPartitions(</span><br><span class="line">            currentAssignment, prevAssignment.keySet(), isFreshAssignment, partition2AllPotentialConsumers, consumer2AllPotentialPartitions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all partitions that need to be assigned (initially set to all partitions but adjusted in the following loop)</span></span><br><span class="line">    List&lt;TopicPartition&gt; unassignedPartitions = <span class="keyword">new</span> ArrayList&lt;&gt;(sortedPartitions);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;String, List&lt;TopicPartition&gt;&gt;&gt; it = currentAssignment.entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">        Map.Entry&lt;String, List&lt;TopicPartition&gt;&gt; entry = it.next();</span><br><span class="line">        <span class="keyword">if</span> (!subscriptions.containsKey(entry.getKey())) &#123;</span><br><span class="line">            <span class="comment">// if a consumer that existed before (and had some partition assignments) is now removed, remove it from currentAssignment</span></span><br><span class="line">            <span class="keyword">for</span> (TopicPartition topicPartition: entry.getValue())</span><br><span class="line">                currentPartitionConsumer.remove(topicPartition);</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// otherwise (the consumer still exists)</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;TopicPartition&gt; partitionIter = entry.getValue().iterator(); partitionIter.hasNext();) &#123;</span><br><span class="line">                TopicPartition partition = partitionIter.next();</span><br><span class="line">                <span class="keyword">if</span> (!partition2AllPotentialConsumers.containsKey(partition)) &#123;</span><br><span class="line">                    <span class="comment">// if this topic partition of this consumer no longer exists remove it from currentAssignment of the consumer</span></span><br><span class="line">                    partitionIter.remove();</span><br><span class="line">                    currentPartitionConsumer.remove(partition);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!subscriptions.get(entry.getKey()).topics().contains(partition.topic())) &#123;</span><br><span class="line">                    <span class="comment">// if this partition cannot remain assigned to its current consumer because the consumer</span></span><br><span class="line">                    <span class="comment">// is no longer subscribed to its topic remove it from currentAssignment of the consumer</span></span><br><span class="line">                    partitionIter.remove();</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// otherwise, remove the topic partition from those that need to be assigned only if</span></span><br><span class="line">                    <span class="comment">// its current consumer is still subscribed to its topic (because it is already assigned</span></span><br><span class="line">                    <span class="comment">// and we would want to preserve that assignment as much as possible)</span></span><br><span class="line">                    unassignedPartitions.remove(partition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// at this point we have preserved all valid topic partition to consumer assignments and removed</span></span><br><span class="line">    <span class="comment">// all invalid topic partitions and invalid consumers. Now we need to assign unassignedPartitions</span></span><br><span class="line">    <span class="comment">// to consumers so that the topic partition assignments are as balanced as possible.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// an ascending sorted set of consumers based on how many topic partitions are already assigned to them</span></span><br><span class="line">    TreeSet&lt;String&gt; sortedCurrentSubscriptions = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> SubscriptionComparator(currentAssignment));</span><br><span class="line">    sortedCurrentSubscriptions.addAll(currentAssignment.keySet());</span><br><span class="line"></span><br><span class="line">    balance(currentAssignment, prevAssignment, sortedPartitions, unassignedPartitions, sortedCurrentSubscriptions,</span><br><span class="line">            consumer2AllPotentialPartitions, partition2AllPotentialConsumers, currentPartitionConsumer);</span><br><span class="line">    <span class="keyword">return</span> currentAssignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sticky 分区策略是从 0.11 版本才开始引入的，它主要有两个目的：</p>
<ol>
<li>分区的分配要尽可能均匀</li>
<li>分区的分配要尽可能与上次分配的保持相同</li>
</ol>
<p>当两者冲突的时候，第一个目标优先于第二个目标。</p>
<p>sticky 的分区方式作用发生分区重分配的时候，尽可能地让前后两次分配相同，进而减少系统资源的损耗及其他异常情况的发生。因为 sticky 分区策略的代码，要比 range 和 roundrobin 复杂很多，此处不做具体的细节分析，只简单举例如下：</p>
<p>假设有 3 个 topic，一个有 2 个 partition，一个有 3 个 partition，另外一个有 4 个 partition，group 中有 3 个 consumer，第一个 consumer 订阅了第一个 topic，第二个 consumer 订阅了前两个 topic，第三个 consumer 订阅了三个 topic，那么它们的分配方案如下：</p>
<table>
<thead>
<tr>
<th>消费者</th>
<th>订阅 topic1 的列表</th>
<th>订阅 topic2 的列表</th>
<th>订阅 topic3 的列表</th>
</tr>
</thead>
<tbody><tr>
<td>consumer1</td>
<td>t1 p0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>consumer2</td>
<td>t1 p1, t2 p1</td>
<td>t2 p0, t2 p3</td>
<td></td>
</tr>
<tr>
<td>consumer3</td>
<td></td>
<td></td>
<td>t3 p0, t3 p1, t3 p2, t3 p3</td>
</tr>
</tbody></table>
<p>上面三个分区策略有着不同的分配方式，在实际使用过程中，需要根据自己的需求选择合适的策略，但是如果你只有一个 consumer，那么选择哪个方式都是一样的，但是如果是多个 consumer 不在同一台设备上进行消费，那么 sticky 方式应该更加合适。</p>
<h3 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h3><p>如之前所说，只需要继承 AbstractPartitionAssignor 并复写其中方法即可 (当然也可以直接实现 PartitionAssignor 接口) 自定义分区策略，其中有两个方法需要复写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                             Map&lt;String, Subscription&gt; subscriptions);</span><br></pre></td></tr></table></figure>

<p>其中 <code>assign ()</code> 方法表示的是分区分配方案的实现，而 <code>name ()</code> 方法则表示了这个分配策略的唯一名称，比如之前提到的 range，roundrobin 和 sticky, 这个名字会在和 GroupCoordinator 的通信中返回，通过它 consumer leader 来确定整个 group 的分区方案 (分区策略是由 group 中的 consumer 共同投票决定的，谁使用的多，就使用哪个策略)。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="http://generalthink.github.io/2019/06/06/kafka-consumer-partition-assign/">http://generalthink.github.io/2019/06/06/kafka-consumer-partition-assign/</a></p>
<p><a target="_blank" rel="noopener" href="https://matt33.com/2017/11/19/consumer-two-summary/">https://matt33.com/2017/11/19/consumer-two-summary/</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>
<p>至此，关于 Kafka 的学习暂时告一段落，未来有需要时，会继续学习。更多关于 Kafka 原理等知识的介绍，参考：</p>
<p><a target="_blank" rel="noopener" href="http://generalthink.github.io/tags/Kafka/">http://generalthink.github.io/tags/Kafka/</a></p>
<p><a target="_blank" rel="noopener" href="https://matt33.com/tags/kafka/">https://matt33.com/tags/kafka/</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Kafka/" rel="tag"># Kafka</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/24/kafka-consumer-subscribeandassign/" rel="prev" title="KafkaConsumer 源码之 consumer 的两种订阅模式">
      <i class="fa fa-chevron-left"></i> KafkaConsumer 源码之 consumer 的两种订阅模式
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/27/java-io/" rel="next" title="Java 的 IO 流">
      Java 的 IO 流 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8-offset-commit-%E6%9C%BA%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">自动 offset commit 机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8-offset-commit-%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">手动 offset commit 机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5-commit"><span class="nav-number">2.1.</span> <span class="nav-text">同步 commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5-commit"><span class="nav-number">2.2.</span> <span class="nav-text">异步 commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-offset-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">commit offset 请求的处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#partition-%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">partition 分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractPartitionAssignor"><span class="nav-number">3.1.</span> <span class="nav-text">AbstractPartitionAssignor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RangeAssignor-%E5%88%86%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">RangeAssignor 分配模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RoundRobinAssignor"><span class="nav-number">3.3.</span> <span class="nav-text">RoundRobinAssignor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StickyAssignor"><span class="nav-number">3.4.</span> <span class="nav-text">StickyAssignor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5"><span class="nav-number">3.5.</span> <span class="nav-text">自定义分区策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">本文参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XiSun"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">XiSun</p>
  <div class="site-description" itemprop="description">心如止水者，虽世间繁华之红尘纷扰，已然空无一物</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiSun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">897k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
