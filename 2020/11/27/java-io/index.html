<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="每次在使用 IO 流之前，应该做到明确分析如下四点：  明确要操作的数据是数据源还是数据目的，也就是要读还是要写；   数据源：InputStream、Reader 数据目的：OutputStream、Writer   明确要操作的设备上的数据是字节还是文本；   数据源：字节 —— InputStream，字符 —— Reader 数据目的：L字节 —— OutputStream，字符 —— W">
<meta property="og:type" content="article">
<meta property="og:title" content="java 的 IO 流">
<meta property="og:url" content="http://example.com/2020/11/27/java-io/index.html">
<meta property="og:site_name" content="XiSun的博客">
<meta property="og:description" content="每次在使用 IO 流之前，应该做到明确分析如下四点：  明确要操作的数据是数据源还是数据目的，也就是要读还是要写；   数据源：InputStream、Reader 数据目的：OutputStream、Writer   明确要操作的设备上的数据是字节还是文本；   数据源：字节 —— InputStream，字符 —— Reader 数据目的：L字节 —— OutputStream，字符 —— W">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b55ba517f0a">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b518cfbd082">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b518d0b6007">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b518d03dfc0">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b518d3549a2">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b518d2e797b">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b5194c7004e">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b5193e018a1">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b51938be9da">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b519317184b">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b51b50af9f5">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b51b5b2204d">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b51b8f8fd36">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/16e24b51bb752dbd">
<meta property="og:image" content="http://example.com/2020/11/27/java-io/image-20201214143657619.png">
<meta property="article:published_time" content="2020-11-27T03:33:09.000Z">
<meta property="article:modified_time" content="2021-01-08T04:03:54.147Z">
<meta property="article:author" content="XiSun">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/27/java-io/16e24b55ba517f0a">

<link rel="canonical" href="http://example.com/2020/11/27/java-io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java 的 IO 流 | XiSun的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiSun的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learning is endless</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/27/java-io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="XiSun">
      <meta itemprop="description" content="心如止水者，虽世间繁华之红尘纷扰，已然空无一物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiSun的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java 的 IO 流
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-27 11:33:09" itemprop="dateCreated datePublished" datetime="2020-11-27T11:33:09+08:00">2020-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-08 12:03:54" itemprop="dateModified" datetime="2021-01-08T12:03:54+08:00">2021-01-08</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>44k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>每次在使用 IO 流之前，应该做到明确分析如下四点：</p>
<ul>
<li>明确要操作的数据是数据源还是数据目的，也就是要读还是要写；</li>
</ul>
<blockquote>
<p>数据源：<strong>InputStream、Reader</strong></p>
<p>数据目的：<strong>OutputStream、Writer</strong></p>
</blockquote>
<ul>
<li>明确要操作的设备上的数据是字节还是文本；</li>
</ul>
<blockquote>
<p>数据源：字节 —— <strong>InputStream</strong>，字符 —— <strong>Reader</strong></p>
<p>数据目的：L字节 —— <strong>OutputStream</strong>，字符 —— <strong>Writer</strong></p>
</blockquote>
<ul>
<li>明确数据所在的具体设备；</li>
</ul>
<blockquote>
<p>数据源设备：硬盘 —— 文件 File 开头；内存 —— 数组，字符串；屏幕 —— System.in；网络 —— Scoket</p>
<p>数据目的设备：硬盘 —— 文件 File 开头；内存 —— 数组，字符串；屏幕 —— System.out；网络—— Scoket</p>
</blockquote>
<ul>
<li>明确是否需要额外功能，比如是否需要转换流、高效流等。</li>
</ul>
<blockquote>
<p>需要转换：转换流 —— <strong>InputStreamReader 、OutputStreamWriter</strong></p>
<p>需要高效：缓冲流 —— <strong>Bufferedxxx</strong></p>
<p>多个源：序列流 —— <strong>SequenceInputStream</strong></p>
<p>对象序列化：<strong>ObjectInputStream、ObjectOutputStream</strong></p>
<p>保证数据的输出形式：打印流 —— <strong>PrintStream 、Printwriter</strong></p>
<p>操作基本数据，保证字节原样性：<strong>DataOutputStream、DataInputStream</strong></p>
</blockquote>
<p>到这，先看看 IO 流的分类：</p>
<p><img src="/2020/11/27/java-io/16e24b55ba517f0a" alt="在这里插入图片描述"></p>
<h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>说到 IO 流，也就是输入输出流，从文件出发到文件结束，至始至终都离不开文件，所以 IO 流还得从文件 File 类讲起。</p>
<h3 id="File-概述"><a href="#File-概述" class="headerlink" title="File  概述"></a>File  概述</h3><p><code>java.io.File</code> 类是专门对文件进行操作的类，只能对文件本身进行操作，不能对文件内容进行操作。 <code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<p>怎么理解上面两句话？其实很简单！</p>
<p>第一句就是说 File 跟流无关，File 类不能对文件进行读和写也就是输入和输出！第二句就是说 File 主要表示类似 <code>D:\\文件目录1</code> 与 <code>D:\\文件目录1\\文件.txt</code>，前者是文件夹 (Directory)，后者则是文件 (file)，而 File 类就是操作这两者的类。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在 java 中，一切皆是对象，File 类也不例外，不论是哪个对象都应该从该对象的构造方法说起：</p>
<p><img src="/2020/11/27/java-io/16e24b518cfbd082" alt="img"></p>
<p>我们主要来学习一下比较常用的三个：</p>
<ol>
<li> <code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File 实例。</li>
<li> <code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File 实例。</li>
<li> <code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File 实例。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过文件路径名 </span></span><br><span class="line">String path1 = <span class="string">&quot;D:\\123.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(path1); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过文件路径名</span></span><br><span class="line">String path2 = <span class="string">&quot;D:\\1\\2.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path2);     -------------相当于d:\\<span class="number">1</span>\\<span class="number">2.</span>txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;F:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);  --------相当于f:\\aaa\\bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;F:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child); --------相当于f:\\aaa\\bbb.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>一个 File 对象代表硬盘中实际存在的一个文件或者目录。</p>
</li>
<li><p>File 类构造方法不会检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。</p>
</li>
</ol>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>File 的常用方法主要分为获取功能、获取绝对路径和相对路径功能、判断功能、创建删除功能。</p>
<h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ol>
<li> <code>public String getAbsolutePath()</code> ：返回此 File 的绝对路径名字符串。</li>
<li> <code>public String getPath()</code> ：将此 File 转换为路径名字符串。</li>
<li> <code>public String getName()</code>  ：返回由此 File 表示的文件或目录的名称。</li>
<li> <code>public long length()</code>  ：返回由此 File 表示的文件的长度。</li>
</ol>
<p>以上方法测试，代码如下【注意测试以自己的电脑文件夹为准】：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;f:/test/a.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span> + f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span> + f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span> + f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span> + f.length() + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;f:/test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span> + f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span> + f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span> + f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span> + f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径: f:\test\a.txt</span><br><span class="line">文件构造路径: f:\test\a.txt</span><br><span class="line">文件名称: a.txt</span><br><span class="line">文件长度: <span class="number">7</span>字节</span><br><span class="line">    </span><br><span class="line">目录绝对路径: f:\test</span><br><span class="line">目录构造路径: f:\test</span><br><span class="line">目录名称: test</span><br><span class="line">目录长度: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>length()</code> 方法，表示文件的长度。但是如果 File 对象表示目录，则返回值未指定。</p>
</blockquote>
<h4 id="获取绝对路径和相对路径功能的方法"><a href="#获取绝对路径和相对路径功能的方法" class="headerlink" title="获取绝对路径和相对路径功能的方法"></a>获取绝对路径和相对路径功能的方法</h4><p><strong>绝对路径</strong>：一个完整的路径，以盘符开头，例如 <code>f:/aaa.txt</code>。 </p>
<p><strong>相对路径</strong>：一个简化的路径，不以盘符开头，例如 <code>/aaa.tx</code>。</p>
<blockquote>
<ol>
<li><strong>路径不区分大小写。</strong></li>
<li>路径中的文件名称分隔符 windows 使用反斜杠，反斜杠是转义字符，两个反斜杠代表一个普通的反斜杠。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// d盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\bbb.java</span><br><span class="line">d:\java\bbb.java</span><br></pre></td></tr></table></figure>

<h4 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h4><ol>
<li> <code>public boolean exists()</code> ：此 File 表示的文件或目录是否实际存在。</li>
<li> <code>public boolean isDirectory()</code> ：此 File 表示的是否为目录。 </li>
<li> <code>public boolean isFile()</code> ：此 File 表示的是否为文件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在: &quot;</span> + f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在: &quot;</span> + f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?: &quot;</span> + f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?: &quot;</span> + f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在: <span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在: <span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?: <span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h4 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h4><ol>
<li> <code>public boolean createNewFile()</code> ：文件不存在，创建一个新的空文件并返回 true，文件存在，不创建文件并返回 false。</li>
<li> <code>public boolean delete()</code> ：删除由此 File 表示的文件或目录。</li>
<li> <code>public boolean mkdir()</code> ：创建由此 File 表示的目录。</li>
<li> <code>public boolean mkdirs()</code> ：创建由此 File 表示的目录，包括任何必需但不存在的父目录。</li>
</ol>
<p>其中，<code>mkdir()</code> 和 <code>mkdirs()</code> 方法类似，但 <code>mkdir()</code>，只能创建一级目录，<code>mkdirs()</code> 可以创建多级目录，比如 <code>/a/b/c</code>，所以开发中一般用 <code>mkdirs()</code> 方法。</p>
<blockquote>
<p><code>delete()</code> 方法，如果此 File 表示目录，则目录必须为空才能删除。</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在: &quot;</span> + f.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建: &quot;</span> + f.createNewFile());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建: &quot;</span> + f.createNewFile());<span class="comment">// 已经创建过了所以再使用createNewFile返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在: &quot;</span> + f.exists());<span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2 = <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在: &quot;</span> + f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建: &quot;</span> + f2.mkdir());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在: &quot;</span> + f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3 = <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4 = <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h4><ol>
<li> <code>public String[] list()</code> ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</li>
<li> <code>public File[] listFiles()</code> ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。</li>
</ol>
<p>其中，<code>listFiles()</code> 在获取指定目录下的文件或者文件夹时必须满足下面两个条件：</p>
<ul>
<li><p><strong>指定的目录必须存在；</strong></p>
</li>
<li><p><strong>指定的必须是目录，否则容易引发返回数组为 null，出现 NullPointerException 异常。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;G:\\光标&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 获取当前目录下的文件以及文件夹的名称</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/27/java-io/16e24b518d0b6007" alt="在这里插入图片描述"></p>
<h4 id="递归遍历文件夹下所有文件以及子文件"><a href="#递归遍历文件夹下所有文件以及子文件" class="headerlink" title="递归遍历文件夹下所有文件以及子文件"></a>递归遍历文件夹下所有文件以及子文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归遍历文件夹下所有的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionDirectory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\java专属IO测试&quot;</span>);</span><br><span class="line">        Recursion(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Recursion</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断传入的是否是目录</span></span><br><span class="line">        <span class="keyword">if</span> (!file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 不是目录直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经确保了传入的file是目录</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">// 遍历files</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="comment">// 如果该目录下文件还是个文件夹就再进行递归遍历其子目录</span></span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                Recursion(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果该目录下文件是个文件，则打印对应的名字</span></span><br><span class="line">                System.out.println(f.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初探-IO-流"><a href="#初探-IO-流" class="headerlink" title="初探 IO 流"></a>初探 IO 流</h2><h3 id="什么是-IO"><a href="#什么是-IO" class="headerlink" title="什么是 IO"></a>什么是 IO</h3><p>数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入 input 和输出 output，即流向内存是输入流，流出内存的输出流。</p>
<p>java 中 I/O 操作主要是指使用 <code>java.io</code> 包下的内容，进行输入、输出操作。<strong>输入也叫做读取数据，输出也叫做作写出数据</strong>。</p>
<h3 id="IO-的分类"><a href="#IO-的分类" class="headerlink" title="IO 的分类"></a>IO 的分类</h3><ol>
<li>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</li>
</ol>
<ul>
<li><strong>输入流</strong> ：把数据从<strong>其他设备</strong>上读取到<strong>内存</strong>中的流。</li>
<li><strong>输出流</strong> ：把数据从<strong>内存</strong>中写出到<strong>其他设备</strong>上的流。</li>
</ul>
<ol start="2">
<li>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</li>
</ol>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<p>分类之后对应的超类 (超类也就是父类的意思)：</p>
<table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字节流</strong></td>
<td>字节输入流： <strong>InputStream</strong></td>
<td>字节输出流： <strong>OutputStream</strong></td>
</tr>
<tr>
<td><strong>字符流</strong></td>
<td>字符输入流： <strong>Reader</strong></td>
<td>字符输出流： <strong>Writer</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>这四个类的子类的名称基本都是以其父类名作为子类名的后缀。</strong>如：InputStream 的子类 FileInputStream，Reader 的子类 FileReader。</p>
</blockquote>
<p><img src="/2020/11/27/java-io/16e24b518d03dfc0" alt="在这里插入图片描述"></p>
<h3 id="关于-IO-的分流向说明"><a href="#关于-IO-的分流向说明" class="headerlink" title="关于 IO 的分流向说明"></a>关于 IO 的分流向说明</h3><p><img src="/2020/11/27/java-io/16e24b518d3549a2" alt="img"></p>
<p><img src="/2020/11/27/java-io/16e24b518d2e797b" alt="img"></p>
<h2 id="字节流-InputStream-与-OutputStream"><a href="#字节流-InputStream-与-OutputStream" class="headerlink" title="字节流 InputStream 与 OutputStream"></a>字节流 InputStream 与 OutputStream</h2><p>InputStream 与 OutputStream的继承关系：</p>
<p><img src="/2020/11/27/java-io/16e24b5194c7004e" alt="在这里插入图片描述"></p>
<h3 id="文件的世界里一切皆为字节"><a href="#文件的世界里一切皆为字节" class="headerlink" title="文件的世界里一切皆为字节"></a>文件的世界里一切皆为字节</h3><p>我们必须明确一点的是，<strong>一切文件数据 (文本、图片、视频等) 在存储时，都是以二进制数字的形式保存，都是一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。</strong>在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h3 id="字节输入流-InputStream"><a href="#字节输入流-InputStream" class="headerlink" title="字节输入流 InputStream"></a>字节输入流 InputStream</h3><p><code>java.io.InputStream</code> 抽象类是表示<strong>字节输入流</strong>的所有类的<strong>超类</strong> (父类)，可以读取字节信息到内存中，它定义了字节输入流的基本共性功能方法。</p>
<p><strong>字节输入流的基本共性功能方法：</strong></p>
<ol>
<li> <code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。</li>
<li> <code>public abstract int read()</code>： 从输入流读取数据的下一个字节。</li>
<li> <code>public int read(byte[] b)</code>： 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回 -1。</li>
</ol>
<h4 id="FileInputStream-类"><a href="#FileInputStream-类" class="headerlink" title="FileInputStream 类"></a>FileInputStream 类</h4><p><code>java.io.FileInputStream</code> 类是文件输入流，从文件中读取字节。</p>
<h5 id="FileInputStream-的构造方法"><a href="#FileInputStream-的构造方法" class="headerlink" title="FileInputStream 的构造方法"></a>FileInputStream 的构造方法</h5><ol>
<li> <code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。</li>
<li> <code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。</li>
</ol>
<p>推荐使用第二种构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件，会抛出 <code>FileNotFoundException</code> 。</p>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos2 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FileInputStream-读取字节数据"><a href="#FileInputStream-读取字节数据" class="headerlink" title="FileInputStream 读取字节数据"></a>FileInputStream 读取字节数据</h5><p><strong>1. 读取单个字节</strong>：<code>read() </code>方法，每次可以读取一个字节的数据，返回为 int 类型，读取到文件末尾，返回 -1。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，read.txt文件中内容为：abcde</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        <span class="comment">// 读取到末尾，返回-1</span></span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>流操作完毕后，必须释放系统资源，调用 <code>close()</code> 方法，千万记得。</p>
</blockquote>
<p>循环改进读取方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，read.txt文件中内容为：abcde</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取 b 的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回 -1。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，read.txt文件中内容为：abcde</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次读取后，把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>由于 read.txt 文件中内容为 <code>abcde</code>，而错误数据 <code>d</code>，是由于最后一次读取时，只读取一个字节 <code>e</code>，数组中，上次读取的数据没有被完全<strong>替换</strong>【注意是替换，看下图】，所以要通过 <code>len</code> ，获取有效的字节。</p>
<p><img src="/2020/11/27/java-io/16e24b5193e018a1" alt="在这里插入图片描述"></p>
<p>改进代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，read.txt文件中内容为：abcde</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，作为每次读取的有效字节个数</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次读取后，把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<p>在开发中一般推荐使用数组读取文件，整体优化代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>

<h3 id="字节输出流-OutputStream"><a href="#字节输出流-OutputStream" class="headerlink" title="字节输出流 OutputStream"></a>字节输出流 OutputStream</h3><p><code>java.io.OutputStream</code> 抽象类是表示<strong>字节输出流</strong>的所有类的<strong>超类</strong> (父类)，将指定的字节信息写出到目的地，它定义了字节输出流的基本共性功能方法。</p>
<p><strong>字节输出流的基本共性功能方法：</strong></p>
<ol>
<li> <code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li>
<li> <code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li>
<li> <code>public void write(byte[] b)</code>：将 b.length 个字节从指定的字节数组写入此输出流。</li>
<li> <code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流，<strong>也就是说从 off 个字节数开始读取一直到 len 个字节结束</strong> 。</li>
<li> <code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ol>
<blockquote>
<p>以上五个方法是字节输出流都具有的方法，由父类 OutputStream 定义提供，子类都会共享以上方法。</p>
</blockquote>
<h4 id="FileOutputStream-类"><a href="#FileOutputStream-类" class="headerlink" title="FileOutputStream 类"></a>FileOutputStream 类</h4><p><code>java.io.FileOutputStream</code> 类是文件输出流，向文件中写入字节。</p>
<h5 id="FileOutputStream-的构造方法"><a href="#FileOutputStream-的构造方法" class="headerlink" title="FileOutputStream 的构造方法"></a>FileOutputStream 的构造方法</h5><ol>
<li> <code>public FileOutputStream(File file)</code>：根据 File 对象为参数创建对象。</li>
<li> <code>public FileOutputStream(String name)</code>： 根据名称字符串为参数创建对象。</li>
</ol>
<p>推荐使用第二种构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上面这句代码来讲，类似这样创建字节输出流对象都做了<strong>三件事情</strong>： </p>
<ol>
<li>调用系统功能去创建文件，输出流对象会自动创建；</li>
<li>创建 outputStream 对象；</li>
<li>把 outputStream 对象指向这个文件。</li>
</ol>
<blockquote>
<p>创建输出流对象的时候，系统会自动去对应位置创建对应文件，而创建输入流对象的时候，文件不存在会报 <code>FileNotFoundException</code> 异常，也就是系统找不到指定的文件异常。</p>
</blockquote>
<p>当创建一个流对象时，必须直接或者间接传入一个文件路径。比如现在我们创建一个 <code>FileOutputStream</code> 流对象，在该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\自动创建的文件夹\\a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FileOutputStream-写出字节数据"><a href="#FileOutputStream-写出字节数据" class="headerlink" title="FileOutputStream 写出字节数据"></a>FileOutputStream 写出字节数据</h5><p>使用 FileOutputStream 写出字节数据主要通过 <code>write()</code> 方法，而<code>write()</code> 方法分如下三种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  <span class="comment">// 从off索引开始，len个字节</span></span></span><br></pre></td></tr></table></figure>

<p><strong>1. 写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        fos.write(<span class="number">97</span>);<span class="comment">// 写出第1个字节</span></span><br><span class="line">        fos.write(<span class="number">98</span>);<span class="comment">// 写出第2个字节</span></span><br><span class="line">        fos.write(<span class="number">99</span>);<span class="comment">// 写出第3个字节</span></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出。</p>
</blockquote>
<p><strong>2. 写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="string">&quot;麻麻我想吃烤山药&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">// 写出字节数组数据</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">麻麻我想吃烤山药</span><br></pre></td></tr></table></figure>

<p><strong>3. 写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code>，每次写出从 off 索引开始，len 个字节。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">// 写出从索引2开始，2个字节。索引2是c，2个字节，也就是cd。</span></span><br><span class="line">        fos.write(b, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<h5 id="FileOutputStream-实现数据追加续写、换行"><a href="#FileOutputStream-实现数据追加续写、换行" class="headerlink" title="FileOutputStream 实现数据追加续写、换行"></a>FileOutputStream 实现数据追加续写、换行</h5><p>经过以上的代码测试，每次程序运行时创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续追加新数据呢？并且实现换行呢？其实很简单，这个时候我们又要再学习 <code>FileOutputStream</code> 的另外两个构造方法了，如下：</p>
<ol>
<li> <code>public FileOutputStream(File file, boolean append)</code></li>
<li> <code>public FileOutputStream(String name, boolean append)</code></li>
</ol>
<p>这两个构造方法，第二个参数中都需要传入一个 boolean 类型的值，true  表示追加数据，false 表示不追加也就是清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，至于 windows 系统换行符是 <code>\r\n</code> ，下面将会详细讲到。</p>
<p>实现数据追加续写代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">        fos.write(b);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>

<p>Windows系统里，换行符号是<code>\r\n</code> ,具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>&#125;;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> word : words) &#123;</span><br><span class="line">            <span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(word);</span><br><span class="line">            <span class="comment">// 写出一个换行，换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回车符 <code>\r</code> 和换行符 <code>\n</code>：</p>
<ul>
<li>回车符：回到一行的开头 (return)。</li>
<li>换行符：下一行 (newline)。</li>
</ul>
<p>不同系统中的换行：</p>
<ul>
<li>Windows系统里，每行结尾是 <code>回车 + 换行</code> ，即 <code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即 <code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即 <code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
<h3 id="FileInputStream-和-FileOutputStream-完成图片复制"><a href="#FileInputStream-和-FileOutputStream-完成图片复制" class="headerlink" title="FileInputStream 和 FileOutputStream 完成图片复制"></a>FileInputStream 和 FileOutputStream 完成图片复制</h3><p>复制图片原理：</p>
<p><img src="/2020/11/27/java-io/16e24b51938be9da" alt="在这里插入图片描述"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.指定数据源fis和目的地fos</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:/test.png&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/test_copy.jpg&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.读和写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制文本、图片、mp3、视频等的方式一样。</p>
</blockquote>
<h2 id="字符流-Reader-和-Writer"><a href="#字符流-Reader-和-Writer" class="headerlink" title="字符流 Reader 和 Writer"></a>字符流 Reader 和 Writer</h2><p>Reader 和 Writer 的继承关系：</p>
<p><img src="/2020/11/27/java-io/16e24b519317184b" alt="在这里插入图片描述"></p>
<h3 id="字符流的由来"><a href="#字符流的由来" class="headerlink" title="字符流的由来"></a>字符流的由来</h3><p>因为数据编码的不同，因而有了对字符进行高效操作的流对象，字符流本质其实就是基于字节流读取时，去查了指定的码表，而字节流直接读取数据会有乱码的问题 (读中文会乱码)。举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharaterStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// FileInputStream为操作文件的字符输入流，read.txt内容为：测试用例</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">æµè¯ç¨ä¾</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字节流读取中文字符时，可能不会显示完整的字符，那是因为一个中文字符占用多个字节存储。</p>
</blockquote>
<p>如果不想乱码，可以用下面的方式，但比较繁琐：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// FileInputStream为操作文件的字符输入流，read.txt内容为：测试用例</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，解码的是 <code>String</code>，查看 <code>new String()</code> 的源码，<code>String</code> 构造方法有解码功能，并且默认编码是 <code>utf-8</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>[] decode(<span class="keyword">byte</span>[] ba, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    String csn = Charset.defaultCharset().name();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// use charset name decode() variant which provides caching.</span></span><br><span class="line">        <span class="keyword">return</span> decode(csn, ba, off, len);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException x) &#123;</span><br><span class="line">        warnUnsupportedCharset(csn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decode(<span class="string">&quot;ISO-8859-1&quot;</span>, ba, off, len);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException x) &#123;</span><br><span class="line">        <span class="comment">// If this code is hit during VM initialization, MessageUtils is</span></span><br><span class="line">        <span class="comment">// the only way we will be able to get any kind of error message.</span></span><br><span class="line">        MessageUtils.err(<span class="string">&quot;ISO-8859-1 charset not available: &quot;</span></span><br><span class="line">                         + x.toString());</span><br><span class="line">        <span class="comment">// If we can not find ISO-8859-1 (a required encoding) then things</span></span><br><span class="line">        <span class="comment">// are seriously wrong with the installation.</span></span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title">defaultCharset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultCharset == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Charset.class) &#123;</span><br><span class="line">            String csn = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> GetPropertyAction(<span class="string">&quot;file.encoding&quot;</span>));</span><br><span class="line">            Charset cs = lookup(csn);</span><br><span class="line">            <span class="keyword">if</span> (cs != <span class="keyword">null</span>)</span><br><span class="line">                defaultCharset = cs;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                defaultCharset = forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultCharset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，尽管字节流也能解决乱码问题，但是比较麻烦，于是 java 就有了字符流，以字符为单位读写数据，字符流专门用于处理文本文件。如果处理纯文本的数据，优先考虑字符流，其他情况就只能用字节流了 (图片、视频、等等只文本例外)。</p>
<blockquote>
<p>从另一角度来说：字符流 = 字节流 + 编码表。</p>
</blockquote>
<h3 id="字符输入流-Reader"><a href="#字符输入流-Reader" class="headerlink" title="字符输入流 Reader"></a>字符输入流 Reader</h3><p><code>java.io.Reader </code> 抽象类是<strong>字符输入流</strong>的所有类的<strong>超类</strong> (父类)，可以读取字符信息到内存中，它定义了字符输入流的基本共性功能方法。</p>
<p><strong>字符输入流的共性方法：</strong></p>
<ol>
<li> <code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。</li>
<li> <code>public int read()</code>： 从输入流读取一个字符。</li>
<li> <code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中。</li>
</ol>
<h4 id="FileReader-类"><a href="#FileReader-类" class="headerlink" title="FileReader 类"></a>FileReader 类</h4><p><code>java.io.FileReader</code> 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h5 id="FileReader-的构造方法"><a href="#FileReader-的构造方法" class="headerlink" title="FileReader 的构造方法"></a>FileReader 的构造方法</h5><ol>
<li> <code>public FileReader(File file)</code>： 创建一个新的 FileReader，给定要读取的 <strong>File 对象</strong>。</li>
<li> <code>public FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的<strong>字符串名称</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr2 = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FileReader-读取字符数据"><a href="#FileReader-读取字符数据" class="headerlink" title="FileReader 读取字符数据"></a>FileReader 读取字符数据</h5><p><strong>读取字符</strong>：<code>read() </code>方法，每次可以读取一个字符的数据，返回为 int 类型，读取到文件末尾，返回 -1，循环读取。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符输出流-Writer"><a href="#字符输出流-Writer" class="headerlink" title="字符输出流 Writer"></a>字符输出流 Writer</h3><p><code>java.io.Writer</code> 抽象类是<strong>字符输出流</strong>的所有类的<strong>超类</strong> (父类)，将指定的字符信息写出到目的地，它同样定义了字符输出流的基本共性功能方法。</p>
<p><strong>字符输出流的基本共性功能方法：</strong></p>
<ol>
<li> <code>void write(int c)</code>：写入单个字符。</li>
<li> <code>void write(char[] cbuf)</code>：写入字符数组。</li>
<li> <code>abstract void write(char[] cbuf, int off, int len)</code>：写入字符数组的某一部分，off 数组的开始索引，len 写的字符个数。</li>
<li> <code>void write(String str)</code>：写入字符串。</li>
<li> <code>void write(String str, int off, int len)</code>：写入字符串的某一部分，off 字符串的开始索引，len 写的字符个数。</li>
<li> <code>void flush()</code>：刷新该流的缓冲。</li>
<li> <code>void close()</code> ：关闭此流，但要先刷新它。</li>
</ol>
<h4 id="FileWriter-类"><a href="#FileWriter-类" class="headerlink" title="FileWriter 类"></a>FileWriter 类</h4><p><code>java.io.FileWriter</code> 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h5 id="FileWriter-的构造方法"><a href="#FileWriter-的构造方法" class="headerlink" title="FileWriter 的构造方法"></a>FileWriter 的构造方法</h5><ol>
<li> <code>public FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的 File 对象。</li>
<li> <code>public FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种：使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种：使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw2 = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FileWriter-写出字符数据"><a href="#FileWriter-写出字符数据" class="headerlink" title="FileWriter 写出字符数据"></a>FileWriter 写出字符数据</h5><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">        fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关闭资源时，与 FileOutputStream 不同，必须执行 <code>close()</code> 方法，如果不关闭，数据只是保存到缓冲区，并未保存到文件。</p>
</blockquote>
<h5 id="关闭-close-方法和刷新-flush-方法"><a href="#关闭-close-方法和刷新-flush-方法" class="headerlink" title="关闭 close() 方法和刷新 flush() 方法"></a>关闭 <code>close()</code> 方法和刷新 <code>flush()</code> 方法</h5><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要 <code>flush()</code> 方法了。</p>
<p><code>flush()</code>：刷新缓冲区，流对象可以继续使用。</p>
<p><code>close()</code>：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlushDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 源   也就是输入流【读取流】 读取read.txt文件，必须要存在read.txt文件，否则报FileNotFoundException异常</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 目的地  也就是输出流，系统会自动创建write.txt，因为它是输出流！</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/write.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fw.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里没有使用close关闭流，开发中不能这样做，但是可以更好的体会flush的作用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码执行完后，因为没有关闭流，write.txt 文件中依旧会是空的。在上面代码中再添加下面三句代码，write.txt 文件就能复制到源文件的数据了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fr.close();</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>

<p><code>flush()</code> 方法是清空的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再写到文件中，那么当你数据读完时，如果这时调用 <code>close()</code> 方法关闭读写流，就可能造成数据丢失，为什么呢？因为，读入数据完成时不代表写入数据完成，一部分数据可能会留在缓存区中，这个时候使用 <code>flush()</code> 方法就格外重要了。</p>
<p><code>close()</code> 方法使用代码示意如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即便是 <code>flush()</code> 方法写出了数据，操作的最后还是要调用 <code>close()</code> 方法，释放系统资源。</p>
</blockquote>
<h5 id="FileWriter-的追加和换行"><a href="#FileWriter-的追加和换行" class="headerlink" title="FileWriter 的追加和换行"></a>FileWriter 的追加和换行</h5><p><strong>追加和换行</strong>：操作类似于 FileOutputStream 操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，true代表可以追加数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/fw.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出换行</span></span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;用例&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">在fw.txt内容的后面，追加：</span><br><span class="line">测试</span><br><span class="line">用例</span><br></pre></td></tr></table></figure>

<h4 id="FileReader-和-FileWriter-完成文本文件复制"><a href="#FileReader-和-FileWriter-完成文本文件复制" class="headerlink" title="FileReader 和 FileWriter 完成文本文件复制"></a>FileReader 和 FileWriter 完成文本文件复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建输入流对象，若文件不存在会抛出java.io.FileNotFoundException</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/copyread.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*创建输出流做的工作：</span></span><br><span class="line"><span class="comment">         *  1.调用系统资源创建了一个文件</span></span><br><span class="line"><span class="comment">         *  2.创建输出流对象</span></span><br><span class="line"><span class="comment">         *  3.把输出流对象指向文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文本文件复制，一次读一个字符</span></span><br><span class="line">        copyMethod1(fr, fw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文本文件复制，一次读一个字符数组</span></span><br><span class="line">        copyMethod2(fr, fw);</span><br><span class="line"></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.close();</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMethod1</span><span class="params">(FileReader fr, FileWriter fw)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch = fr.read()) != -<span class="number">1</span>) &#123;<span class="comment">// 读数据</span></span><br><span class="line">            fw.write(ch);<span class="comment">// 写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMethod2</span><span class="params">(FileReader fr, FileWriter fw)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(chs)) != -<span class="number">1</span>) &#123;<span class="comment">// 读数据</span></span><br><span class="line">            fw.write(chs, <span class="number">0</span>, len);<span class="comment">// 写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时，使用字符流，其他情况使用字节流。</p>
</blockquote>
<h2 id="IO-异常的处理"><a href="#IO-异常的处理" class="headerlink" title="IO 异常的处理"></a>IO 异常的处理</h2><p>我们在学习的过程中可能习惯把异常抛出，而实际开发中并不能这样处理，建议使用 <code>try...catch...finally</code> 代码块，处理异常部分，代码格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;测试用例&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>缓冲流，也叫高效流，是对4个 <code>FileXxx</code> 流的 “增强流”。</p>
<p><strong>缓冲流的基本原理：</strong></p>
<ol>
<li> 使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。</li>
<li> 通过缓冲区的 <code>read()</code> 方法从缓冲区获取具体的字符数据，这样就提高了效率。</li>
<li> 如果用 <code>read()</code> 方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了 <code>readLine()</code> 功能。</li>
</ol>
<p>也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统 IO 次数，从而提高读写的效率。</p>
<p>缓冲流书写格式为 <code>BufferedXxx</code>，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code></li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<h3 id="字节缓冲流-BufferedInputStream-和-BufferedOutputStream"><a href="#字节缓冲流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="字节缓冲流 BufferedInputStream 和 BufferedOutputStream"></a>字节缓冲流 BufferedInputStream 和 BufferedOutputStream</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流，注意参数类型为 <strong>InputStream</strong>。</li>
<li> <code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流，注意参数类型为 <strong>OutputStream</strong>。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/write.txt&quot;</span>);) &#123;</span><br><span class="line">            <span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高效的字节缓冲流"><a href="#高效的字节缓冲流" class="headerlink" title="高效的字节缓冲流"></a>高效的字节缓冲流</h4><p>缓冲流读写方法与基本的流是一致的，我们通过复制 370 多 MB 的大文件，测试它的效率。</p>
<p>基本流，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/write.txt&quot;</span>);) &#123;</span><br><span class="line">            <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲流，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/write.txt&quot;</span>);) &#123;</span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，缓冲流能明显提高效率。</p>
<p><strong>上述代码还能通过定义数组，来进一步优化</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/write.txt&quot;</span>);) &#123;</span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流优化后的复制时间:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流-BufferedReader-和-BufferedWriter"><a href="#字符缓冲流-BufferedReader-和-BufferedWriter" class="headerlink" title="字符缓冲流 BufferedReader 和 BufferedWriter"></a>字符缓冲流 BufferedReader 和 BufferedWriter</h3><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流，注意参数类型为 <strong>Reader</strong>。</li>
<li> <code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流，注意参数类型为 <strong>Writer</strong>。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/writer.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">            BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            <span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">            BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高效的字符缓冲流"><a href="#高效的字符缓冲流" class="headerlink" title="高效的字符缓冲流"></a>高效的字符缓冲流</h4><p>此处与字节缓冲流类似，优化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/writer.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">char</span>[] bytes = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bfr.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bfw.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流优化后的复制时间:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符缓冲流的特有方法"><a href="#字符缓冲流的特有方法" class="headerlink" title="字符缓冲流的特有方法"></a>字符缓冲流的特有方法</h4><p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的<strong>特有方法</strong>：</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>：<strong>读一行数据</strong>，读取到最后返回 null。</li>
<li>BufferedWriter：<code>public void newLine()</code>:：<strong>换行</strong>，由系统属性定义符号。</li>
</ul>
<p><code>readLine()</code> 方法示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLineDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            <span class="comment">// 定义字符串，保存读取的一行文字</span></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 循环读取，读取到最后返回null</span></span><br><span class="line">            <span class="keyword">while</span> ((line = bfr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">                System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            bfr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newLine()</code> 方法示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewLineDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;xisun-database/write.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">            bfw.write(<span class="string">&quot;测&quot;</span>);</span><br><span class="line">            <span class="comment">// 换行</span></span><br><span class="line">            bfw.newLine();</span><br><span class="line">            bfw.write(<span class="string">&quot;试&quot;</span>);</span><br><span class="line">            bfw.newLine();</span><br><span class="line">            bfw.write(<span class="string">&quot;用&quot;</span>);</span><br><span class="line">            bfw.newLine();</span><br><span class="line">            bfw.write(<span class="string">&quot;例&quot;</span>);</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            bfw.flush();</span><br><span class="line">            bfw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">测</span><br><span class="line">试</span><br><span class="line">用</span><br><span class="line">例</span><br></pre></td></tr></table></figure>

<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>众所周知，计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。注意，<strong>编码规则和解码规则要对应，否则会导致乱码。</strong>比如说，按照 A 规则存储，同样按照 A 规则解析，那么就能显示正确的文本符号。反之，按照 A 规则存储，再按照 B 规则解析，就会导致乱码现象。</p>
<p><img src="/2020/11/27/java-io/16e24b51b50af9f5" alt="在这里插入图片描述"></p>
<p>简单一点说就是：</p>
<ul>
<li><p>编码：字符 (能看懂的) → 字节 (看不懂的)。</p>
</li>
<li><p>解码：字节 (看不懂的) → 字符 (能看懂的)。</p>
</li>
</ul>
<p>用代码解释则为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName): 通过指定的字符集解码字节数组</span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName): 使用指定的字符集合把字符串编码为字节数组</span><br><span class="line"></span><br><span class="line">编码: 把看得懂的变成看不懂的</span><br><span class="line">String -- <span class="keyword">byte</span>[]</span><br><span class="line"></span><br><span class="line">解码: 把看不懂的变成看得懂的</span><br><span class="line"><span class="keyword">byte</span>[] -- String</span><br></pre></td></tr></table></figure>

<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p><strong>字符集</strong> <code>Charset</code>：也叫<strong>编码表</strong>。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有 <code>ASCII</code> 字符集、<code>GBK</code> 字符集、<code>Unicode</code> 字符集等。</p>
<p><img src="/2020/11/27/java-io/16e24b51b5b2204d" alt="在这里插入图片描述"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li>ASCII 字符集<ul>
<li>ASCII (American Standard Code for Information Interchange，美国信息交换标准代码) 是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符 (回车键、退格、换行键等) 和可显示字符 (英文大小写字符、阿拉伯数字和西文符号)。</li>
<li>基本的 ASCII 字符集，使用 7 位（bits）表示一个字符，共 128 字符。ASCII 的扩展字符集使用 8 位（bits）表示一个字符，共 256 字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li>ISO-8859-1 字符集<ul>
<li>拉丁码表，别名 Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1 使用单字节编码，兼容 ASCII 编码。</li>
</ul>
</li>
<li>GBxxx 字符集<ul>
<li>GB 就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于 127 的字符的意义与原来相同。但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含 7000 多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的 “全角” 字符，而原来在 127 号以下的那些就叫 “半角” 字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在 GB2312 标准基础上的扩展规范，使用了双字节编码方案，共收录了 21003 个汉字，完全兼容 GB2312 标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li>Unicode 字符集<ul>
<li>Unicode 编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用 4 个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16 和 UTF-32。最为常用的 UTF-8 编码。</li>
<li>UTF-8 编码，可以用来表示 Unicode 标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组 (IETF) 要求所有互联网协议都必须支持 UTF-8 编码。所以，我们开发 Web 应用，也要使用 UTF-8 编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128 个 US-ASCII 字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。</li>
<li>大部分常用字 (含中文)，使用三个字节编码。</li>
<li>其他极少使用的 Unicode 辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="编码问题导致乱码"><a href="#编码问题导致乱码" class="headerlink" title="编码问题导致乱码"></a>编码问题导致乱码</h3><p>在 java 开发工具 IDEA 中，使用 FileReader 读取项目中的文本文件。由于 IDEA 的设置，都是默认的 UTF-8 编码，所以没有任何问题。但是，当读取 Windows 系统中创建的文本文件时，由于 Windows 系统的默认是 GBK 编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:\\test.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> read;</span><br><span class="line">            <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) read);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">��������</span><br></pre></td></tr></table></figure>

<p>那么如何读取 GBK 编码的文件呢？ 这个时候就得讲讲转换流了！</p>
<blockquote>
<p>从另一角度来讲：<strong>字符流 = 字节流 + 编码表</strong>。</p>
</blockquote>
<h3 id="InputStreamReader-类-—-字节流到字符流的桥梁"><a href="#InputStreamReader-类-—-字节流到字符流的桥梁" class="headerlink" title="InputStreamReader 类 — 字节流到字符流的桥梁"></a>InputStreamReader 类 — 字节流到字符流的桥梁</h3><p>转换流 <code>java.io.InputStreamReader</code>，是 Reader 的子类，从字面意思可以看出它是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>InputStreamReader(InputStream in)</code>：创建一个使用默认字符集的字符流。</li>
<li> <code>InputStreamReader(InputStream in, String charsetName)</code>：创建一个指定字符集的字符流。</li>
</ol>
<h4 id="使用转换流解决编码问题-—-读文件"><a href="#使用转换流解决编码问题-—-读文件" class="headerlink" title="使用转换流解决编码问题 — 读文件"></a>使用转换流解决编码问题 — 读文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 文件为gbk编码</span></span><br><span class="line">        String fileName = <span class="string">&quot;E:/test.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建流对象，默认UTF8编码</span></span><br><span class="line">            InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">            <span class="comment">// 创建流对象，指定GBK编码</span></span><br><span class="line">            InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(fileName), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义变量，保存字符</span></span><br><span class="line">            <span class="keyword">int</span> read;</span><br><span class="line">            <span class="comment">// 使用默认编码字符流读取，乱码</span></span><br><span class="line">            <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) read);</span><br><span class="line">            &#125;</span><br><span class="line">            isr.close();</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;\r\n******************\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用指定编码字符流读取，正常解析</span></span><br><span class="line">            <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) read);</span><br><span class="line">            &#125;</span><br><span class="line">            isr2.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">��������</span><br><span class="line">******************</span><br><span class="line">测试用例</span><br></pre></td></tr></table></figure>

<h3 id="OutputStreamWriter-类-—-字符流到字节流的桥梁"><a href="#OutputStreamWriter-类-—-字符流到字节流的桥梁" class="headerlink" title="OutputStreamWriter 类 — 字符流到字节流的桥梁"></a>OutputStreamWriter 类 — 字符流到字节流的桥梁</h3><p>转换流 <code>java.io.OutputStreamWriter</code> ，是 Writer 的子类，字面看容易混淆会误以为是转为字符流，其实不然，OutputStreamWriter 为从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>OutputStreamWriter(OutputStream in)</code>：创建一个使用默认字符集的字符流。</li>
<li> <code>OutputStreamWriter(OutputStream in, String charsetName)</code>：创建一个指定字符集的字符流。</li>
</ol>
<h4 id="使用转换流解决编码问题-—-写文件"><a href="#使用转换流解决编码问题-—-写文件" class="headerlink" title="使用转换流解决编码问题 — 写文件"></a>使用转换流解决编码问题 — 写文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">            OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:/test.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            osw.write(<span class="string">&quot;测试&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">            osw.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">            OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:/test2.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            osw2.write(<span class="string">&quot;用例&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">            osw2.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/27/java-io/16e24b51b8f8fd36" alt="在这里插入图片描述"></p>
<p>为了达到<strong>最高效率</strong>，可以考虑在 BufferedReader 内包装 InputStreamReader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))；</span><br></pre></td></tr></table></figure>

<h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><h3 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h3><p>java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该 <code>对象的数据</code>、<code>对象的类型</code> 和 <code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code> 和 <code>对象中存储的属性</code> 等信息，都可以用来在内存中创建对象。如图所示：</p>
<p><img src="/2020/11/27/java-io/16e24b51bb752dbd" alt="在这里插入图片描述"></p>
<h3 id="ObjectOutputStream-类"><a href="#ObjectOutputStream-类" class="headerlink" title="ObjectOutputStream 类"></a>ObjectOutputStream 类</h3><p><code>java.io.ObjectOutputStream</code> 类，将 java 对象的原始数据类型写出到文件，实现对象的持久存储。</p>
<h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定 OutputStream 的 ObjectOutputStream。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;aa.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>

<h4 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h4><p><strong>一个对象要想序列化，必须满足两个条件：</strong></p>
<ul>
<li><p>该类必须实现 <code>java.io.Serializable</code> 接口，Serializable 是一个标记接口，不实现此接口的类不能实现任何状态序列化或反序列化，否则会抛出 <code>NotSerializableException</code>。</p>
</li>
<li><p>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用 <code>transient</code> 关键字修饰。</p>
</li>
</ul>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员，不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写出对象方法：</strong></p>
<ul>
<li> <code>public final void writeObject(Object obj)</code>： 将指定的对象写出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        employee.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">        employee.age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建序列化流对象</span></span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;xisun-database/employee.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 写出对象</span></span><br><span class="line">            out.writeObject(employee);</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            out.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<p>employee.txt 文件内容：</p>
<p><img src="/2020/11/27/java-io/image-20201214143657619.png" alt="image-20201214143657619"></p>
<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p><code>java.io.ObjectInputStream</code> 类，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象。</p>
<h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public ObjectInputStream(InputStream in)</code>： 创建一个指定 InputStream 的 ObjectInputStream。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;aa.txt&quot;</span>);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br></pre></td></tr></table></figure>

<h4 id="反序列化操作"><a href="#反序列化操作" class="headerlink" title="反序列化操作"></a>反序列化操作</h4><p>如果能找到一个对象的 class 文件，我们可以进行反序列化操作，调用 ObjectInputStream <strong>读取对象的方法</strong>：</p>
<ul>
<li><code>public final Object readObject()</code>：读取一个对象。</li>
</ul>
<p>以前面序列化得到的 employee.txt 文件为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建反序列化流</span></span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/employee.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 读取一个对象</span></span><br><span class="line">            employee = (Employee) in.readObject();</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常，直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + employee.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + employee.address);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + employee.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Name: zhangsan</span><br><span class="line">Address: beiqinglu</span><br><span class="line">Age: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>JVM 可以反序列化对象，但前提是必须能够找到 class 文件的类。如果找不到该类的 class 文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</p>
<p>另外，当 JVM 反序列化对象时，如果找到的 class 文件，在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个 <code>InvalidClassException</code> 异常。发生这个异常的原因如下：</p>
<ol>
<li> 该类的序列版本号与从流中读取的类描述符的版本号不匹配；</li>
<li> 该类包含未知数据类型；</li>
<li> 该类没有可访问的无参数构造方法。</li>
</ol>
<h3 id="序列版本号-serialVersionUID"><a href="#序列版本号-serialVersionUID" class="headerlink" title="序列版本号 serialVersionUID"></a>序列版本号 <code>serialVersionUID</code></h3><p>需要知道的是，只有实现了 Serializable 或 Externalizable 接口的类的对象才能被序列化。Externalizable 接口继承自 Serializable 接口，实现 Externalizable 接口的类完全由自身来控制序列化的行为，而仅实现 Serializable 接口的类可以采用默认的序列化方式 。</p>
<p>凡是实现 Serializable 接口的类都有一个表示序列化版本标识符的静态变量：<code>private static final long serialVersionUID;</code>，该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<p>类的 serialVersionUID 的默认值完全依赖于 java 编译器的实现，对于同一个类，用不同的 java 编译器编译，有可能会导致不同的 serialVersionUID。</p>
<p>当然，也可以人为显式地定义 serialVersionUID，这种方式有两种用途： </p>
<ol>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的 serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的 serialVersionUID。 </li>
<li>当你序列化了一个类实例后，后续可能更改一个字段或添加一个字段。如果不设置 serialVersionUID，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常；如果你添加了 serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值 (对象为 null，基本类型为相应的初始默认值)，字段被删除将不设置。 </li>
</ol>
<p>比如，对之前的 Employee 类添加新字段，同时希望能够继续反序列化未添加字段前得到的 employee.txt 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.添加序列版本号，并保持和不添加新属性之前相同的serialVersionUID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5303622816239242438L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员，不会被序列化</span></span><br><span class="line">    <span class="comment">// 2.添加新的属性，重新反序列化之前序列化得到的文件，此时该属性赋为int类型的默认值0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> eid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，再次执行 DeserializeDemo 的方法，输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: zhangsan</span><br><span class="line">Address: beiqinglu</span><br><span class="line">Age: <span class="number">0</span></span><br><span class="line">Eid：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><h3 id="什么是打印流"><a href="#什么是打印流" class="headerlink" title="什么是打印流"></a>什么是打印流</h3><p>平时我们在控制台打印输出，是调用 print 方法和 println 方法完成的，实际上，这两个方法都来自于 <code>java.io.PrintStream</code> 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<p><strong>打印流分类：</strong></p>
<ul>
<li>字节打印流 PrintStream</li>
<li>字符打印流 PrintWriter</li>
</ul>
<p><strong>打印流特点：</strong></p>
<ul>
<li>只操作目的地，不操作数据源。</li>
<li>可以操作任意类型的数据。</li>
<li>如果启用了自动刷新，在调用 <code>println()</code> 方法的时候，能够换行并刷新。</li>
<li>可以直接操作文件。</li>
</ul>
<blockquote>
<p>一般情况下，如果一个流的构造方法能够同时接收 File 和 String 类型的参数，都是可以直接操作文件的！</p>
</blockquote>
<p>PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类，两者处于对等的位置上，所以它们的 API 是非常相似的。二者区别无非一个是字节打印流，一个是字符打印流。</p>
<h3 id="字节输出打印流-PrintStream-复制文本文件"><a href="#字节输出打印流-PrintStream-复制文本文件" class="headerlink" title="字节输出打印流 PrintStream 复制文本文件"></a>字节输出打印流 PrintStream 复制文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>));</span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;xisun-database/printcopy.txt&quot;</span>);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ps.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            ps.close();</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符输出打印流-PrintWriter-复制文本文件"><a href="#字符输出打印流-PrintWriter-复制文本文件" class="headerlink" title="字符输出打印流 PrintWriter 复制文本文件"></a>字符输出打印流 PrintWriter 复制文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xisun-database/read.txt&quot;</span>));</span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;xisun-database/printcopy.txt&quot;</span>);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pw.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            pw.close();</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Properties-属性类"><a href="#Properties-属性类" class="headerlink" title="Properties 属性类"></a>Properties 属性类</h2><h3 id="Properties-概述"><a href="#Properties-概述" class="headerlink" title="Properties 概述"></a>Properties 概述</h3><p><code>java.util.Properties</code> 继承于 Hashtable，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多 java 类使用，比如获取系统属性时，<code>System.getProperties()</code> 方法就是返回一个 Properties 对象。</p>
<h3 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h3><h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li> <code>public Properties()</code>：创建一个空的属性列表。</li>
</ol>
<h4 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h4><ol>
<li> <code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li>
<li> <code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li>
<li> <code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li>
</ol>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过键，获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集，获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot; -- &quot;</span> + properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;location=D:\a.txt, filename=a.txt, length=<span class="number">209385038</span>&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">location -- D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span>    </span><br></pre></td></tr></table></figure>

<h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><ol>
<li> <code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。</li>
<li> <code>public void load(Reader reader)</code>：从字符输入流中读取键值对。</li>
<li> <code> public void store(Writer writer,String comments)</code></li>
<li> <code>public void store(OutputStream out,String comments)</code></li>
</ol>
<p>可以看出，参数中使用了字节输入流时，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。</p>
<p>例如，现在文本数据格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename=Properties.txt</span><br><span class="line">length=<span class="number">123</span></span><br><span class="line">location=C:/Properties.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xisun-database/Properties.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 创建属性集对象</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">            properties.load(fis);</span><br><span class="line">            <span class="comment">// 遍历集合并打印</span></span><br><span class="line">            Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">            <span class="keyword">for</span> (String key : strings) &#123;</span><br><span class="line">                System.out.println(key + <span class="string">&quot; -- &quot;</span> + properties.getProperty(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">location -- C:/Properties.txt</span><br><span class="line">filename -- Properties.txt</span><br><span class="line">length -- <span class="number">123</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="字节流-FileInputStream-和-FileOutputStream-用法"><a href="#字节流-FileInputStream-和-FileOutputStream-用法" class="headerlink" title="字节流 FileInputStream 和 FileOutputStream 用法"></a>字节流 FileInputStream 和 FileOutputStream 用法</h3><p>读文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:/read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PictureCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:/input.png&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:/copy-input.png&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流-FileReader-和-FileWriter-的用法"><a href="#字符流-FileReader-和-FileWriter-的用法" class="headerlink" title="字符流 FileReader 和 FileWriter 的用法"></a>字符流 FileReader 和 FileWriter 的用法</h3><p>复制文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fw.write(chars, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节缓冲流-BufferedInputStream-和-BufferedOutputStream-的用法"><a href="#字节缓冲流-BufferedInputStream-和-BufferedOutputStream-的用法" class="headerlink" title="字节缓冲流 BufferedInputStream 和 BufferedOutputStream 的用法"></a>字节缓冲流 BufferedInputStream 和 BufferedOutputStream 的用法</h3><p>复制文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:/copy-read.txt&quot;</span>);</span><br><span class="line">             BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">             BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>性能优于 FileInputStream 和 FileOutputStream。</p>
</blockquote>
<h3 id="字符缓冲流-BufferedReader-和-BufferedWriter-的用法"><a href="#字符缓冲流-BufferedReader-和-BufferedWriter-的用法" class="headerlink" title="字符缓冲流 BufferedReader 和 BufferedWriter 的用法"></a>字符缓冲流 BufferedReader 和 BufferedWriter 的用法</h3><p>复制文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>);</span><br><span class="line">             BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">             BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bfr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bfw.write(chars, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特有方法——按行读取和写入：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>);</span><br><span class="line">             BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">             BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw)) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bfr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bfw.write(line);</span><br><span class="line">                bfw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>性能优于 FileReader 和 FileWriter。</p>
<p>FileWriter 每次调用 <code>write()</code> 方法，都会直接写入磁盘，不但效率低，性能也差。而 BufferedWriter 每次调用 <code>write()</code> 方法，会先写入缓冲区，直到缓冲区满了才写入磁盘。查看 BufferedWriter 源码可知 <code>defaultCharBufferSize = 8192;</code>，即缓冲区大小默认是 8 K，可以在构造方法时，指定缓冲区的大小，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr, <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw, <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>)；</span><br></pre></td></tr></table></figure>

<p>对于文本文件，推荐使用 BufferedReader 和 BufferedWriter 两个字符缓冲流对象处理。</p>
<p>使用字符流复制文件时，建议采用逐字符复制和逐行复制两种方式。</p>
</blockquote>
<h3 id="关于-flush-方法的特别说明"><a href="#关于-flush-方法的特别说明" class="headerlink" title="关于 flush() 方法的特别说明"></a>关于 <code>flush()</code> 方法的特别说明</h3><p>使用缓冲流时，默认情况要等缓冲区满了才会写入磁盘，或者调用 <code>close()</code> 方法关闭文件时也会写入磁盘，如果希望立即将缓冲区中的数据写入磁盘，则需要调用 <code>flush()</code> 方法。</p>
<p>另外，创建的流对象均应放在 try 结构体上，这样 java 会自动关闭流对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>)) &#123;</span><br><span class="line">            BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bfr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bfw.write(line);</span><br><span class="line">                bfw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            bfw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法，缓冲流对象没有放在 try 结构体上，如果不调用 <code>flush()</code> 方法，可能会造成数据丢失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:/read.txt&quot;</span>);</span><br><span class="line">             FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E:/copy-read.txt&quot;</span>);</span><br><span class="line">             BufferedReader bfr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">             BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw)) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bfr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bfw.write(line);</span><br><span class="line">                bfw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法，缓冲流对象放在 try 结构体上，不需要调用 <code>flush()</code> 方法，java 会自动关闭流，在关闭之前，会将缓冲区中的数据写入磁盘。</p>
<h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903985078337550#heading-55">https://juejin.cn/post/6844903985078337550#heading-55</a></p>
<p>声明：写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 <a href="mailto:wdshfut@163.com">wdshfut@163.com</a>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/24/kafka-consumer-commitandpartition/" rel="prev" title="KafkaConsumer 源码之 consumer 的 offset commit 机制和 partition 分配机制">
      <i class="fa fa-chevron-left"></i> KafkaConsumer 源码之 consumer 的 offset commit 机制和 partition 分配机制
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/14/java-io-close/" rel="next" title="java 关闭 IO 流">
      java 关闭 IO 流 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#File-%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">File 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#File-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">File  概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">获取功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.2.</span> <span class="nav-text">获取绝对路径和相对路径功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">判断功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">创建删除功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.5.</span> <span class="nav-text">目录的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%AD%90%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.6.</span> <span class="nav-text">递归遍历文件夹下所有文件以及子文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E6%8E%A2-IO-%E6%B5%81"><span class="nav-number">2.</span> <span class="nav-text">初探 IO 流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-IO"><span class="nav-number">2.1.</span> <span class="nav-text">什么是 IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">IO 的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-IO-%E7%9A%84%E5%88%86%E6%B5%81%E5%90%91%E8%AF%B4%E6%98%8E"><span class="nav-number">2.3.</span> <span class="nav-text">关于 IO 的分流向说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81-InputStream-%E4%B8%8E-OutputStream"><span class="nav-number">3.</span> <span class="nav-text">字节流 InputStream 与 OutputStream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%96%E7%95%8C%E9%87%8C%E4%B8%80%E5%88%87%E7%9A%86%E4%B8%BA%E5%AD%97%E8%8A%82"><span class="nav-number">3.1.</span> <span class="nav-text">文件的世界里一切皆为字节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81-InputStream"><span class="nav-number">3.2.</span> <span class="nav-text">字节输入流 InputStream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileInputStream-%E7%B1%BB"><span class="nav-number">3.2.1.</span> <span class="nav-text">FileInputStream 类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileInputStream-%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">FileInputStream 的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileInputStream-%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">FileInputStream 读取字节数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81-OutputStream"><span class="nav-number">3.3.</span> <span class="nav-text">字节输出流 OutputStream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileOutputStream-%E7%B1%BB"><span class="nav-number">3.3.1.</span> <span class="nav-text">FileOutputStream 类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileOutputStream-%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">FileOutputStream 的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileOutputStream-%E5%86%99%E5%87%BA%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">FileOutputStream 写出字节数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileOutputStream-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%BF%BD%E5%8A%A0%E7%BB%AD%E5%86%99%E3%80%81%E6%8D%A2%E8%A1%8C"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">FileOutputStream 实现数据追加续写、换行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileInputStream-%E5%92%8C-FileOutputStream-%E5%AE%8C%E6%88%90%E5%9B%BE%E7%89%87%E5%A4%8D%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">FileInputStream 和 FileOutputStream 完成图片复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81-Reader-%E5%92%8C-Writer"><span class="nav-number">4.</span> <span class="nav-text">字符流 Reader 和 Writer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="nav-number">4.1.</span> <span class="nav-text">字符流的由来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81-Reader"><span class="nav-number">4.2.</span> <span class="nav-text">字符输入流 Reader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileReader-%E7%B1%BB"><span class="nav-number">4.2.1.</span> <span class="nav-text">FileReader 类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileReader-%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">FileReader 的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileReader-%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">FileReader 读取字符数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81-Writer"><span class="nav-number">4.3.</span> <span class="nav-text">字符输出流 Writer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileWriter-%E7%B1%BB"><span class="nav-number">4.3.1.</span> <span class="nav-text">FileWriter 类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileWriter-%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">FileWriter 的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileWriter-%E5%86%99%E5%87%BA%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">FileWriter 写出字符数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%97%AD-close-%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%B7%E6%96%B0-flush-%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">关闭 close() 方法和刷新 flush() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileWriter-%E7%9A%84%E8%BF%BD%E5%8A%A0%E5%92%8C%E6%8D%A2%E8%A1%8C"><span class="nav-number">4.3.1.4.</span> <span class="nav-text">FileWriter 的追加和换行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileReader-%E5%92%8C-FileWriter-%E5%AE%8C%E6%88%90%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">4.3.2.</span> <span class="nav-text">FileReader 和 FileWriter 完成文本文件复制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">IO 异常的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">6.</span> <span class="nav-text">缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81-BufferedInputStream-%E5%92%8C-BufferedOutputStream"><span class="nav-number">6.1.</span> <span class="nav-text">字节缓冲流 BufferedInputStream 和 BufferedOutputStream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="nav-number">6.1.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">6.1.2.</span> <span class="nav-text">高效的字节缓冲流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81-BufferedReader-%E5%92%8C-BufferedWriter"><span class="nav-number">6.2.</span> <span class="nav-text">字符缓冲流 BufferedReader 和 BufferedWriter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="nav-number">6.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">6.2.2.</span> <span class="nav-text">高效的字符缓冲流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.3.</span> <span class="nav-text">字符缓冲流的特有方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">7.</span> <span class="nav-text">转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81"><span class="nav-number">7.1.</span> <span class="nav-text">编码与解码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-number">7.2.</span> <span class="nav-text">字符集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E4%B9%B1%E7%A0%81"><span class="nav-number">7.3.</span> <span class="nav-text">编码问题导致乱码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputStreamReader-%E7%B1%BB-%E2%80%94-%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%B0%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E6%A1%A5%E6%A2%81"><span class="nav-number">7.4.</span> <span class="nav-text">InputStreamReader 类 — 字节流到字符流的桥梁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="nav-number">7.4.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2%E6%B5%81%E8%A7%A3%E5%86%B3%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98-%E2%80%94-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">7.4.2.</span> <span class="nav-text">使用转换流解决编码问题 — 读文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutputStreamWriter-%E7%B1%BB-%E2%80%94-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%88%B0%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E6%A1%A5%E6%A2%81"><span class="nav-number">7.5.</span> <span class="nav-text">OutputStreamWriter 类 — 字符流到字节流的桥梁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-4"><span class="nav-number">7.5.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2%E6%B5%81%E8%A7%A3%E5%86%B3%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98-%E2%80%94-%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">7.5.2.</span> <span class="nav-text">使用转换流解决编码问题 — 写文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="nav-number">8.</span> <span class="nav-text">序列化流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">8.1.</span> <span class="nav-text">什么是序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectOutputStream-%E7%B1%BB"><span class="nav-number">8.2.</span> <span class="nav-text">ObjectOutputStream 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-5"><span class="nav-number">8.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-number">8.2.2.</span> <span class="nav-text">序列化操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectInputStream%E7%B1%BB"><span class="nav-number">8.3.</span> <span class="nav-text">ObjectInputStream类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-6"><span class="nav-number">8.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-number">8.3.2.</span> <span class="nav-text">反序列化操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E7%89%88%E6%9C%AC%E5%8F%B7-serialVersionUID"><span class="nav-number">8.4.</span> <span class="nav-text">序列版本号 serialVersionUID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">9.</span> <span class="nav-text">打印流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">9.1.</span> <span class="nav-text">什么是打印流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%89%93%E5%8D%B0%E6%B5%81-PrintStream-%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">9.2.</span> <span class="nav-text">字节输出打印流 PrintStream 复制文本文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%89%93%E5%8D%B0%E6%B5%81-PrintWriter-%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">9.3.</span> <span class="nav-text">字符输出打印流 PrintWriter 复制文本文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Properties-%E5%B1%9E%E6%80%A7%E7%B1%BB"><span class="nav-number">10.</span> <span class="nav-text">Properties 属性类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties-%E6%A6%82%E8%BF%B0"><span class="nav-number">10.1.</span> <span class="nav-text">Properties 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties-%E7%B1%BB"><span class="nav-number">10.2.</span> <span class="nav-text">Properties 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-7"><span class="nav-number">10.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="nav-number">10.2.2.</span> <span class="nav-text">基本的存储方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E6%B5%81%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">10.2.3.</span> <span class="nav-text">与流相关的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81-FileInputStream-%E5%92%8C-FileOutputStream-%E7%94%A8%E6%B3%95"><span class="nav-number">11.1.</span> <span class="nav-text">字节流 FileInputStream 和 FileOutputStream 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81-FileReader-%E5%92%8C-FileWriter-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">11.2.</span> <span class="nav-text">字符流 FileReader 和 FileWriter 的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81-BufferedInputStream-%E5%92%8C-BufferedOutputStream-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">11.3.</span> <span class="nav-text">字节缓冲流 BufferedInputStream 和 BufferedOutputStream 的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81-BufferedReader-%E5%92%8C-BufferedWriter-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">11.4.</span> <span class="nav-text">字符缓冲流 BufferedReader 和 BufferedWriter 的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-flush-%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E5%88%AB%E8%AF%B4%E6%98%8E"><span class="nav-number">11.5.</span> <span class="nav-text">关于 flush() 方法的特别说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83"><span class="nav-number">12.</span> <span class="nav-text">本文参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XiSun"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">XiSun</p>
  <div class="site-description" itemprop="description">心如止水者，虽世间繁华之红尘纷扰，已然空无一物</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiSun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">607k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:12</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
